[{"title":"Redis基础篇","url":"/2024/03/04/Redis基础篇/","content":"\n<a name=\"AAv2g\"></a>\n## 1. Redis简介\n> Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n- Redis的特征：\n   - 键值（`key-value`）型，value支持多种不同数据结构，功能丰富；\n   - 单线程，每个命令具备原子性；\n   - 低延迟，速度快（基于内存、IO多路复用、良好的编码）；\n   - 支持数据持久化；\n   - 支持主从集群、分片集群；\n   - 支持多语言客户端。\n- 什么是NoSQL：\n   - NoSQL最常见的解释是\"non-relational\"， 很多人也说它是\"_**Not Only SQL**_\"；\n   - NoSQL仅仅是一个概念，泛指**非关系型的数据库；**\n   - 区别于关系数据库，它们不保证关系数据的ACID特性（原子性 (Atomicity)、 一致性；(Consistency)、隔离性(Isolation) 和 持久性(Durability)）；\n   - NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入；\n   - 常见的NoSQL数据库有：`Redis`、`MemCache`、`MongoDB`等。\n- NoSQL与SQL的差异：\n\n| 属性 | SQL | NoSQL |\n| :-: | :-: | :-: |\n| 数据结构 | 结构化 | 非结构化 |\n| 数据关联 | 关联的 | 无关联的 |\n| 查询方式 | SQL查询 | 非SQL |\n| 事务特性 | ACID | BASE |\n| 存储方式 | 磁盘 | 内存 |\n| 扩展性 | 垂直 | 水平 |\n| 使用场景 | （1）数据结构固定<br />（2）相关业务对数据安全性、一致性要求较高 | （1）数据结构不固定<br />（2）对一致性、安全性要求不高<br />（3）对性能要求 |\n\n<a name=\"fRycZ\"></a>\n## 2. Redis安装\n<a name=\"ZO5Z0\"></a>\n### 2.1 ubuntu安装 \n\n- ubunutu指令安装：\n```shell\napt install redis-server\n```\n\n- 检查安装：\n```shell\nservice redis-server start\n\n# 检查启动情况\nps -ef | grep redis # 进程检查\nnetstat -anp | grep redis # 端口检查\n```\n\n- 启动redis服务：\n```shell\nservice redis-server start\n```\n\n- 连接redis客户端：\n```shell\n# 需要在客户端上对redis进行操作\nredis-cli\n```\n<a name=\"jVgJz\"></a>\n### 2.2 linux源码安装\n> 由于redis使用C语言编写，所以想要使用源码编译安装，必须先安装编译器再执行后续步骤。\n> `apt install gcc`：为了编译源代码\n> `apt install make`：为了自动化构建项目\n\n- 解压压缩包\n```shell\ntar -zxvf redis-6.0.6.tar.gz\n```\n\n- 进入源码目录\n```shell\ncd redis-6.0.6\n```\n\n- 执行编译\n```shell\n# 需要主机上有C语言的编译环境，即gcc 等编译工具链\nmake\n```\n\n- 默认安装\n```shell\n# 默认地，相关程序会被安装到 /usr/local/bin 目录下,例如 /usr/local/bin/redis-server\nmake install\n```\n  - 或者安装到指定目录\n```shell\nexport PREFIX=/opt/redis\nmake install\n```\n\n- 运行\n```shell\ncd /usr/local/bin/\nredis-server\n# 运行时也可以指定配置文件路径\nredis-server  /path/of/redis/redis.conf\n```\n<a name=\"BEQuA\"></a>\n### 2.3 设置开机自启\n> Redis推荐开机自启\n\n- 首先，新建一个系统服务文件 ：\n```shell\nvi /etc/systemd/system/redis.service\n```\n\n- 粘贴一下内容：\n```nginx\n[Unit]\nDescription=redis-server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n- 然后重载系统服务 ：\n```shell\nsystemctl daemon-reload\n```\n\n- 之后，我们可以用下面这组命令来操作redis：\n```shell\n# 启动\nsystemctl start redis\n# 停止\nsystemctl stop redis\n# 重启\nsystemctl restart redis\n# 查看状态\nsystemctl status redis\n```\n\n- 执行下面的命令，可以让redis开机自启 \n```shell\nsystemctl enable redis\n```\n<a name=\"x4NCY\"></a>\n## 3. 修改配置文件\n找到`/etc/redis/`下的`redis.conf`文件使用`vim`编辑：\n\n1. 绑定ip配置：当服务器存在多个网卡(IP) 时，让服务器监听哪个IP\n```shell\nbind 127.0.0.1 # 只能从本机访问\nbind 192.168.43.128 # 只能从内网访问\nbind 202.10.8.130  # 可以从外网访问\nbind 0.0.0.0  # 可以从任意位置访问此服务器 (比较常用)\n```\n\n2. 设置密码：\n```shell\n# 找到requirepass这一行 使用/requirepass + n 或者 ?requirepass + n 快速查找（vim知识点）\nrequirepass 1a2b3c # 密码尽量复杂些，避免被破解\n```\n\n3. 重启`redis`服务：\n```shell\n# 不重启服务输入密码不通过\nservice redis-server restart\n```\n\n4. 连接客户端：\n```shell\nredis-cli\n# 验证密码\nauth 1a2b3c\n# 也可以将以上两步合为一步 redis-cli -a a1b2c3\nping # 服务端正常会返回pong\n```\n<a name=\"CEe0H\"></a>\n## 4. Redis命令\n<a name=\"I5L8G\"></a>\n### 4.1 通用命令\n| 指令 | 描述 |\n| :-: | :-: |\n| KEYS | 查看符合模板的所有key，不建议在生产环境设备上使用 |\n| DEL | 删除一个指定的key |\n| EXISTS | 判断key是否存在 |\n| EXPIRE | 给一个key设置有效期，有效期到期时该key会被自动删除 |\n| TTL | 查看一个KEY的剩余有效期 |\n\n> 可以通过`help [command]`查看一个命令的具体用法！\n\n<a name=\"OzXhr\"></a>\n### 4.2 各个数据类型命令\n<a name=\"IweAd\"></a>\n\n#### 4.2.1 String\n**String的常见命令：**\n- `SET`：添加或者修改已经存在的一个String类型的键值对\n- `GET`：根据key获取String类型的value\n- `MSET`：批量添加多个String类型的键值对\n- `MGET`：根据多个key获取多个String类型的value\n- `INCR`：让一个整型的key自增1\n- `INCRBY`:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\n- `INCRBYFLOAT`：让一个浮点类型的数字自增并指定步长\n- `SETNX`：添加一个String类型的键值对，前提是这个key不存在，否则不执行\n- `SETEX`：添加一个String类型的键值对，并且指定有效期\n\n**注意：**\n- 以上命令除了`INCRBYFLOAT`都是常用命令\n- `SET`和`GET`：如果key不存在则是新增，如果存在则是修改\n```shell\n127.0.0.1:6379> set name Rose  //原来不存在\nOK\n\n127.0.0.1:6379> get name \n\"Rose\"\n\n127.0.0.1:6379> set name Jack //原来存在，就是修改\nOK\n\n127.0.0.1:6379> get name\n\"Jack\"\n```\n<a name=\"TwBwp\"></a>\n#### 4.2.2 Hash\n**Hash类型的常见命令:**\n- `HSET key field value`：添加或者修改hash类型key的field的值\n- `HGET key field`：获取一个hash类型key的field的值\n- `HMSET`：批量添加多个hash类型key的field的值\n- `HMGET`：批量获取多个hash类型key的field的值\n- `HGETALL`：获取一个hash类型的key中的所有的field和value\n- `HKEYS`：获取一个hash类型的key中的所有的field\n- `HINCRBY`:让一个hash类型key的字段值自增并指定步长\n- `HSETNX`：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n  <a name=\"nXnw9\"></a>\n#### 4.2.3 List\n**List的常见命令：**\n- `LPUSH key element ... `：向列表左侧插入一个或多个元素\n- `LPOP key`：移除并返回列表左侧的第一个元素，没有则返回nil\n- `RPUSH key element ...`：向列表右侧插入一个或多个元素\n- `RPOP key`：移除并返回列表右侧的第一个元素\n- `LRANGE key star end`：返回一段角标范围内的所有元素\n- `BLPOP`和`BRPOP`：与`LPOP`和`RPOP`类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/07/126318_7e02f584dc-4.2.3list.png)\n<a name=\"WMrHG\"></a>\n#### 4.2.4 Set\n**Set类型的常见命令：**\n- `SADD key member ...`：向set中添加一个或多个元素\n- `SREM key member ...`: 移除set中的指定元素\n- `SCARD key`： 返回set中元素的个数\n- `SISMEMBER key member`：判断一个元素是否存在于set中\n- `SMEMBERS`：获取set中的所有元素\n- `SINTER key1 key2 ...`：求key1与key2的交集\n- `SDIFF key1 key2 ...`：求key1与key2的差集\n- `SUNION key1 key2 ...`：求key1和key2的并集\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/07/126318_81ff1000dc-4.2.4set.png)\n<a name=\"m4FJA\"></a>\n#### 4.2.5 SortedSet\n**SortedSet的常见命令：**\n- `ZADD key score member`：添加一个或多个元素到SortedSet ，如果已经存在则更新其score值\n- `ZREM key member`：删除SortedSet中的一个指定元素\n- `ZSCORE key member` : 获取SortedSet中的指定元素的score值\n- `ZRANK key member`：获取SortedSet 中的指定元素的排名\n- `ZCARD key`：获取SortedSet中的元素个数\n- `ZCOUNT key min max`：统计score值在给定范围内的所有元素的个数\n- `ZINCRBY key increment member`：让SortedSet中的指定元素自增，步长为指定的increment值\n- `ZRANGE key min max`：按照score排序后，获取指定排名范围内的元素\n- `ZRANGEBYSCORE key min max`：按照score排序后，获取指定score范围内的元素\n- `ZDIFF.ZINTER.ZUNION`：求差集、交集、并集\n\n**注意：**<br />所有的排名默认都是升序，如果要降序则在命令的`Z`后面添加`REV`即可，例如：\n- **升序**获取SortedSet中的指定元素的排名：`ZRANK key member`\n- **降序**获取SortedSet中的指定元素的排名：`ZREVRANK key memeber`\n  <a name=\"FadCZ\"></a>\n## 5. Redis的Java客户端\n<a name=\"BpC55\"></a>\n### 5.1 目前主流的Redis的Java客户端：\n\n- **Jedis和Lettuce：** 这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。\n- **Redisson：** 是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。\n<a name=\"eMiZZ\"></a>\n### 5.2 Jedis快速入门\n**不使用连接池：**\n\n- 引入相关依赖\n```xml\n<!--jedis-->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n\n<!--单元测试-->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.7.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n- 建立测试类\n```java\nprivate Jedis jedis;\n\n// 建立连接\n@BeforeEach\nvoid setUp() {\n    // 建立连接（ip + port）\n    jedis = new Jedis(\"127.0.0.1\", 6379);\n    // 设置密码\n    jedis.auth(\"1a2b3c\");\n    // 选择库（总共16个库）\n    jedis.select(0);\n}\n\n// 释放资源\n@AfterEach\nvoid tearDown(){\n    if (jedis != null){\n        jedis.close();\n    }\n}\n```\n\n- 在测试类中进行测试\n```java\n// 测试String\n@Test\nvoid testString(){\n    jedis.set(\"name\",\"SmallBoat\");\n    String name = jedis.get(\"name\");\n    System.out.println(\"name: \" + name);\n}\n\n// 测试Hash\n@Test\nvoid testHash(){\n    jedis.hset(\"user:1\",\"name\",\"Jack\");\n    jedis.hset(\"user:2\",\"name\",\"Rose\");\n    jedis.hset(\"user:1\",\"age\",\"21\");\n    jedis.hset(\"user:2\",\"age\",\"18\");\n    Map<String, String> map = jedis.hgetAll(\"user:1\");\n    System.out.println(map);\n}\n```\n**使用连接池：**\n> Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式。\n\n- 创建JedisConnectionFactory工具类\n```java\npublic class JedisConnectionFactory {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 配置连接池\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(8);\n        poolConfig.setMaxIdle(8);\n        poolConfig.setMinIdle(0);\n        poolConfig.setMaxWaitMillis(1000);\n        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码\n        jedisPool = new JedisPool(poolConfig, \"127.0.0.1\", 6379, 1000, \"1a2b3c\");\n    }\n\n    public static Jedis getJedis(){\n        return jedisPool.getResource();\n    }\n}\n```\n\n- 创建测试类\n```java\n@SpringBootTest\nclass RedisTestApplicationTests {\n\n    private Jedis jedis = JedisConnectionFactory.getJedis();\n\n    // 测试String\n    @Test\n    void testString(){\n        jedis.set(\"name\",\"SmallBoat\");\n        String name = jedis.get(\"name\");\n        System.out.println(\"name: \" + name);\n    }\n\n    // 测试Hash\n    @Test\n    void testHash(){\n        jedis.hset(\"user:1\",\"name\",\"Jack\");\n        jedis.hset(\"user:2\",\"name\",\"Rose\");\n        jedis.hset(\"user:3\",\"name\",\"SmallBoat\");\n        jedis.hset(\"user:1\",\"age\",\"21\");\n        jedis.hset(\"user:2\",\"age\",\"18\");\n        jedis.hset(\"user:3\",\"age\",\"18\");\n        Map<String, String> map = jedis.hgetAll(\"user:3\");\n        System.out.println(map);\n    }\n\n    // 释放资源\n    @AfterEach\n    void tearDown(){\n        if (jedis != null){\n            jedis.close();\n        }\n    }\n}\n```\n<a name=\"Tj3JO\"></a>\n### 5.3 SpringDataRedis快速入门\n<a name=\"z49za\"></a>\n#### 5.3.1 SpringDataRedis简介\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis。<br />**特性：**\n\n- 提供了对不同Redis的Java客户端的整合（包括Jedis和Lettuce）；\n- 提供了RedisTemplate统一API来操作Redis；\n- 支持Redis的发布订阅模型；\n- 支持Redis哨兵和Redis集群；\n- 支持基于Lettuce的响应式编程；\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化；\n- 支持基于Redis的JDKCollection实现。\n\n**redisTemplate的各种API：**\n\n| API | 返回值类型 | 说明 |\n| :-: | :-: | :-: |\n| redisTemplate.opsForValue() | ValueOperations | 操作String类型数据 |\n| redisTemplate.opsForHash() | HashOperations | 操作Hash类型数据 |\n| redisTemplate.opsForList() | ListOperations | 操作List类型数据 |\n| redisTemplate.opsForSet() | SetOperations | 操作Set类型数据 |\n| redisTemplate.opsForzSet() | ZSetOperations | 操作SortedSet类型数据 |\n\n<a name=\"KgQPI\"></a>\n#### 5.3.2 示例\n\n- 引入相关依赖\n```xml\n<!--redis依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--common-pool-->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n<!--Jackson依赖-->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n<!--lombok-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n- 在yaml文件中配置redis\n```yaml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n    password: 1a2b3c\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        min-idle: 0\n        max-wait: 100ms\n```\n\n- 测试\n```java\n// 因为有了SpringBoot自动装配的加持，在使用的时候直接注入即可\n@Autowired\nprivate RedisTemplate redisTemplate;\n\n@Test\nvoid stringTest(){\n    redisTemplate.opsForValue().set(\"username\", \"SmallBoat\");\n    String username = (String) redisTemplate.opsForValue().get(\"username\");\n    System.out.println(username);\n}\n```\n<a name=\"qh8Dg\"></a>\n#### 5.3.3 序列化\nRedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果类似于：`\\xAC\\xED\\x00\\x05t\\x00\\x06\\xE5\\xBC\\xA0\\xE4\\xB8\\x89`<br />我们可以看到，如果使用默认的序列化工具，不仅可读性差，而且还浪费内存。于是我们需要自定义RedisTemplate的序列化方式。<br />**自定义序列化：**\n\n- 编写Redis配置类\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建RedisTemplate对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n        // 创建JSON序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\n                new GenericJackson2JsonRedisSerializer();\n        // 设置Key的序列化\n        template.setKeySerializer(RedisSerializer.string());\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置Value的序列化\n        template.setValueSerializer(jsonRedisSerializer);\n        template.setHashValueSerializer(jsonRedisSerializer);\n        // 返回\n        return template;\n    }\n}\n```\n\n- 得到的存储结果\n```json\n{\n  \"@class\": \"com.cxc.pojo.User\",\n  \"name\": \"SmallBoat\",\n  \"age\": 18\n}\n```\n> 由于我们使用了Json序列化代替jdk序列化，当我们使用自定义序列化后，整体可读性得到提升，且能将Java对象自动的序列化为JSON字符串，并且查询时还能自动把JSON反序列化为Java对象。但是，在存数据时会记录序列化时对应的Class名称（为了查询时实现自动反序列化），这会带来额外的内存开销。因此，再介绍一种方案：StringRedisTemplate\n\n<a name=\"kGAlK\"></a>\n#### 5.3.4 StringRedisTemplate\n为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，这样就只能存储String类型的key和value。所以，当需要存储Java对象时，需要手动完成对象的序列化和反序列化。因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis。<br />由于这种用法比较普遍，于是乎SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。<br />**StringRedisTemplate源码：**\n```java\npublic class StringRedisTemplate extends RedisTemplate<String, String> {\n    public StringRedisTemplate() {\n        this.setKeySerializer(RedisSerializer.string());\n        this.setValueSerializer(RedisSerializer.string());\n        this.setHashKeySerializer(RedisSerializer.string());\n        this.setHashValueSerializer(RedisSerializer.string());\n    }\n\n    public StringRedisTemplate(RedisConnectionFactory connectionFactory) {\n        this();\n        this.setConnectionFactory(connectionFactory);\n        this.afterPropertiesSet();\n    }\n\n    protected RedisConnection preProcessConnection(RedisConnection connection, boolean existingConnection) {\n        return new DefaultStringRedisConnection(connection);\n    }\n}\n```\n有了StringRedisTemplate，我们就不需要再进行自定义序列化了，而是直接进行使用。\n\n- 测试\n```java\n// 使用StringRedisTemplate测试String\n@Test\nvoid stringTest() throws JsonProcessingException {\n    // 创建对象\n    User user = new User(\"SmallBoat\", 18);\n    // 手动序列化\n    String userjson = mapper.writeValueAsString(user);\n    // 写入数据\n    stringRedisTemplate.opsForValue().set(\"userjson\", userjson);\n    // 获取数据\n    String getUserjson = stringRedisTemplate.opsForValue().get(\"userjson\");\n    // 手动反序列化\n    User getUser = mapper.readValue(getUserjson, User.class);\n    System.out.println(getUser);\n}\n```\n\n- 存储结果\n```json\n{\n  \"name\": \"SmallBoat\",\n  \"age\": 18\n}\n```\n\n","categories":["Redis"]},{"title":"King of Bots项目总结","url":"/2024/02/27/King of Bots项目总结/","content":"\n<a name=\"xvTck\"></a>\n## 1. 项目规划\n- 使用其后端分离方式完成本项目。其中，前端使用`Vue3`完成，后端使用`SpringBoot2`完成。\n\n![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_235f9eadd9-1.项目规划.png)\n\n- 技术栈：\n\n| **技术** | **说明** |\n| :-: | :-: |\n| SpringBoot | 容器+MVC框架 |\n| mysql | 关系型数据库 |\n| JWT | 登录支持 |\n| SpringSecurity | 验证和授权框架 |\n| Redis | 缓存数据库 |\n| Lombok | 简化对象封装工具 |\n| MyBatisPlus | ORM框架 |\n| MicroService（SpringCloud） | 微服务 |\n\n- 项目（游戏）设计逻辑：\n\n![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_1d7f8b70d9-1.2.项目逻辑设计.png)\n<a name=\"P2aiK\"></a>\n## 2. 环境配置与项目创建\n<a name=\"ue2bM\"></a>\n### 2.1 项目设计\n\n- 名称：`King Of Bots`\n- 项目包含的模块\n- PK模块：匹配界面（微服务）、实况直播界面（`WebSocket`协议）\n   - 对局列表模块：对局列表界面、对局录像界面\n   - 排行榜模块：`Bot`排行榜界面\n   - 用户中心模块：注册界面、登录界面、我的`Bot`界面、每个`Bot`的详情界面\n- 前后端分离模式\n   - `SpringBoot`实现后端\n   - `Vue3`实现`Web`端和`AcApp`端\n   <a name=\"VPYFM\"></a>\n### 2.2 配置git环境\n\n1. 安装`Git Bash`：[https://gitforwindows.org/](https://gitforwindows.org/)\n2. 进入家目录生成秘钥：执行命令`ssh-keygen`\n3. 将`id_rsa.pub`的内容复制到`github`上\n<a name=\"UX9s1\"></a>\n### 2.3 创建项目前后端\n\n- 后端：使用`Spring Initilizr`创建后端，使用`2.3.7REALESE`版本，添加`SpringBoot Web Starter`插件。\n- 前端：使用`Vue cli`脚手架创建项目，添加`Vue Router`和`VueX`插件，添加`BootStrap`与`jquery`依赖。（`Vue ui`创建前端有点奇怪的`bug`，选择位置时不选择默认盘符下的位置就报错，先在该盘符创建再移动到目标盘符去）\n<a name=\"VBmjE\"></a>\n## 3. 创建前端基础页面\n<a name=\"chK2N\"></a>\n### 3.1 创建导航栏及页面\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_2aa880d4d9-3.1创建导航栏.png)<br />通过创建各个页面的`view`，主要包括`error, pk, ranklist, record, user-bot`页面。然后在导航栏中通过`router`进行跳转。<br />通过如下方式实时计算当前页面位于哪个部分，以便于高亮导航栏中的对应部分：\n```javascript\nconst route = useRoute();\nlet route_name = computed(() => route.name)\nreturn {\n  route_name\n}\n```\n<a name=\"cfwHz\"></a>\n### 3.2 创建游戏地图\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_301badf5d9-3.2创建游戏地图.png)<br />首先创建游戏地图基类`AcGameObject`，然后通过继承该类实现`GameMap`游戏地图渲染类。\n\n- 在`AcGameObject`中，通过`requestAnimationFrame(step)`递归实现每`60`帧（因显示器而异）的实时渲染游戏画面。\n- 在`GameMap`中，先将游戏背景（绿布）渲染出来，然后创建四周墙壁，再随机生成内部墙体障碍物，每生成一种方案，通过`Flood Fill`算法检验左下角与右上角的连通性，如果不连通则重新生成。\n\n**注意：** 在后期会将生成地图的逻辑放到后端（前端只负责渲染，暂时放在前端便于当前调试），避免两名用户中有人修改前端代码造成不公平的情况。与此同时，生成的地图为$13 \\times 14$的布局，并确保其是中心对称的。\n> 设计成$13 \\times 14$主要是为了避免两条蛇头能同时到达一个点的情况（平局），避免造成对优势方不利的情况。\n> 解释：若设计为$13 \\times 13$，则刚开始两条蛇的蛇头坐标为`(1, 13), (13, 1)`，双方每走一步，横纵坐标之和的变化都是相同的（偶、奇、偶、奇……），设计成$13 \\times 14$则刚开始两蛇头的坐标为`(1, 14), (13, 1)`，则双方每走一步横纵坐标之和不可能相等，意味着双方的蛇头不可能在同一时间进入同一个格子。\n\n<a name=\"BUfE6\"></a>\n### 3.3 创建蛇类\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_35da8150d9-3.3创建蛇类.png)在创建蛇类前，先要创建蛇的身体类（即`Cell`类）：\n```javascript\nexport class Cell {\n  constructor(r, c) {\n    // 格子坐标\n    this.r = r; \n    this.c = c;\n    \n    this.x = c + 0.5; // 圆心横坐标\n    this.y = r + 0.5; // 圆心纵坐标\n  }\n}\n```\n在定义蛇类时，需要定义其状态、当前移动方向、眼睛的偏移方向。蛇的移动方式为每移动一步，蛇头向前一步，蛇尾砍掉，身体保持不同（前10步，蛇尾不用移动，每次移动只蛇头向前移动即可，长度加1，之后每3步增长一格）。\n> 蛇的身体为一个个圆形`Cell`组成，因此，每两个`Cell`间用长方形进行填充，这样就只有头和尾的`Cell`有圆弧，看起来会比较正常。\n\n在移动时，通过蛇类中的函数设置当前步的前进方向，然后在地图类中进行监听用户操作（后续接入代码操作后，也将调用此函数设置蛇蛇的移动方向）：\n```javascript\nset_direction(d) {\n  this.direction = d;\n}\n```\n然后判断蛇的存活状态（在地图类中进行判断，而不是在蛇类中判断）：\n```javascript\ncheck_valid(cell) {  // 检测目标位置是否合法：没有撞到两条蛇的身体和障碍物\n  for (const wall of this.walls) {\n      if (wall.r === cell.r && wall.c === cell.c)\n          return false;\n  }\n  for (const snake of this.snakes) {\n      let k = snake.cells.length;\n      if (!snake.check_tail_increasing()) {  // 当蛇尾会前进的时候，蛇尾不用判断\n          k -- ;\n      }\n      for (let i = 0; i < k; i ++ ) {\n          if (snake.cells[i].r === cell.r && snake.cells[i].c === cell.c)\n              return false;\n      }\n  }\n  return true;\n}\n```\n<a name=\"KM6d4\"></a>\n## 4. 配置MySql与实现注册登录模块\n在`pom.xml`文件中添加如下依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.24</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <version>8.0.33</version>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.2</version>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-generator</artifactId>\n    <version>3.5.3</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n    <version>3.1.5</version>\n</dependency>\n```\n<a name=\"IdcIv\"></a>\n### 4.1 数据库配置\n数据库使用`MySql8.0`版本，并创建`user`表。`YAML`相关配置如下：\n```yaml\n# 配置数据库连接\nspring:\n  datasource:\n    username: root\n    password: xxxxxxx\n    url: jdbc:mysql://localhost:3306/kob?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n<a name=\"qaDya\"></a>\n### 4.2 登录校验模块\n<a name=\"KX9uz\"></a>\n#### 4.2.1 基本登录功能\n登录模块利用`SpringSecurity`自带的功能即可完成。通过配置`SecurityConfig`配置类、再实现`UserDetailsService, UserDetails`两个接口即可。在`UserDetailsServiceImpl`中先校验用户是否存在，再返回一个**包含用户信息**的`UserDetailsImpl`对象用于校验用户合法性（包括密码校验、用户是否失效、用户是否被锁等等）。\n<a name=\"StVor\"></a>\n#### 4.2.2 引入[JWT](https://www.yuque.com/cxc_lhl/iupfzc/krkag1qcw9gl91u4#xFIlJ)认证\n为了使用`jwt`认证，先在`pom.xml`文件中引入一下依赖：\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>0.11.2</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>0.11.2</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.11.2</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n1. 实现`JwtUtil`类，用于生成和解析`jwt`。\n2. 实现`JwtAuthenticationTokenFilter`类，用于验证用户传递过来的`jwt`，验证成功后，当前用户的信息将会被注入上下文中。\n3. 修改`SecurityConfig`放行`token`及`register`请求。\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.csrf()\n        .disable()\n        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n        .authorizeRequests()\n        .antMatchers(\"/user/account/token/\", \"/user/account/register/\").permitAll()\n        .antMatchers(HttpMethod.OPTIONS).permitAll()\n        .anyRequest().authenticated();\n    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n}\n```\n\n- 再分别创建三个接口`/user/account/token/, /user/account/info/, /user/account/register/`用于获取`token`、获取用户信息、用户注册。\n> 在调试过程中，发现一个需要注意的细节，在浏览器中复制生成的`token`时，需要将其点开再复制，因为当位置不够时，中间很长一部分会议省略号形式展示，复制后根本无法发出请求。\n\n<a name=\"JrIwT\"></a>\n### 4.3 前端注册页面实现\n注册页面与登录页面极其类似，直接复制过来修改一下即可。<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_3991b228d9-4.3前端注册页面实现.png)\n<a name=\"DuFMp\"></a>\n### 4.4 将jwt信息存进localStorage\n每当用户登录成功时，我们就将其获取到的`jwt`存进`localStorage`中。\n```javascript\nlocalStorage.setItem(\"jwt\", resp.token)\n```\n然后在每次路由跳转到登录页时，闲取出`localStorage`中的`jwt`信息，然后发送获取用户信息的请求以校验当前的`jwt`是否过期。\n```javascript\nconst jwt = localStorage.getItem(\"jwt\")\nif (jwt) {\n  store.commit(\"updateToken\", jwt)\n  store.dispatch(\"getInfo\", {\n    success() {\n      router.push({name: \"home\"})\n      store.commit(\"updatePullingInfo\", false)\n    },\n    error() {\n      store.commit(\"updatePullingInfo\", false)\n    }\n  })\n} else {\n  store.commit(\"updatePullingInfo\", false)\n}\n```\n如果成功，则路由直接跳转到首页，否则显示登录页让用户重新登录。\n> 其中，`updatePullingInfo`是`user.js`中的用于修改全局变量`pulling_info`的函数，`pulling_info`用于控制当前是否处于获取用户信息状态（避免此时登录页会闪一下的问题），当用户信息拉取完毕时，成功就跳转首页，失败就正常显示登录页。\n\n```javascript\nupdatePullingInfo(state, pulling_info) {\n    state.pulling_info = pulling_info\n}\n```\n<a name=\"lVLd6\"></a>\n## 5. 个人中心（我的Bot）\n<a name=\"p2qBF\"></a>\n### 5.1 Bot的CRUD（后端）\n`Bot`的`CRUD`是一些比较重复性的工作，此处以`add`举例。\n```java\n@Override\npublic Map<String, String> add(Map<String, String> botData) {\n    UsernamePasswordAuthenticationToken authenticationToken =\n            (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();\n    UserDetailsImpl loginUser = (UserDetailsImpl) authenticationToken.getPrincipal();\n    User user = loginUser.getUser();\n\n    String title = botData.get(\"title\");\n    String description = botData.get(\"description\");\n    String content = botData.get(\"content\");\n\n    Map<String, String> map = new HashMap<>();\n\n    if (null == title || title.length() == 0) {\n        map.put(\"error_massage\", \"Bot标题不能为空！\");\n        return map;\n    }\n    if (title.length() > 50) {\n        map.put(\"error_message\", \"Bot标题长度不能超过50！\");\n        return map;\n    }\n\n    // 描述可以为空\n    if (null == description || description.length() == 0) {\n        description = \"这个用户很懒，什么也没写~\";\n    }\n    if (description.length() > 200) {\n        map.put(\"error_message\", \"Bot描述长度不能超过200！\");\n        return map;\n    }\n\n    if (null == content || content.length() == 0) {\n        map.put(\"error_message\", \"Bot代码不能为空！\");\n        return map;\n    }\n    if (content.length() > 10000) {\n        map.put(\"error_message\", \"Bot代码长度不能超过10000！\");\n        return map;\n    }\n\n    // 校验一下该 bot的标题和代码，是否已创建过\n    QueryWrapper<Bot> botQueryWrapper = new QueryWrapper<>();\n    botQueryWrapper.eq(\"user_id\", user.getId());\n    botQueryWrapper.and(wrapper -> wrapper.eq(\"content\", content).or().eq(\"title\", title));\n    Long count = botMapper.selectCount(botQueryWrapper);\n    if (count > 0) {\n        map.put(\"error_message\", \"该Bot已经被你创建过啦，创建一个新的吧！\");\n        return map;\n    }\n\n    Date now = new Date();\n    System.out.println(now);\n    Bot bot = new Bot(null, user.getId(), title, description, content, DEFAULT_RATING, now, now, null);\n    System.out.println(bot);\n\n    int state = botMapper.insert(bot);\n    if (state > 0) {\n        map.put(\"error_message\", \"success\");\n        return map;\n    }\n\n    map.put(\"error_message\", \"创建失败！\");\n    return map;\n}\n```\n`CRUD`部分基本都类似，主要是一些限制条件要限制好，不然前端代码如果被修改，数据安全性得不到保证。\n> 正如 yxc 所说，前端防君子，后端防小人！\n> 这里创建Bot类时有个需要注意的地方，时区一定要通过`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"Asia/Shanghai\")`规定好，不然会出现前后端时间相差8小时的情况（具体可参考[使用@JsonFormat注解前后端时间相差8小时](https://blog.csdn.net/m0_65894434/article/details/134997740)）。\n\n<a name=\"bpIYU\"></a>\n### 5.2 Bot的CRUD（前端）\n前端实现`CRUD`比较容易，使用`BootStrap`中的样式即可。唯一麻烦点的是引入`ace`代码编辑器。\n\n- **我的Bot页面：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_3e2a0c6bd9-5.2.1我的bot页面.png)\n\n- **创建Bot的**`Modal`**框：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_43f08b5cd9-5.2.2创建bot的modal框.png)\n\n- **修改Bot的**`Modal`**框：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_4684fd31d9-5.2.3修改bot的modal框.png)\n> 注意：在引入`ace`代码编辑器时，在调试时可能会因为浏览器的问题而导致代码高亮、自动提示等出现不符合预期的问题，切换浏览器尝试一下。\n\n<a name=\"D2Q1e\"></a>\n## 6. 微服务：实现匹配系统\n<a name=\"p1O0M\"></a>\n### 6.1 后端（backend）集成WebSocket\n\n1. 在`pom.xml`文件中添加依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n    <version>2.7.2</version>\n</dependency>\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>2.0.11</version>\n</dependency>\n```\n\n2. 添加`WebSocketConfig`配置类：\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n\n        return new ServerEndpointExporter();\n    }\n}\n```\n\n3. 添加`WebSocketServer`类（核心功能）：\n```java\npackage com.kob.backend.comsumer;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.kob.backend.comsumer.utils.Game;\nimport com.kob.backend.comsumer.utils.JwtAuthentication;\nimport com.kob.backend.mapper.UserMapper;\nimport com.kob.backend.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@ServerEndpoint(\"/websocket/{token}\")  // 不要以'/'结尾\npublic class WebSocketServer {\n\n    private Session session;\n    private User user;\n    // 记录全局的连接信息\n    private static final ConcurrentHashMap<Integer, WebSocketServer> users = new ConcurrentHashMap<>();\n\n    private static final CopyOnWriteArraySet<User> matchpool = new CopyOnWriteArraySet<>();\n\n    private static UserMapper userMapper;\n\n    @Autowired\n    public void setUserMapper(UserMapper userMapper) {\n        WebSocketServer.userMapper = userMapper;\n    }\n\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"token\") String token) throws IOException {\n        // 建立连接\n        this.session = session;\n        Integer userId = JwtAuthentication.getUserId(token);\n        this.user = userMapper.selectById(userId);\n\n        if (null != this.user) {\n            users.put(userId, this);\n            System.out.println(\"connected!\");\n        } else {\n            this.session.close();\n        }\n\n        System.out.println(users);\n\n    }\n\n    @OnClose\n    public void onClose() {\n        // 关闭链接\n        System.out.println(\"disconnected!\");\n        if (null != this.user) {\n            users.remove(this.user.getId());\n            matchpool.remove(this.user);\n        }\n    }\n    \n    private void startMatching() {\n        System.out.println(\"start_matching!\");\n        matchpool.add(this.user);\n        // 暂时实现简单匹配逻辑\n        while (matchpool.size() >= 2) {\n            Iterator<User> it = matchpool.iterator();\n            User a = it.next(), b = it.next();\n            matchpool.remove(a);\n            matchpool.remove(b);\n\n            Game game = new Game(13, 14, 20);\n            game.createMap();\n\n            JSONObject respA = new JSONObject();\n            respA.put(\"event\", \"start-matching\");\n            respA.put(\"opponent_username\", b.getUsername());\n            respA.put(\"opponent_photo\", b.getPhoto());\n            respA.put(\"gameMap\", game.getG());\n            users.get(a.getId()).sendMessage(respA.toJSONString());\n\n            JSONObject respB = new JSONObject();\n            respB.put(\"event\", \"start-matching\");\n            respB.put(\"opponent_username\", a.getUsername());\n            respB.put(\"opponent_photo\", a.getPhoto());\n            respB.put(\"gameMap\", game.getG());\n            users.get(b.getId()).sendMessage(respB.toJSONString());\n        }\n    }\n\n    private void stopMatching() {\n        System.out.println(\"stop_matching!\");\n        matchpool.remove(this.user);\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        // 从 Client 接收消息\n        System.out.println(\"receive message!\");\n        JSONObject data = JSON.parseObject(message);\n        String event = data.getString(\"event\");\n        \n        if (\"start-matching\".equals(event)) {\n            startMatching();\n        } else if (\"stop-matching\".equals(event)) {\n            stopMatching();\n        }\n    }\n\n    public void sendMessage(String message) {\n        // 从 server 发送消息\n        synchronized (this.session) {\n            try {\n                this.session.getBasicRemote().sendText(message);\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n}\n\n```\n\n4. 修改`SecurityConfig`放行`\"/websocket/**\"`请求：\n```java\n@Override\npublic void configure(WebSecurity web) throws Exception {\n    web.ignoring().antMatchers(\"/websocket/**\");\n}\n```\n\n5. 将前端生成地图的逻辑放到后端：\n```java\npackage com.kob.backend.comsumer.utils;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Game {\n    /**\n     * 游戏地图行数\n     */\n    private final Integer rows;\n    /**\n     * 游戏地图列数\n     */\n    private final Integer cols;\n    /**\n     * 地图内部墙体障碍物数量\n     */\n    private final Integer innerWallsCount;\n    /**\n     * 游戏地图（0 表示草地，1 表示墙体障碍物）\n     */\n    private final int[][] g;\n\n    private final static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\n    public Game(Integer rows, Integer cols, Integer innerWallsCount) {\n        this.rows = rows;\n        this.cols = cols;\n        this.innerWallsCount = innerWallsCount;\n        this.g = new int[rows][cols];\n    }\n\n    public int[][] getG() {\n        return g;\n    }\n\n    // Flood Fill 校验地图连通性\n    public boolean checkConnectivity(int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) return true;\n        // 表示已经走过\n        g[sx][sy] = 1;\n        for (int d = 0; d < 4; d ++) {\n            int a = sx + dx[d], b = sy + dy[d];\n            if (a >= 0 && a < this.rows && b >= 0 && b < this.cols && g[a][b] == 0) {\n                if (checkConnectivity(a, b, tx, ty)) {\n                    // 恢复现场\n                    g[sx][sy] = 0;\n                    return true;\n                }\n            }\n        }\n        // 即使校验失败也要恢复现场\n        g[sx][sy] = 0;\n        return false;\n\n    }\n\n    // 画地图\n    private boolean draw() {\n        // 初始化地图\n        for (int i = 0; i < g.length; i ++) {\n            Arrays.fill(g[i], 0);\n        }\n        // 生成四周墙体障碍物\n        for (int r = 0; r < this.rows; r ++) {\n            g[r][0] = g[r][this.cols - 1] = 1;\n        }\n        for (int c = 0; c < this.cols; c ++) {\n            g[0][c] = g[this.rows - 1][c] = 1;\n        }\n        // 生成地图内部随机墙体障碍物\n        Random random = new Random();\n        for (int i = 0; i < this.innerWallsCount >> 1; i ++) {\n            for (int j = 0; j < 1000; j ++) {\n                int r = random.nextInt(this.rows);\n                int c = random.nextInt(this.cols);\n                if (g[r][c] == 1 || g[this.rows - 1 - r][this.cols - 1 - c] == 1) {\n                    continue;\n                }\n                if (r == this.rows - 2 && c == 1 || r == 1 && c == this.cols - 2) {\n                    continue;\n                }\n                g[r][c] = g[this.rows - 1 - r][this.cols - 1 - c] = 1;\n                break;\n            }\n        }\n        // 校验连通性\n        return checkConnectivity(this.rows - 2, 1, 1, this.cols - 2);\n    }\n\n    public void createMap() {\n        // 循环 1000 次，直到成功生成合法地图\n        for (int i = 0; i < 1000; i ++) {\n            if (draw()) {\n                break;\n            }\n        }\n    }\n}\n```\n<a name=\"KNr6s\"></a>\n### 6.2 前端实现匹配界面\n\n1. 前端实现`pk`类，在其中维护当前一次的`pk`需要的变量，其中利用`status`变量动态切换匹配和游戏界面（`status: \"matching\", // matching 表示匹配界面，playing 表示对战界面`）。\n```javascript\nexport default {\n    state: {\n        status: \"matching\",  // matching 表示匹配界面，playing 表示对战界面\n        socket: null,\n        opponent_username: \"\",\n        opponent_photo: \"\",\n        gameMap: null,\n    },\n    getters: {\n    },\n    mutations: {\n        updateSocket(state, socket) {\n            state.socket = socket;\n        },\n        updateOpponent(state, opponent) {\n            state.opponent_username = opponent.username;\n            state.opponent_photo = opponent.photo;\n        },\n        updateStatus(state, status) {\n            state.status = status;\n        },\n        updateGameMap(state, gameMap) {\n            state.gameMap = gameMap;\n        }\n    },\n    actions: {\n    },\n    modules: {\n    }\n}\n\n```\n\n2. 除了之前实现的游戏界面，还需要实现一个匹配界面。匹配界面相对简单，和游戏地图界面类似，两个头像，一个按钮。\n\n> 玩家1：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_528bdb66d9-6.2.2玩家1.png)\n\n> 玩家2：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_57338a40d9-6.2.2玩家2.png)\n\n> 匹配成功：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_4dac59a0d9-6.2.2匹配成功.png)\n\n3. 实现`PkIndexView`页面。之前该页面只有游戏地图，现在开始时需要先匹配，匹配成功后，需要将匹配界面关掉，切换为游戏地图页面。\n```vue\n<template>\n  <PlayGround v-if=\"$store.state.pk.status === 'playing'\" />\n  <MatchGround v-if=\"$store.state.pk.status === 'matching'\" />\n</template>\n\n<script>\nimport PlayGround from '../../components/PlayGround.vue'\nimport MatchGround from '../../components/MatchGround.vue'\nimport { onMounted, onUnmounted } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  components: {\n    PlayGround,\n    MatchGround,\n  },\n  setup() {\n    const store = useStore();\n    const socketUrl = `ws://127.0.0.1:8090/websocket/${store.state.user.token}/`;\n\n    let socket = null;\n    onMounted(() => {\n      store.commit(\"updateOpponent\", {\n        username: \"我的对手\",\n        photo: \"https://cdn.acwing.com/media/article/image/2022/08/09/1_1db2488f17-anonymous.png\",\n      })\n      socket = new WebSocket(socketUrl);\n\n      socket.onopen = () => {\n        console.log(\"connected!\");\n        store.commit(\"updateSocket\", socket);\n      }\n\n      socket.onmessage = msg => {\n        const data = JSON.parse(msg.data);\n        if (data.event === \"start-matching\") {  // 匹配成功\n          store.commit(\"updateOpponent\", {\n            username: data.opponent_username,\n            photo: data.opponent_photo,\n          });\n          setTimeout(() => {\n            store.commit(\"updateStatus\", \"playing\");\n          }, 2000);\n          store.commit(\"updateGameMap\", data.gameMap);\n        }\n      }\n\n      socket.onclose = () => {\n        console.log(\"disconnected!\");\n      }\n    });\n\n    onUnmounted(() => {\n      socket.close();\n      store.commit(\"updateStatus\", \"matching\");\n    })\n  }\n}\n</script>\n\n<style scoped>\n</style>\n```\n> 需要注意的是，与`http`协议类似，`socketUrl`的写法将`http`换为`ws`即可。\n\n匹配成功后，双方的地图均是从后端获取，因此实现了两名玩家的地图一致性。<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5ad67da0d9-6.2.3匹配成功后1.png)![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5d39caf8d9-6.2.3匹配成功后2.png)\n<a name=\"m4d1x\"></a>\n### 6.3 实现匹配系统的微服务（matchingsystem）\n新建一个`backendCloud` `maven`项目，引入`springcloud`依赖，在该项目下面新增两个模块（`backend, matchingsystem`），将先前的`backend`复制过来，引入并配置`restTemplate`。<br />**匹配系统思路：** 每次有匹配请求，`backend`发送添加用户请求到`matchingsystem`，`matchingsystem`将该用户添加到待匹配列表中。`matchingsystem`会在项目启动时开启`matchingPool`线程，并每秒尝试进行匹配列表中的玩家，同时每秒会增加玩家等待时间，时间越大，那么匹配该玩家时，可接受的天梯分差也将越大。\n\n- 在`webSocketServer`中实现`startMatching`函数调用匹配系统进行匹配：\n```java\nprivate void startMatching() {\n    System.out.println(\"start_matching!\");\n    MultiValueMap<String, String> playerData = new LinkedMultiValueMap<>();\n    playerData.add(\"userId\", this.user.getId().toString());\n    playerData.add(\"rating\", this.user.getRating().toString());\n\n    // ADD_PLAYER_URL = \"http://127.0.0.1:8089/player/add/\"\n    restTemplate.postForObject(ADD_PLAYER_URL, playerData, String.class);\n}\n```\n\n- 匹配系统`MatchingPool`类核心代码：\n```java\n@Override\npublic void run() {\n    while (true) {\n        try {\n            Thread.sleep(1000);\n            lock.lock();\n            try {\n                increaseWaitedTime();\n                matchPlayers();\n            } finally {\n                lock.unlock();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n- 在`matchingsystem`项目启动时开启`MatchingPool`线程：\n```java\n@SpringBootApplication\npublic class MatchingSystemApplication {\n    public static void main(String[] args) {\n        MatchingServiceImpl.matchingPool.start();\n        SpringApplication.run(MatchingSystemApplication.class, args);\n    }\n}\n```\n\n- 一旦匹配成功一对玩家，就会调用`MatchingPool`的`sendResult`方法通知`backend`以创建当前游戏：\n```java\n// 返回匹配成功结果\nprivate void sendResult(Player a, Player b) {\n    System.out.println(\"matched: \" + a + \" \" + b);\n    MultiValueMap<String, String> gameData = new LinkedMultiValueMap<>();\n    gameData.add(\"aId\", a.getUserId().toString());\n    gameData.add(\"bId\", b.getUserId().toString());\n    // START_GAME_URL = \"http://127.0.0.1:8090/pk/startGame/\"\n    restTemplate.postForObject(START_GAME_URL, gameData, String.class);\n}\n```\n> `startGame`函数会在下一部分介绍。\n\n<a name=\"L5bbR\"></a>\n### 6.4 实现后端游戏逻辑\n在`WebSocketServer`中调用实现函数`startGame`以便匹配系统完成匹配时进行调用以开始游戏：\n```java\npublic static void startGame(Integer aId, Integer bId) {\n    User a = userMapper.selectById(aId);\n    User b = userMapper.selectById(bId);\n\n    Game game = new Game(13, 14, 20, aId, bId);\n    game.createMap();\n    game.start();\n    if (null != users.get(aId)) {\n        users.get(aId).game = game;\n    }\n    if (null != users.get(bId)) {\n        users.get(bId).game = game;\n    }\n\n    JSONObject respGame = new JSONObject();\n    respGame.put(\"a_id\", game.getPlayerA().getId());\n    respGame.put(\"a_sx\", game.getPlayerA().getSx());\n    respGame.put(\"a_sy\", game.getPlayerA().getSy());\n    respGame.put(\"b_id\", game.getPlayerB().getId());\n    respGame.put(\"b_sx\", game.getPlayerB().getSx());\n    respGame.put(\"b_sy\", game.getPlayerB().getSy());\n    respGame.put(\"map\", game.getG());\n\n    JSONObject respA = new JSONObject();\n    respA.put(\"event\", \"start-matching\");\n    respA.put(\"opponent_username\", b.getUsername());\n    respA.put(\"opponent_photo\", b.getPhoto());\n    respA.put(\"game\", respGame);\n    // 给玩家A客户端返回结果\n    if (null != users.get(aId)) {\n        users.get(aId).sendMessage(respA.toJSONString());\n    }\n\n    JSONObject respB = new JSONObject();\n    respB.put(\"event\", \"start-matching\");\n    respB.put(\"opponent_username\", a.getUsername());\n    respB.put(\"opponent_photo\", a.getPhoto());\n    respB.put(\"game\", respGame);\n    // 给玩家B客户端返回结果\n    if (null != users.get(bId)) {\n        users.get(bId).sendMessage(respB.toJSONString());\n    }\n}\n```\n主要的游戏逻辑在`Game`类中，每次等待用户输入，然后校验操作时候合法，如果合法，则将两名玩家的操作广播给双方的客户端。如果有玩家操作不合法或者有玩家五秒内未进行输入，则游戏结束，向两名玩家广播游戏结果。<br />`Game`中的核心代码如下：\n```java\n@Override\npublic void run() {\n    for (int i = 0; i < 1000; i ++) {\n        if (nextStep()) {\n            judge();\n            if (\"playing\".equals(status)) {\n                sendMove();\n            } else {\n                sendResult();\n                break;\n            }\n        } else {\n            status = \"finished\";\n            lock.lock();\n            try {\n                if (null == nextStepA && null == nextStepB) {\n                    winner = \"all\";\n                } else if (null == nextStepB) {\n                    winner = \"A\";\n                } else {\n                    winner = \"B\";\n                }\n            } finally {\n                lock.unlock();\n            }\n            sendResult();\n            break;\n        }\n    }\n}\n```\n<a name=\"QHwmW\"></a>\n## 7. 微服务：Bot代码的执行（botrunningsystem）\n\n- 添加依赖：\n```xml\n<dependency>\n    <groupId>org.jooq</groupId>\n    <artifactId>joor-java-8</artifactId>\n    <version>0.9.14</version>\n</dependency>\n```\n\n- 配置`restTemplate`与`security`：\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"/bot/add/\").hasIpAddress(\"127.0.0.1\")\n                .antMatchers(HttpMethod.OPTIONS).permitAll()\n                .anyRequest().authenticated();\n    }\n}\n```\n每次后端（`backend`）会调用`bot/add/`接口往`bots`队列中添加`Bot`：\n```java\npublic void addBot(Integer userId, String botCode, String input) {\n    lock.lock();\n    try {\n        bots.add(new Bot(userId, botCode, input));\n        // 当 bot 添加结束，需要唤起其他线程进行消费\n        condition.signalAll();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n`botPool`的核心代码（这里相当于手动实现了一个消息队列）：\n```java\nprivate void consume(Bot bot) {\n    Consumer consumer = new Consumer();\n    consumer.startTimeout(2000, bot);\n}\n\n@Override\npublic void run() {\n    while (true) {\n        lock.lock();\n        if (bots.isEmpty()) {\n            try {\n                // 当队列中没有等待消费的Bot时，让线程等待，当有新添加的Bot时，会被condition.signalAll();唤醒\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break;\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            Bot bot = bots.poll();\n            lock.unlock();\n            // consume 可能会执行几秒钟，需要先解锁\n            consume(bot);\n        }\n    }\n}\n```\n而在`Consumer`中，需要控制每个`Bot`的执行时间：\n```java\npublic void startTimeout(long timeout, Bot bot) {\n    this.bot = bot;\n    this.start();\n    try {\n        this.join(timeout);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } finally {\n        // 最多等待 timeout 秒，然后中断\n        this.interrupt();\n    }\n}\n```\n`Consumer`中的核心代码：\n```java\n@Override\npublic void run() {\n    UUID uuid = UUID.randomUUID();\n    String uid = uuid.toString().substring(0, 8);\n    // 需要保障每次的类名不一样，否则只编译一次\n    Supplier<Integer> botInterface = Reflect.compile(\n            \"com.kob.botrunningsystem.utils.Bot\" + uid,\n            addUid(bot.getBotCode(), uid)\n    ).create().get();\n    // 将输入写入文件以便后续扩展（后期可以在docker中运行，就需要从文件中读取输入）\n    File file = new File(\"input.txt\");\n    try (PrintWriter fout = new PrintWriter(file)) {\n        fout.println(bot.getInput());\n        fout.flush();\n    } catch (FileNotFoundException e) {\n        throw new RuntimeException(e);\n    }\n    // 执行Bot代码，获取结果\n    Integer direction = botInterface.get();\n    // 将Bot执行结果返回\n    MultiValueMap<String, String> data = new LinkedMultiValueMap<>();\n    data.add(\"userId\", bot.getUserId().toString());\n    data.add(\"direction\", direction.toString());\n\n    restTemplate.postForObject(RECEIVE_BOT_MOVE_URL, data, String.class);\n}\n```\n<a name=\"CKczF\"></a>\n## 8. 创建对战列表与排行榜页面\n这两部分主要的任务就是写好分页查询和分页展示。<br />分页查询直接利用`MybatisPlus`自带的分页工具即可。<br />分页配置：\n```java\n@Configuration\npublic class MybatisConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n}\n```\n其中，在对战列表中的`查看录像`功能，实现原理为：将数据库中记录的地图信息、用户双方的操作信息取出，在游戏地图中重新模拟一遍即可。<br />**对局列表：**<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5ef9b2e6d9-8.对局列表.png)<br />**排行榜：**<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_61f70baed9-8.排行榜.png)\n<a name=\"Wj4NC\"></a>\n## 9. 实现QQ三方登录\n> **基本思路：** 通过访问后端的`@GetMapping(\"/applyCode/\")`接口获取`apply_code`，同时后端生成了`state`存入`redis`中。然后前端再调用后端的`@GetMapping(\"/receiveCode/\")`接口。在该接口中，会拿着`state`与`redis`中的进行校验，然后获取`access_token`，拿到`access_token`之后获取用户的`openid`，然后判断该`openid`是否已经存在，如果存在直接生成`jwt`并返回前端，如果不存在，则说明是第一次申请`QQ`登录，需要获取`user_info`，再存入数据库并生成`jwt`返回。\n\n**官方授权流程图（**[**官方教程**](https://wiki.connect.qq.com/%e4%bd%bf%e7%94%a8authorization_code%e8%8e%b7%e5%8f%96access_token)**）：**<br />![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_6f230017d9-9.官方授权流程图.png)\n<a name=\"lBIVC\"></a>\n### 9.1 前往腾讯开放平台完成资料审核\n\n- 先前往腾讯开放平台进行开发者人脸识别校验（[腾讯开放平台](https://app.open.qq.com/p/developer/team_manage/info)）\n> 需要先QQ登录，然后点击右上角的账户管理，根据提示微信扫码完成人脸识别校验。\n\n- QQ互联进行开发者资料审核（[开发者资料审核](https://connect.qq.com/devuser.html#/create/1/)）\n> 注：手持照片得用后置摄像头拍摄，前置摄像头有镜像功能，手指不能遮挡证件信息，一定要拍清楚，否则 会被驳回！\n\n<a name=\"dgV8H\"></a>\n### 9.2 在腾讯开放平台创建应用\n\n- 创建应用\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_65986370d9-9.2创建应用.png)\n\n- 填写应用资料\n> 网站回调地址填写前端页面地址，再由前端页面请求后端进行账户注册或`jwt`生成。在这里需要处理一下前端页面的地址，因为这一栏腾讯要求不能以`'/'`结尾。所以前端页面也不能以`'/'`结尾。\n\n```javascript\n{\n  path: \"/user/account/qq/web/receiveCode\",\n  name: \"user_account_qq_receive_code\",\n  component: ()=>import('@/views/user/account/UserAccountQQReceiveCodeView'),\n  meta:{\n    requestAuth : false\n  }\n},\n```\n所以我的地址（后端的`redirect_uri`与此保持一致）：\n```xml\nhttps://smallboat.games/user/account/qq/web/receiveCode\n```\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_6a4f7e5bd9-9.2填写应用资料.png)\n> - 提供方和网站地址备案号可在：`[https://icp.chinaz.com/](https://icp.chinaz.com/)`查询。\n> - 提交审核后一定要先将`QQ`登录按钮部署到正式环境，否则会以`未摆放QQ登录按钮`审批不通过。\n\n- 审核通过\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_67678959d9-9.2审核通过.png)\n<a name=\"KFUq7\"></a>\n### 9.3 代码实现\n<a name=\"FXRnt\"></a>\n#### 9.3.1 前端\n\n- 在登录页合适位置添加`QQ`登录按钮：\n```html\n<div @click=\"qq_login\" style=\"cursor: pointer; text-align: center; margin-top: 10px;\">\n  <img height=\"30\" \n    src=\"https://wiki.connect.qq.com/wp-content/uploads/2013/10/03_qq_symbol-1-250x300.png\"\n    alt=\"QQ官方图标\"/>\n  <br>\n  <div style=\"color: #09e309\">\n    QQ一键登录\n  </div>\n</div>\n```\n```javascript\nconst qq_login = () => {\n  $.ajax({\n    url: \"https://smallboat.games/api/user/account/qq/web/applyCode/\",\n    type: \"GET\",\n    success: resp => {\n      if (resp.result === \"success\") {\n        window.location.replace(resp.apply_code_url);\n      }\n    }\n  })\n}\n```\n\n- 添加路由（~~其实上面已经写过~~）\n```javascript\n{\n  path: \"/user/account/qq/web/receiveCode\",\n  name: \"user_account_qq_receive_code\",\n  component: ()=>import('@/views/user/account/UserAccountQQReceiveCodeView'),\n  meta:{\n    requestAuth : false\n  }\n},\n```\n\n- 处理`QQ`登录的页面\n```vue\n<template>\n  <div></div>\n</template>\n\n<script>\nimport router from \"@/router/index\";\nimport {useStore} from \"vuex\";\nimport {useRoute} from \"vue-router\";\nimport $ from 'jquery'\nexport default {\n  name: \"UserAccountQQReceiveCodeView\",\n  setup() {\n    const myRoute = useRoute();\n    const store = useStore();\n    $.ajax({\n      url: \"https://smallboat.games/api/user/account/qq/web/receiveCode/\",\n      type: \"GET\",\n      data: {\n        code: myRoute.query.code,\n        state: myRoute.query.state,\n      },\n      success: resp => {\n        if (resp.result === \"success\") {\n          localStorage.setItem(\"jwt\", resp.jwt);\n          store.commit(\"updateToken\", resp.jwt);\n          router.push({name: \"home\"});\n          store.commit(\"updatePullingInfo\", false);\n        } else {\n          router.push({name: \"user_account_login\"});\n        }\n      }\n    })\n  }\n}\n</script>\n\n<style scoped>\n\n</style>\n```\n<a name=\"OxeZj\"></a>\n#### 9.3.2 后端\n**后端主要需要实现两个接口：**\n> 记得在`SecurityConfig`中放行这两个接口，因为是在用户未获取`jwt`时进行访问。\n\n- `@GetMapping(\"/applyCode/\")`\n```java\n@Override\npublic JSONObject applyCode() {\n    JSONObject resp = new JSONObject();\n    String encodeUrl = \"\";\n    try {\n        encodeUrl = URLEncoder.encode(REDIRECT_URI, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        resp.put(\"result\", \"failed\");\n        return resp;\n    }\n\n    // 随机字符串，防止 csrf 攻击\n    StringBuilder state = new StringBuilder();\n    for (int i = 0; i < 10; i ++) {\n        state.append((char)(random.nextInt(10) + '0'));\n    }\n    // 存到redis里，有效期设置为10分钟\n    resp.put(\"result\", \"success\");\n    redisTemplate.opsForValue().set(state.toString(), \"true\");\n    redisTemplate.expire(state.toString(), Duration.ofMinutes(10));\n\n    String applyCodeUrl = \"https://graph.qq.com/oauth2.0/authorize\"\n            + \"?response_type=\"+\"code\"\n            + \"&client_id=\" + APP_ID\n            + \"&redirect_uri=\" + encodeUrl\n            + \"&state=\" + state;\n    resp.put(\"apply_code_url\", applyCodeUrl);\n\n    return resp;\n}\n```\n\n- `@GetMapping(\"/receiveCode/\")`\n```java\n@Override\npublic JSONObject receiveCode(String code, String state) {\n    JSONObject resp = new JSONObject();\n    resp.put(\"result\", \"failed\");\n    if (null == code || null == state) return resp;\n    if (Boolean.FALSE.equals(redisTemplate.hasKey(state))) return resp;\n    redisTemplate.delete(state);\n    // 获取access_token\n    List<NameValuePair> nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"grant_type\", \"authorization_code\"));\n    nameValuePairs.add(new BasicNameValuePair(\"client_id\", APP_ID));\n    nameValuePairs.add(new BasicNameValuePair(\"client_secret\", APP_SECRET));\n    nameValuePairs.add(new BasicNameValuePair(\"code\", code));\n    nameValuePairs.add(new BasicNameValuePair(\"redirect_uri\", REDIRECT_URI));\n    nameValuePairs.add(new BasicNameValuePair(\"fmt\", \"json\"));\n\n    String getString = HttpClientUtil.get(APPLY_ACCESS_TOKEN_URL, nameValuePairs);\n    if (null == getString) return resp;\n    JSONObject getResp = JSONObject.parseObject(getString);\n    String accessToken = getResp.getString(\"access_token\");\n\n    // 获取openid\n    nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"access_token\", accessToken));\n    nameValuePairs.add(new BasicNameValuePair(\"fmt\", \"json\"));\n\n    getString = HttpClientUtil.get(APPLY_USER_OPENID_URL, nameValuePairs);\n    if(null == getString) return resp;\n    getResp = JSONObject.parseObject(getString);\n    String openid = getResp.getString(\"openid\");\n\n    if (accessToken == null || openid == null) return resp;\n\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.eq(\"openid_qq\", openid);\n    List<User> users = userMapper.selectList(queryWrapper);\n\n    // 用户已经授权，自动登录\n    if (null != users && !users.isEmpty()) {\n        User user = users.get(0);\n        // 生成jwt\n        String jwt = JwtUtil.createJWT(user.getId().toString());\n\n        resp.put(\"result\", \"success\");\n        resp.put(\"jwt\", jwt);\n        return resp;\n    }\n\n    // 新用户授权，获取用户信息，并创建新用户\n    nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"access_token\", accessToken));\n    nameValuePairs.add(new BasicNameValuePair(\"openid\", openid));\n    nameValuePairs.add(new BasicNameValuePair(\"oauth_consumer_key\", APP_ID));\n    getString = HttpClientUtil.get(APPLY_USER_INFO_URL, nameValuePairs);\n    if (null == getString) return resp;\n\n    getResp = JSONObject.parseObject(getString);\n    String username = getResp.getString(\"nickname\");\n    // 50*50的头像\n    String photo = getResp.getString(\"figureurl_1\");\n\n    if (null == username || null == photo) return resp;\n\n    // 每次循环，用户名重复的概率为上一次的1/10\n    for (int i = 0; i < 100; i ++) {\n        QueryWrapper<User> usernameQueryWrapper = new QueryWrapper<>();\n        usernameQueryWrapper.eq(\"username\", username);\n        if (userMapper.selectCount(usernameQueryWrapper) == 0) break;\n        username += (char)(random.nextInt(10) + '0');\n        if (i == 99) return resp;\n    }\n    User user = new User(null, username, null, photo, 1500, null, openid, null);\n    userMapper.insert(user);\n    // 生成 jwt\n    String jwt = JwtUtil.createJWT(user.getId().toString());\n    resp.put(\"result\", \"success\");\n    resp.put(\"jwt\", jwt);\n    return resp;\n}\n```\n<a name=\"jQ4rd\"></a>\n\n## 10. 项目上线\n上线流程参考：<br />[项目上线基本流程-CSDN博客](http://smallboatc.github.io/2024/02/01/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/)<br />上线成果：<br />[King of Bots](https://smallboat.games/)<br />项目`github`地址：<br />[https://github.com/smallboatc/kob/](https://github.com/smallboatc/kob/)\n","categories":["SpringBoot"]},{"title":"项目上线基本流程","url":"/2024/02/01/项目上线基本流程/","content":"\n<a name=\"Q907D\"></a>\n## 1. 租ECS云服务器\n服务器推荐顺序：\n\n- 阿里云\n- 腾讯云\n- 华为云\n\n一般选择`1核2G`即可，选择按使用量计费。<br />通过命令`ssh root@xx.xxx.xxx.xxx #（公网ip）`，然后输入购买服务器时设置的密码即可连接到服务器。之前如果没生成过公钥的，需要先在本地使用命令`ssh-keygen`一路回车生成公钥再登录。<br />如果是重置过服务器，那么之前就会有记录，重新登录时会报错，此时需要在文件中将该服务器的配置删掉再登录。\n```shell\nvim .ssh/known_hosts # 进入后删除该服务器的配置\n```\n<a name=\"pUBb0\"></a>\n## 2. 配置服务器\n`CentOs`创建用户（默认的`root`权限过高，需要使用拥有`sudo`权限的用户进行操作）\n```shell\nuseradd acs # acs 为自己想取的用户名\npasswd acs\n# 设置密码\nchmod -v u+w /etc/sudoers # 给 sudoers 文件可写权限\nvim /etc/sudoers # 修改该文件，给用户 acs 添加权限\n# 进入后先输入 /Allow root 找到 root    ALL=(ALL)    ALL 所在位置\n# i 进入编辑模式，在 root    ALL=(ALL)    ALL 下一行写入 acs    ALL=(ALL)    ALL\n# 按ESC 然后输入 :wq 保存并退出 \nchmod -v u-w /etc/sudoers # 收回 sudoers 文件可写权限\nsu acs # 使用新账户登录系统\n```\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_aaaccb4ad8-2.配置服务器.png)<br />然后`exit`退出，在本地配置免密登录：\n```shell\nvim .ssh/config # 没有该文件会自动创建\n```\n在文件中添加如下语句\n```shell\nHost springboot_server # 后面这个是给服务器取的名字\n  \tHostName xx.xxx.xxx.xxx # 后面这个是公网ip\n    User acs # 后面这个是刚刚添加的用户名\n```\n保存并退出<br />在终端中输入`ssh-copy-id springboot_server`然后输入密码完成免密登录配置，之后就可以使用使用`ssh springboot_server`直接登录，而不需要输入密码。<br />然后我们先不登录，先将一些祖传配置文件传过去。<br />使用`scp xxx springboot_server:`将需要的文件传到服务器（没有就不传），注意一定要有冒号`:`\n```shell\nscp .bashrc .vimrc .tmux.conf server_name:  # server_name需要换成自己配置的别名\n```\n然后登录服务器<br />先装一个`tmux`（所有工作尽量在`tmux`中完成，避免发生意外丢失工作进度）\n```shell\nsudo yum update # 先更新数据源，网络不好可能会报错，尽量在网络环境良好时操作\nsudo yum install tmux\n```\n<a name=\"jzQu6\"></a>\n## 3. 安装docker\n然后在`tmux`中安装`docker`（[docker安装步骤（官网）](https://docs.docker.com/engine/install/centos/)）<br />安装完成后输入`docker`会有一些提示，说明安装成功！<br />然后启动`docker`：`sudo systemctl start docker`<br />安装成功之后，将用户在`docker`中赋予`sudo`权限：`sudo usermod -aG docker $USER`，以便该用户可以使用 `docker` 而无需使用 `sudo`。之后需要退出重新登录才会生效，否则执行`docker`相关命令会提示没有权限。\n\n之后就可以使用`scp`命令把自己的镜像传到服务器了\n\n然后使用命令`docker load -i django_lesson_1_0.tar`将镜像文件解压到`docker`中。<br />运行镜像：\n```shell\n# 中间是需要使用的端口号映射配置，例如 -p 20000:22 会将在外界访问服务器20000端口时自动映射到容器的22端口\ndocker run -p 20000:22 -p 443:443 -p 80:80 -p 3000:3000 -p 3001:3001 -p 3002:3002 -itd --name kob_server django_lesson:1.0\n```\n然后就可以进到`docker`中了：`docker attach kob_server`（镜像是`ubuntu`）\n\n之后给创建用户并赋予`sudo`权限，再按`ctrl + p, strl + q`挂载容器（退出但不销毁）。\n\n之后同样的操作将祖传的配置文件传到容器中\n<a name=\"tAnh0\"></a>\n## 4. 容器中安装各种服务\n然后在容器中安装`mysql`\n```shell\nsudo apt-get install mysql-server\nsudo apt-get update\nsudo apt-get install mysql-server\t\n```\n\n然后启动`mysql`:`sudo service mysql start`<br />然后进入`mysql mysql -uroot -pxxxxx`\n\n在`mysql`中执行`sql`语句：`ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'yourpasswd';`以修改密码。\n\n创建数据库并创建表：\n```sql\ncreate database kob;\nuse kob;\nsource /home/acs/create_table.sql; # 提前准备好的创建数据库表的sql文件\nexit;\n```\n安装java\n```shell\nsudo apt-get install openjdk-8-jdk\n```\n<a name=\"UbU8u\"></a>\n## 5. 打包项目到容器中\n然后就是将项目打包传到容器中运行了\n\n后端项目先`clean`再`package`即可。<br />前端项目修改请求地址运行`npm run build`\n\n将后端项目的jar包分别发送到容器中运行\n```shell\njava -jar xxx.jar # 运行\n```\n需要停止的话\n```shell\nps -ef | grep xxx.jar # 查询程序的进程号\nkill -s 9 xxxx # 后面是查询到的进程号\n```\n<a name=\"UwYLg\"></a>\n## 6. 配置许可证以及nginx等\n配置`key, pem, nginx.conf`<br />在这之前先将配置文件复制到root目录下（为了使配置nginx.conf时文件格式好看点）<br />`sudo cp .bashrc .vimrc .tmux.conf /root`<br />具体的域名、许可证、证书申请及`nginx`配置可参考其他文章。<br />最后启动`nginx`\n```shell\nsudo /etc/init.d/nginx start # 如果运行结果是fail的话需要查看错误日志对应修改\n```\n\n结束。<br />**题外话：** 需要在本地连接容器中的数据库，可以参考[Navicat 连接远程服务器里 docker 中的 mysql](http://t.csdnimg.cn/mp9E2)\n\n","categories":["Linux"]},{"title":"ubuntu解决终端中文乱码问题","url":"/2024/01/28/ubuntu解决终端中文乱码问题/","content":"\n1. 查看当前系统语言\n```shell\n$ echo $LANG\n```\n\n2. 查看系统安装的语言包\n```shell\n$ locale -a \nC\nC.UTF-8\nPOSIX\n\n$ sudo dpkg -l | grep language-pack-zh-hans\n```\n\n3. 如果没有中文语言包，需要安装\n```shell\n$ sudo apt-get install language-pack-zh-hans\n```\n\n4. 安装成功后，确认是否安装成功\n```shell\n$ locale -a \nC\nC.UTF-8\nPOSIX\nzh_CN.utf8\nzh_SG.utf8\n\n$ sudo dpkg -l | grep language-pack-zh-hans\nii  language-pack-zh-hans           1:20.04+20210802                    all          translation updates for language Simplified Chinese\nii  language-pack-zh-hans-base      1:20.04+20210802                    all          translations for language Simplified Chinese\n```\n\n5. 设置系统语言环境\n```shell\n# export 的方式只对当前终端生效\n$ export LANG=\"zh_CN.UTF-8\"\n\n#  /etc/profile 文件中添加export LANG=\"zh_CN.UTF-8\" 对所有用户生效\n$ sudo vim /etc/profile\n```\n","categories":["Linux"]},{"title":"动态规划LIS模型","url":"/2024/01/19/动态规划LIS模型/","content":"\n<a name=\"UlPOe\"></a>\n## 1. LIS 模型\n> LIS问题：给定一个长度为`N`的数列 `a`，求数值严格单调递增的子序列的长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i]$表示由数列$a$的前$i$个数字组成（不一定包含所有数字）且以$a[i]$结尾的最长上升子序列的长度。\n- 状态计算：遍历小于$i$的每一个$j$，若有$a[j] < a[i]$，则$f[i] = max(f[i], f[j] + 1)$，否则$f[i] = 1$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] a = new int[N], f = new int[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            f[i] = 1;\n            for (int j = 1; j <= n; j ++) {\n                if (a[j] < a[i]) f[i] = Math.max(f[i], f[j] + 1);\n            }\n        }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[i]);\n        System.out.println(res);\n    }\n}\n```\n**优化：**<br />在状态计算那一步，我们每次去遍历所有小于$i$的$j$，这样显然时间复杂度是$O(n^2)$。对于数据量大的题目，是会$TLE$的。我们可以使用贪心的方式来优化，具体如下：<br />我们用一个数组$q$来维护当前遍历到的元素之前的序列，每次遍历到一个元素$a[i]$，就在$q$中寻找小于$a[i]$的最大的元素$q[r]$，并将$q[r+1]$赋值为$a[i]$，同时更新一下最长上升子序列的长度。<br />有三个注意点：\n\n- 将$q[r+1]$赋值为$a[i]$：有可能$a[i]$就是维护的序列中最大的元素，因此会是添加到序列后面。也有可能是将$q[r+1]$修改为$a[i]$。\n- 如果是将$q[r+1]$修改为$a[i]$，这个操作是不影响后面的遍历的，因为如果后面某个元素$a[j]$能放到原来的$q[r+1]$后面，也必然能放到新的$q[r+1](a[i])$后面（因为当前的$q[r+1]$必然是大于$a[i]$的）。\n- 在该序列中寻找小于$a[i]$的最大的元素$q[r]$：这个操作我们可以通过二分来实现。\n\n**优化代码实现：**\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 100010;\n    static int[] a = new int[N], q = new int[N];\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s = br.readLine().split(\" \");\n        for (int i = 0; i < n; i ++) a[i] = Integer.parseInt(s[i]);\n        \n        int len = 0;\n        q[0] = -(int)2e9;\n        for (int i = 0; i < n; i ++) {\n            int l = 0, r = len;\n            while(l < r) {\n                int mid = l + r + 1 >> 1;\n                if (q[mid] < a[i]) l = mid;\n                else r = mid - 1;\n            }\n            // 更新最长上升子序列长度（不一定能更新）\n            len = Math.max(len, r + 1);\n            // 将新点插入\n            q[r + 1] = a[i];\n        }\n        System.out.print(len);\n    }\n}\n```\n**LIS模型相关题目：**\n\n- [AcWing 1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)：题目需要求从一个点开始，每一次的下一个位置不许严格低于前一个位置，问最远能走多远。逆向思维，求一遍LIS问题即可。\n- [AcWing 482. 合唱队形](https://www.acwing.com/problem/content/484/)：题目要求至少要多少名同学出列才能形成合唱队形，我们可以求合唱队形最长能多长（即正反分别求一次LIS问题），然后用总人数减去最长合唱队行人数。\n- [AcWing 1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)：LIS问题求的是数量，而这道题求的是每个元素的和，所以求LIS问题时将`+1`改为`+a[i]`即可。\n- [AcWing 187. 导弹防御系统](https://www.acwing.com/problem/content/189/)：这道题虽然也是LIS模型，但是已经跟DP无关了，解题方法为DFS+贪心版LIS。\n<a name=\"nYruO\"></a>\n## 2. LCS模型\n> LCS问题：给定两个长度分别为n 和 m 的字符串 a 和 b，求既是 a 的子序列又是 b 的子序列的字符串长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i][j]$表示由数列$a$的前$i$个数字与数列$b$的前$j$个数字组成的公共子序列的长度最大值。\n- 状态计算：\n   - 当包含$a[i]$且不包含$b[j]$时，$f[i][j] = max(f[i][j], f[i][j - 1])$；\n   - 当包含$b[j]$且不包含$a[i]$时，$f[i][j] = max(f[i][j], f[i - 1][j])$；\n   - 当既不包含$a[i]$也不包含$b[j]$时，$f[i][j] = max(f[i][j], f[i - 1][j - 1])$，但是这种情况可以被以上任意一种包含；\n   - 当包含$a[i]$且包含$b[j]$时（要求$a[i] = b[j]$），$f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        char[] a = (\" \" + sc.next()).toCharArray(), b = (\" \" + sc.next()).toCharArray();\n        for (int i = 1; i <= n; i ++)\n            for (int j = 1; j <= m; j ++) {\n                f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]);\n                if (a[i] == b[j]) f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n<a name=\"FNFgY\"></a>\n## 3. LCIS模型\n> LCIS问题：给定两个长度分别为n 和 m 的字符串 a 和 b，求既是 a 的子序列又是 b 的子序列且数值严格单调递增的字符串长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i][j]$表示由数列$a$的前$i$个数字与数列$b$的前$j$个数字组成且以$b[j]$结尾的最长上升公共子序列的长度的最大值。\n- 状态计算：\n   - 当不包含$a[i]$时，$f[i][j] = f[i - 1][j]$；\n   - 当包含$a[i]$时（要求$a[i] = b[j]$），此时$f[i][j]$起码为1，$f[i][j] = max(f[i][j], 1)$，然后遍历$b[j]$之前的元素，若$b[k]<b[j]$，则$f[i][j] = max(f[i][j], f[i][k] + 1)$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 3010;\n    static int[] a = new int[N], b = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) b[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= n; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (a[i] == b[j]) {\n                    f[i][j] = Math.max(f[i][j], 1);\n                    for (int k = 1; k < j; k ++) \n                        if (b[k] < b[j]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);\n                }\n            }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[n][i]);\n        System.out.println(res);\n    }\n}\n```\n**优化：**<br />上述的方法时间复杂度达到了$O(n^3)$，数据量稍大一些就$TLE$。我们可以对代码做等价变形优化成$O(n^2)$。<br />可以发现，当$a[i] = b[j]$时，`if (b[k] < b[j]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);`这一句等价于`if (b[k] < a[i]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);`，我们就能发现，这一部分求解其实是与$b[j]$无关的。我们可以直接用一个变量代替这一部分，每次循环$j$时维护起来即可。<br />**优化代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 3010;\n    static int[] a = new int[N], b = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) b[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            int maxv = 1;\n            for (int j = 1; j <= n; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (a[i] == b[j]) f[i][j] = Math.max(f[i][j], maxv);\n                // 这里的b[j]就等价于优化前的b[k]，a[i]就等价于优化前的b[j]\n                if (a[i] > b[j]) maxv = Math.max(maxv, f[i][j] + 1);\n            }\n        }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[n][i]);\n        System.out.println(res);\n    }\n}\n```\n\n","categories":["算法"]},{"title":"二分算法详解","url":"/2024/01/16/二分算法详解/","content":"\n<a name=\"qR9aQ\"></a>\n## 1. 二分定义\n**二分查找（百度百科）**：二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求[线性表](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink)必须采用[顺序存储结构](https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1347176?fromModule=lemma_inlink)，而且表中元素按关键字有序排列。<br />上述的定义只是狭义上的二分查找定义，在上述定义中提到了一个概念：**有序**，但实际上，我们只需要让线性表满足**二段性**即可使用二分。\n<a name=\"cfGPL\"></a>\n## 2. 二段性\n那么，什么是二段性呢？<br />所谓二段性，就是在线性表中有一个元素，使得该元素的左侧满足性质1，右侧满足性质2。<br />举个🌰，有一个数组`nums = [4, 5, 6, 7, 0, 1, 2]`，该数数组原本是严格递增的，但是被按照某个点旋转了一次。现在我们需要找出该数组的原始起点（当然，直接遍历一遍是一种有效但并不优美的做法）。在这例子中，起点当然是`0`了，并且我们通过观察可以发现，`0`**的左侧满足所有的元素都大于等于**`nums[0] = 4`（性质1），而`0`**及其右侧元素都小于**`nums[0] = 4`（性质2）。那么此时，元素`0`就是让这个线性表具有二段性的元素**之一**（为什么说之一呢，因为例如`7`也能使该线性表具有二段性）。<br />为什么具有二段性就能使用二分呢？<br />还是拿上述例子进行说明，我们既然清楚了我们需要查找的元素具有二段性，那么，我们是否可以利用这个性质缩小查询范围以不断逼近并最终查询到这个元素呢？\n<a name=\"f3r3P\"></a>\n## 3. 利用二段性实现二分\n答案是肯定的。每一次，我们取整个线性表的中间元素（下标记为`mid`），判断`nums[mid]`满足**性质1**还是**性质2**。\n\n- 如果满足性质1，则说明`nums[mid]`在目标元素的左侧，此时我们将区间左端点（`l`）移动到`mid + 1`（因为此时我们可以明确的知道`nums[mid]`并不是我们需要的元素）。\n- 如果满足性质2，则说明`nums[mid]`就是目标元素或是在目标元素右侧，此时我们将区间右端点移动到`mid`。\n\n于是，二分查找的代码就有了：\n```java\nint l = 0, r = n - 1;\nint x = nums[0];\nwhile (l < r) {\n    int mid = l + r >> 1;\n    if (nums[mid] >= x) l = mid + 1;\n    else r = mid;\n}\n```\n> `l + r >> 1`等价于`(l + r) / 2`\n\n到此处，我们几乎能用一句话总结二分，即**利用二段性不断逼近直到查找到目标元素**。\n<a name=\"GDwgm\"></a>\n## 4. 二分常见模板\n这类题目一般能够使用二分（因为他们通常情况下具有二段性）：\n\n- 查找最小的最大值\n- 查找最大的最小值\n\n**模板1：**\n```java\nint l = 0, r = n - 1;\nwhile (l < r) {\n    int mid = l + r >> 1;\n    // check() 判断 mid 是否满足性质1或性质2\n    if (check(mid)) r = mid;\n    else l = mid + 1;\n}\n```\n**模板2：**\n```java\nint l = 0, r = n - 1;\nwhile (l < r) {\n    int mid = l + r + 1 >> 1;\n    if (check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n**为什么会有两种模板呢？**<br />主要是出于两个目的：\n\n1. 时时刻刻保证目标元素在所维护区间的内部\n2. 处理边界问题（直接背过就行，当出现`r = mid - 1`时，`mid`就定义为`int mid = l + r + 1 >> 1;`，前人总结出的经验）。\n\n在次给出几道`leetcode`例题练练手（通过看优质题解是很好的进步方式）：\n\n- 例题1：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n- 例题2：[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)\n- 例题3：[搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)\n<a name=\"ThfuS\"></a>\n## 5. 扩展：二分答案\n对于二分的题目，很多时候还会以**二分答案**的形式出题。<br />什么是二分答案？<br />**我们以一道例题为例：**[**跳石头**](https://www.luogu.com.cn/problem/P2678)\n<a name=\"TROgb\"></a>\n### 5.1 题目描述\n一年一度的“跳石头”比赛又要开始了！<br />这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。<br />为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。\n<a name=\"vk8Ln\"></a>\n### 输入格式\n第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。<br />接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。\n<a name=\"Fvhnt\"></a>\n### 输出格式\n一个整数，即最短跳跃距离的最大值。\n<a name=\"q3dYD\"></a>\n### 样例输入 #1\n```\n25 5 2 \n2\n11\n14\n17 \n21\n```\n<a name=\"X2jeI\"></a>\n### 样例输出 #1\n```\n4\n```\n<a name=\"lnEVN\"></a>\n### 输入输出样例 1 说明\n将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。\n<a name=\"dfZxe\"></a>\n### 数据规模与约定\n对于 $20\\%$的数据，$0 \\le M \\le N \\le 10$。<br />对于 $50\\%$ 的数据，$0 \\le M \\le N \\le 100$。<br />对于 $100\\%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \n \\le 10^9$。\n<a name=\"OBkEH\"></a>\n### 5.2 题解\n本题中，我们的目的是要寻找`最短跳跃距离的最大值`，这个答案肯定在$1\\thicksim L$之间，最暴力的方法就是从$L$枚举到$1$，找到的第一个合法答案就是最优解。那么什么样的答案能被称为合法呢？题目要求最多只能挪走$M$块石头，所以如果在挪走$M$块石头之前能够满足每两块石头间的距离大于等于我们枚举的答案，那么这个答案就是合法的。而挪走石头的顺序就是要先解决距离最小的石头，因此从小到大开始挪石头即可，每次挪完石头记录挪走的石头数量，然后更新一下下一块石头与挪走的石头的上一块石头之间的距离。若挪完石头发现挪走石头的数量大于$M$，那么我们枚举的这个答案就不是满足题目要求的`最短跳跃距离的最大值`，就继续往前找。\n\n我们可以发现，在上面的分析过程中，我们是先从答案入手，再去判断答案是否满足题目的限制条件。而这一暴力过程其实是可以使用二分优化的。这种从答案出发，使用二分优化的方式就被称为**二分答案**。\n\n> 重点分析`check`函数，二分的精髓。\n\n\n```java\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n\tstatic final int N = 50010;\n\tstatic int L, n, m;\n    // dist记录当前点与前一个点的距离\n\tstatic int[] a = new int[N], dist = new int[N];\n\tpublic static boolean check(int mid) {\n\t\tint cnt = 0;\n\t\tint[] backup = Arrays.copyOf(dist, dist.length);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tif (dist[i] < mid) {\n\t\t\t\tcnt ++;\n\t\t\t\tdist[i + 1] += dist[i];\n\t\t\t}\n        // 每一轮挪完石头需要将dist数组还原，因为每轮挪石头都是独立的\n\t\tdist = Arrays.copyOf(backup, backup.length);\n\t\treturn cnt <= m;\n\t}\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s = br.readLine().split(\" \");\n\t\tL = Integer.parseInt(s[0]);\n\t\tn = Integer.parseInt(s[1]);\n\t\tm = Integer.parseInt(s[2]);\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\ta[i] = Integer.parseInt(br.readLine().split(\" \")[0]);\n\t\t\tdist[i] = a[i] - a[i - 1];\n\t\t}\n\t\tdist[n + 1] = L - a[n];\n\t\tn ++;\n\t\tint l = 1, r = L;\n\t\twhile (l < r) {\n\t\t\tint mid = l + r + 1 >> 1;\n\t\t\tif (check(mid)) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tSystem.out.print(l);\n\t}\n}\n```\n","categories":["算法"]},{"title":"使用@JsonFormat注解前后端时间相差8小时的问题","url":"/2023/12/17/使用@JsonFormat注解前后端时间相差8小时的问题/","content":"\n<a name=\"BW8kv\"></a>\n在写项目时发现在实体类中使用了`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`注解，然后该时间存入数据库也正常，从数据库中取出也是正常，但是传给前端就出现问题，两边的时间相差了 `8`小时。\n\n- 配置文件：\n```yaml\nurl: jdbc:mysql://localhost:3306/xxx?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8\n```\n> 注意：`gmtCreate`只是数据库中习惯命名，并非使用的是`GMT`时间。\n\n<a name=\"lsS8y\"></a>\n## 1. 原始写法\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\nprivate Date gmtModified;\n```\n\n- 程序获取到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_adf2f129d9-1.1.png)\n- 数据库中存入的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_afd1785ed9-1.2.png)\n- 前端接收到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b2bf2366d9-1.3.png)\n\n**问题剖析：**\n\n1. **程序-数据库：** 程序中获取的是当前的系统时间，取决于服务器的时间，所以获取的时间是正确的，然后传给数据库的时候，由于两边的时区没有差别，所以在序列化的时候，时间转化是没有一点问题的。\n2. **数据库-程序：** 从数据库取出时间的时候进行反序列化，此时两边的时区一致，时间转换没有问题，所以程序拿到的时间也是正确的。\n3. **程序-前端：** 当程序需要将对象传输给前端时，并不明确前端的时区，所以将默认对方为`GMT`时间，所以在序列化时，由于时区的变化，得到的`Json`字符串自然也发生了变化（`-8`小时）。\n<a name=\"VtAtN\"></a>\n## 2. 修正写法\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\nprivate Date gmtCreate;\n```\n\n- 程序获取到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b3fb63dfd9-2.1.png)\n- 数据库中存入的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b7045e3bd9-2.2.png)\n- 前端接收到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_baa13aecd9-2.3.png)\n\n通过在`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`注解中加入`timezone = \"GMT+8\"`，就明确了在转为`GMT`时间时将时间`+8`再序列化。<br />当然，也可以直接指定时区：\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"Asia/Shanghai\")\nprivate Date gmtCreate;\n```\n","categories":["后端开发排坑"]},{"title":"SQL开发手册（自用版）","url":"/2023/09/14/SQL开发手册（自用版）/","content":"\n<a name=\"kaTKj\"></a>\n# 一、SELECT查询技巧\n1、对查询进行优化，应尽量避免全表扫描(非必要不使用`SELECT * FROM table1`)，首先应考虑在 WHERE 及 ORDER BY 涉及的列上建立索引(建立索引需满足建立索引规约)。<br />2、应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，创建表时 NULL 是默认值，但大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。<br />3、应尽量避免在 WHERE 子句中使用 != 或 <> 操作符。MySQL 只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的 LIKE(索引文件具有B-Tree的最左前缀匹配特性)。<br />4、应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION 合并查询。\n\n- 反例：\n```sql\nSELECT id FROM t WHERE num = 10 OR num = 20;\n```\n\n- 正例：\n```sql\nSELECT id FROM t WHERE num = 10\nUNION ALL\nSELECT id FROM t WHERE num = 20;\n```\n5、IN 和 NOT IN 也要慎用，否则会导致全表扫描。对于连续的数值，能用 BETWEEN 就不要用 IN。\n\n- 反例：\n```sql\nSELECT id FROM t WHERE num IN (1, 2, 3);\n```\n\n- 正例：\n```sql\nSELECT id FROM t WHERE num BETWEEN 1 AND 3;\n```\n6、如果在 WHERE 子句中使用参数(指数据库暂时无法确定其值的局部变量，并不是mybatis中的参数)，也会导致全表扫描而不是走索引。<br />7、应尽量避免在 WHERE 子句中对字段进行表达式操作，应尽量避免在 WHERE 子句中对字段进行函数操作。\n\n- 说明：WHERE 子句中对列的任何操作结果都是在 SQL 运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。如果这些结果在查询编译时就能得到，那么就可以被 SQL 优化器优化，从而可能使用索引，进而避免表搜索。\n- 反例：\n```sql\nSELECT * FROM order_master WHERE SUBSTRING(order_master_sn, 1, 4) = '2023';\nSELECT * FROM order_master WHERE payment / 2 < 500;\nSELECT * FROM f_user WHERE CONVERT(CHAR(10), birthday, 112) = '19991217'\n```\n\n- 正例：\n```sql\nSELECT * FROM order_master WHERE order_master_sn LIKE '2023%'\nSELECT * FROM order_master WHERE payment < 500 * 2\nSELECT * FROM f_user WHERE birthday = '1999-12-17'\n```\n8、很多时候用 EXISTS 代替 IN 是一个好的选择：`SELECT num from a WHERE num IN(SELECT num FROM b)`。用下面的语句替换：`SELECT num FROM a WHERE EXISTS(SELECT 1 FROM b WHERE num = a.num)`。<br />9、当在 SQL 语句中连接多个表时，尽量为表起别名，同时把别名前缀于每个 Column 上（即`order_master.order_master_id`在多表查询时给`order_master`起别名`om`，然后替换为`om.order_master_id`）。该操作可减少解析的时间并减少那些由 Column 歧义引起的语法错误。<br />10、尽量使用 “>=”，不要使用 “>”。\n\n- 说明：使用`>=`逻辑更加清晰、避免遗漏数据、能够轻松的修改边界值、可以有效避免误操作。\n\n11、选择最有效率的表名顺序（只在基于规则的优化器中有效）。\n\n- 说明：Oracle 的解析器按照从右到左的顺序处理 FROM 子句中的表名，FROM 子句中写在最后的表（基础表 driving table）将被最先处理，在 FROM 子句中包含多个表的情况下，必须选择记录条数最少的表作为基础表。\n\n12、可以通过将不需要的记录在 GROUP BY 之前过滤掉来提高 GROUP BY 语句的效率。\n\n- 反例：\n```sql\nSELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING JOB = 'PRESIDENT' OR JOB = 'MANAGER'\n```\n\n- 正例：\n```sql\nSELECT JOB, AVG(SAL) FROM EMPWHERE JOB = 'PRESIDENT' OR JOB = 'MANAGER' GROUP BY JOB\n```\n13、SQL 语句用大写，因为较多主流数据库总是先把小写的字母转换成大写的再执行。<br />14、使用`ISNULL()` 来判断是否为NULL值。 \n\n- 说明：NULL与任何值的直接比较都为NULL。\n   - `NULL <> NULL`的返回结果是NULL，而不是false。\n   - `NULL = NULL`的返回结果是NULL，而不是true。\n   - `NULL <> 1`的返回结果是NULL，而不是true。 \n- 反例：在SQL语句中，如果在NULL前换行，影响可读性。 `SELECT * FROM table WHERE column1 IS NULL AND column3 IS NOT NULL;`而`ISNULL(column)` 是一个整体，简洁易懂。从性能数据上分析，`ISNULL(column)` 执行效率更快一些。\n\n15、代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。<br />16、sql.xml配置参数使用：`#{}`，`#param#` ，不要使用 `${}` （此种方式容易出现SQL注入）。<br />17、不允许直接拿HashMap与Hashtable作为查询结果集的输出。\n\n- 反例：某同学为避免写一个`<resultMap>xxx</resultMap>`，直接使用Hashtable来接收数据库返回结果，结果出现日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。\n\n18、当只要一行数据时使用 LIMIT 1 。\n\n- 说明：当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。在这种情况下，加上 LIMIT 1 可以增加性能。这样一来，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。\n\n19、使用子查询优化大分页查询\n\n- 说明：这种优化方式只使用与`id`是正序的情况。\n- 反例：\n```sql\nSELECT score, name FROM student ORDER BY score DESC LIMIT 1000000, 10;\n```\n\n- 正例：\n```sql\nSELECT score, name FROM student\nWHERE id >= (SELECT id FROM student LIMIT 1000000, 1)\nORDER BY score\nLIMIT 10;\n```\n<a name=\"ax9ds\"></a>\n\n# 二、索引\n1、业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n\n- 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n2、超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n\n- 说明：即使双表join也要注意表索引、SQL性能。\n\n3、索引的使用规范：\n\n- 索引的创建要与应用结合考虑，且一个表尽量不要超过 6 个索引；\n- 尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过 index index_name 来强制指定索引；\n- 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；\n- 要注意索引的维护，周期性重建索引，重新编译存储过程；\n- 在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。例如对该字段的前20个字符建立索引（`ALTER table user ADD INDEX idx_desc(desc(20));`）；\n- 如果需要使用索引，不要使用uuid作为主键，不能保证其自增性，会导致数据库对B+树的操作更复杂。\n\n4、应尽可能的避免更新 Clustered 索引数据列， 因为 Clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 Clustered 索引数据列，那么需要考虑是否应将该索引建为 Clustered 索引。\n\n- 说明：聚集索引（Clustered Index）是一种SQL数据库中的索引类型，它对表中的数据行进行物理排序。每个表只能有一个聚集索引，因为它决定了数据行在磁盘上的物理存储顺序。这也意味着表中的数据行按照聚集索引的键列的值进行排序，并且物理存储位置与索引的结构紧密关联。\n<a name=\"mlW4c\"></a>\n# 三、数据库表的设计\n1、只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br />2、尽可能的使用 varchar, nvarchar 代替 char, nchar。\n\n- 说明：首先，变长字段存储空间小，可以节省存储空间；其次，对于查询来说，在一个相对较小的字段内搜索效率会更高。\n\n3、表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。\n\n- 说明：任何字段如果为非负数，必须是unsigned。\n- 正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。\n\n4、varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引率。<br />5、在数据库中不能使用物理删除操作，要使用逻辑删除。\n\n- 说明：逻辑删除在数据删除后可以追溯到行为操作。不过会使得一些情况下的唯一主键变得不唯一，需要根据情况来酌情解决。\n<a name=\"w5T7q\"></a>\n","categories":["数据库"]},{"title":"算法基础笔记","url":"/2023/06/15/算法基础笔记/","content":"\n> 所谓基础，指的是`base`，而非`easy`。—— yxc\n\n<a name=\"fhScF\"></a>\n\n## 第一章：基础算法\n\n<a name=\"KanrX\"></a>\n\n### 1. 1 快速排序$\\mathcal{O}(n \\log n)$：[快速排序](https://www.acwing.com/problem/content/787/)\n\n<a name=\"nVSic\"></a>\n\n#### 算法思想：分治\n\n1. 确定分界点 `x = q[l + r >> 1]`\n2. 调整区间：让第一个区间里的数小于等于`x`， 让第二个区间的数大于等于`x`\n3. 递归处理左右两边\n   <a name=\"ZXrlK\"></a>\n\n#### 代码实现：\n\n```java\npublic static void quick_sort(int[] q, int l, int r) {\n\tif(l >= r) return; // 如果左端点大于等于右端点，则直接返回，也为递归退出条件\n\tint i = l - 1, j = r + 1, x = q[l + r >> 1];\n\twhile(i < j) {\n\t\tdo i ++; while(q[i] < x);\n\t\tdo j --; while(q[j] > x);\n\t\tif(i < j) {\n\t\t\tint tmp = q[i];\n\t\t\tq[i] = q[j];\n\t\t\tq[j] = tmp;\n\t\t}\n\t}\n\tquick_sort(q, l, j);\n\tquick_sort(q, j + 1, r);\n}\n```\n\n<a name=\"Z30ax\"></a>\n\n### 1.2 归并排序$\\mathcal{O}(n \\log n)$\n\n<a name=\"PMNCs\"></a>\n\n#### 1.2.1 归并排序：[归并排序](https://www.acwing.com/problem/content/789/)\n\n<a name=\"oXI7a\"></a>\n\n##### 算法思想：分治\n\n1. 确定分界点 `mid = r + l >> 1`\n2. 递归处理左右两边\n3. 归并，将两个区间合二为一（从递归后的最顶层开始合并，每次回溯后达到排序的效果）($\\mathcal{O}(n)$)\n   <a name=\"DHETn\"></a>\n\n##### 代码实现：\n\n```java\npublic static void merge_sort(int[] q, int l, int r) {\n    if (l >= r) return;\n    int mid = l + r >> 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r); \n\n    int k = 0, i = l, j = mid + 1;\n    while (i <= mid && j <= r)\n        // tmp为辅助数组，用于临时存储归并数据，也是归并排序空间复杂度主要来源\n        if (q[i] <= q[j]) tmp[k ++] = q[i ++];\n        else tmp[k ++] = q[j ++];\n\n    while (i <= mid) tmp[k ++] = q[i ++];\n    while (j <= r) tmp[k ++] = q[j ++];\n\n    for (i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];\n}\n```\n\n<a name=\"rfvUw\"></a>\n\n#### 1.2.2 归并求逆序对：[逆序对的数量](https://www.acwing.com/activity/content/problem/content/822/)\n\n<a name=\"gu6yy\"></a>\n\n##### 代码实现：\n\n```java\npublic static long merge_sort(int l, int r) {\n    if(l >= r) return 0;\n    int mid = l + r >> 1;\n    int k = 0, i = l, j = mid + 1;\n    long res = merge_sort(l, mid) + merge_sort(mid + 1, r);\n    while(i <= mid && j <= r) \n        if(q[i] <= q[j]) tmp[k ++] = q[i ++];\n        else {\n            tmp[k ++] = q[j ++];\n            res += mid - i + 1;\n        }\n    while(i <= mid) tmp[k ++] = q[i ++];\n    while(j <= r) tmp[k ++] = q[j ++];\n    for(i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];\n    return res;\n}\n```\n\n<a name=\"LmlLz\"></a>\n\n### 1.3 整数二分$\\mathcal{O}(\\log n)$：[数的范围](https://www.acwing.com/problem/content/791/)\n\n<a name=\"nDrJV\"></a>\n\n#### 算法思想：\n\n1. 时时刻刻保证答案在所维护的区间内部。\n2. `check()`函数为满足条件部分，例如：`1、2、3、3、4、5`中，求`3`的起始位置，则所求位置在所有`3`范围的最左侧，于是需要保证每次`mid`需要在最左边一个`3`或其右侧，故`check()`函数为`if (q[mid] >= 3)`；若求`3`的最后位置，同理`check()`函数为`if (q[mid] <= 3)`。每次判断后需要调整区间端点，例如在求`3`的左端点时，如果满足`q[mid] >= 3`,则说明所求位置在`mid`左侧或就是`mid`，则将区间右端点更新为`mid`，即`r = mid`。\n3. 每次二分之前需将`l、r`初始化，**注意：** 更新时，若`r`被更新为`mid - 1`，则`mid`应初始化为`mid = l + r + 1 >> 1`，避免更新边界后范围不变，出现死循环。\n\n- 能使用二分的条件：必须要有**二段性**，即一定存在一个分界点，使得分界点一边(包括分界点)满足题目要求，另一边不满足。（参考[二分算法详解](http://smallboatc.github.io/2024/01/16/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/)）\n- 二分的题目有两种，一种是直接裸的二分题目，另一种则是枚举可能的答案，然后`check`这个答案是否**可行**。（二分答案）\n  <a name=\"bCFAX\"></a>\n\n#### 代码实现：\n\n```java\n// 检查x是否满足某种性质，不一定是一个函数，也可能是例如 if (a[mid] >= 3) 的简单形式\npublic static boolean check(int x) {/* ... */} \n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\npublic static int bsearch_1(int l, int r) {\n    while (l < r) {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid; // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\npublic static int bsearch_2(int l, int r) {\n    while (l < r) {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n```\n\n<a name=\"xwt7l\"></a>\n\n### 1.4 浮点数二分$\\mathcal{O}(\\log n)$：[数的三次方根](https://www.acwing.com/problem/content/792/)\n\n<a name=\"QDY11\"></a>\n\n#### 算法思想：\n\n算法原理与整数二分相似，在区间划分的时候没有整数二分的各种边界情况，一般用左右端点的差值是否小于某个值$\\epsilon$来判定是否需要继续循环。\n<a name=\"b5cNf\"></a>\n\n#### 代码实现：\n\n```java\n// 检查x是否满足某种性质\npublic static boolean check(double x) {/* ... */} \n\npublic static double bsearch_3(double l, double r) {\n    // eps 表示精度 epsilon，取决于题目对精度的要求，一般比题目保留小数位数大2\n    final static double eps = 1e-8;\n    while (r - l > eps) {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n```\n\n<a name=\"ZD5Bq\"></a>\n\n### 1.5 一维前缀和：[前缀和](https://www.acwing.com/problem/content/797/)\n\n<a name=\"aJwbp\"></a>\n\n#### 算法思想：\n\n- 在输入时，顺便记录前`i`项的和，`i`从`1 ~ n`，记为：`s[i]`，当需要求第`i`个数到第`j` 个数的和时，直接使用`s[j] - s[i - 1]`，时间复杂度为`O(1)`，比重新遍历更快。\n- 但是，如果数据会发生改变，则前缀和数组也会发生改变，而这种方式求解前缀和是$\\mathcal{O}(n)$的。则此时需要使用树状数组或者线段树进行求解（详见第二章`2.9`）。\n  <a name=\"Sa1Cj\"></a>\n\n#### 代码实现：\n\n```java\ns[i] = a[1] + a[2] + ... a[i]\n\n// 输入数组时顺带求出前缀和\nfor (int i = 1; i <= n; i ++) {\n    a[i] = sc.nextInt();\n    // sum[0] 默认为 0\n    sum[i] = sum[i - 1] + a[i];\n}\n\n// 只需要前缀和\nfor (int i = 1; i <= n; i ++) s[i] = s[i - 1] + sc.nextInt();\n\na[l] + ... + a[r] = s[r] - s[l - 1]\n```\n\n<a name=\"w7f5T\"></a>\n\n### 1.6 二维前缀和：[二维前缀和](https://www.acwing.com/problem/content/798/)\n\n<a name=\"ss2Vn\"></a>\n\n#### 算法思想：\n\n二维前缀和思想类似于一维前缀和，用`s[i][j]`表示以`(i,j)`为右下角，`(0,0)`为左上角的子矩阵中所有数之和。可用于求解以`(x1, y1)`为左上角，`(x2, y2)`为右下角的子矩阵的和为（可利用容斥原理推导）。\n<a name=\"viQAr\"></a>\n\n#### 代码实现：\n\n```java\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n\t// 求前缀和矩阵\n        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];\n// 求解以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和\nint res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n```\n\n<a name=\"ovvCL\"></a>\n\n### 1.7 一维差分：[差分](https://www.acwing.com/problem/content/799/)\n\n<a name=\"klHY9\"></a>\n\n#### 算法思想：\n\n- 实际上，差分与前缀和互为逆运算，例如，如果数组`s`为数组`a`的前缀和数组，那么`a`则称为`s`的差分数组，即`a[i] = s[i] - s[i - 1]`。\n- 差分数组的作用在于，如果需要对一个数组中的`l ~ r`区间的`k`个数字均加上`c`，则时间复杂度与`k`相关，而对其差分数组进行操作，则只需在其差分数组的第`l`项加`c`，再对第`r + 1`项减去`c`，时间复杂度降为$\\mathcal{O}(1)$。\n  <a name=\"hSUFq\"></a>\n\n#### 代码实现：\n\n```java\n// 插入操作，用于对差分数组的修改，a 数组初始化为 0\npublic static void insert(int l, int r, int c) {\n    a[l] += c;\n    a[r + 1] -= c;\n}\n\n// 读入需要操作的原数组\nfor (int i = 1; i <= n; i ++) s[i] = sc.nextInt(); \n\n/*\n利用插入操作，直接求解s数组的差分数组a。\n原理是在a[i]位置插入s[i]后，a[i + 1]会先减去s[i]，\n等到i = i + 1时，a[i + 1]的位置会加上s[i + 1]，则最终a[i + 1]位置上的数\n正好为s[i + 1] - s[i]，由定义可知，a正好构成s的差分数组\n*/\nfor (int i = 1; i <= n; i ++) insert(i, i, s[i]); \n\n// 当然，也可以直接根据定义求差分数组：a[i] = s[i] - s[i - 1];\n\n// 该操作可能会有很多组，直接对s数组操作时间复杂度较高，则对其差分数组操作，最后统一求一次前缀和即可得到新的s数组\nint l = sc.nextInt(), r = sc.nextInt(), c = sc.nextInt();\ninsert(l, r, c);\n\n// 求一遍前缀和\nfor (int i = i; i <= n; i ++) b[i] += b[i - 1]; \n```\n\n<a name=\"uHO1j\"></a>\n\n### 1.8 二维差分：[差分矩阵](https://www.acwing.com/problem/content/800/)\n\n<a name=\"oOJrb\"></a>\n\n#### 算法思想：\n\n- 类似于一维差分，二维差分与二维前缀和互为逆运算，例如，数组`s`是数组`b`的前缀和数组，那么`b`就称为`s`差分数组。\n- 二维差分数组的作用在于，如果需要对二维矩阵中以`(x1, y1)`为左上角，`(x2, y2)`为右下角的区域内每个数加上`c`，那么可以对差分矩阵中`b[x1][y1]`加上`c`，对`b[x2 + 1][y1]`与`b[x1][y2 + 1]`减去`c`，再对`b[x2 + 1][y2 + 1]`减去`c`。因为对`b[x1][y1]`，将会导致求前缀和后，`s[x1][y1]`到右下角这部分区域每个数都加上`c`，因此，根据容斥原理，需对其他部分进行如上处理。\n- 同时，与一维差分类似，二维差分也不用去想如何构造差分数组，也可以利用插入操作完成。\n  <a name=\"NmWSH\"></a>\n\n#### 代码实现：\n\n```java\n// 插入操作，用于对差分数组b进行修改，同时可以用来构造差分数组b\npublic static void insert(int x1, int y1, int x2, int y2, int c) {\n    b[x1][y1] += c; // 加c后右下角都将+c\n    b[x2 + 1][y1] -= c; // 需要对b[x2 + 1][y1]右下角减去一个c使其保持不变\n    b[x1][y2 + 1] -= c; // 需要对b[x1][y2 + 1]右下角减去一个c使其保持不变\n    b[x2 + 1][y2 + 1] += c; // b[x2 + 1][y2 + 1]右下角被减了两次，需要加一次补回来\n}\n\n// 读入需要操作的二维数组\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        s[i][j] = sc.nextInt();\n\n// 求差分数组 b\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        insert(i, j, i, j, s[i][j]);\n\n// 对原数组 O(n) 的操作等价于对差分数组 O(1) 的操作\nint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt(), c = sc.nextInt();\ninsert(x1, y1, x2, y2, c);\n\n// 对 b 数组求一遍前缀和\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];\n```\n\n<a name=\"d3Hnq\"></a>\n\n### 1.9 双指针： [最长连续不重复子序列](https://www.acwing.com/problem/content/801/)\n\n<a name=\"K7CEY\"></a>\n\n#### 算法思想：\n\n- 双指针算法是优化枚举最常用的算法，其核心思想在于通过找到单调性，将$\\mathcal{O}(n^2)$的暴力枚举转变成$\\mathcal{O}(n)$的双指针算法。\n- 该算法有两类，第一类为类似于归并排序中，在两个区间上归并的操作。第二类则在一个区间上动态维护一个小区间。\n  <a name=\"QzOAd\"></a>\n\n#### 代码实现：\n\n```java\n// 第一类同归并排序中两个指针同时扫描两个数组\n\n// 第二类\nfor (int i = 0, j = 0; i < n; i ++) {\n    while (j < i && check(i, j)) j ++; // j < i 也可以根据具体逻辑适当调整，check()为检验是否满足某一性质\n    // 具体问题的逻辑\n}\n```\n\n<a name=\"pIInD\"></a>\n\n#### 最长连续不重复子序列题解（第二类）：\n\n**题目描述：**<br />给定一个长度为`n`的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br />**输入格式：**<br />第一行包含整数`n`。<br />第二行包含`n`个整数，表示整数序列。<br />**输出格式：**<br />共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br />**数据范围：**<br />$1 \\leq n\\leq 10^5$<br />**输入样例：**\n\n```\n5\n1 2 2 3 5\n```\n\n**输出样例：**\n\n```\n3\n```\n\n**双指针算法**$\\mathcal{O}(n)$**：**<br />定义两个指针`i, j`，数组`a`，`i`从第一个元素开始往后走，每经过一个元素，用`s`数组记录当前数字出现的次数，当走到某个元素`a[i]`时，若`s[a[i]] > 1`，则说明该数字前面出现过一次，此时让`j`指针向后走，`j`指针每经过一个元素，就让该元素出现次数就减一，当不满足`s[a[i]] > 1`时，说明`j`刚好经过与`a[i]`重复的那个数值，则此时`j`不再向后走，记录`j ~ i`之间元素个数，然后`i`继续向后走，重复此过程，直到走完整个数组。\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    static final int N = 100010;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int[] s = new int[N]; // 用于记录每位数出现的次数\n\n        for (int i = 0; i < n; i ++)\n            a[i] = sc.nextInt();\n\n        int res = 0;\n        for (int i = 0, j = 0; i < n; i ++) {\n            s[a[i]] ++; // 每次 i 往后走，相应的数字出现的次数就自增\n            while (j < i && s[a[i]] > 1) {\n                s[a[j]] --; // 让 j 经过的数字出现的次数减一\n                j ++; // j 往后走\n            }\n            // 这一步就算没有遇到重复元素也会计算最长不连续数目\n            res = Math.max(res, i - j + 1); \n        }\n        System.out.println(res);\n    }\n}\n```\n\n> 这道题还有滑动窗口解法，滑动窗口更好理解，许多双指针理解起来较为抽象的题目均可使用滑动窗口解决，详见第二章`2.5`滑动窗口模板。\n\n<a name=\"b3uG4\"></a>\n\n### 1.10 位运算：[二进制中1的个数](https://www.acwing.com/problem/content/803/)\n\n<a name=\"gIDbD\"></a>\n\n#### 算法思想：\n\n该部分不存在什么思想，更多的是语法，会用即可。<br />**用法一：** 求`n`的二进制表示中第`k`位（从右往左看，最右边为第`0`位）数字。**原理：** n >> k & 1。<br />**用法二：**`lowbit`操作，返回`x`的最后一位`1`，例如`x = (1010)₂`，则`lowbit(x) = 10`；若`x = (101000)₂`，则`lowbit(x) = 1000`，具体见代码实现。**原理：** 因为`x & -x = x & (~x + 1)`，而`x & (~x + 1)`能返回`x`的最后一位`1`，所以一般用`x & -x`求解`x`的最后一位`1`。（`lowbit`操作是树状数组的基础。）\n<a name=\"yGatg\"></a>\n\n#### 代码实现：\n\n```java\n// 用法一：求 n 的二进制表示中第 k 位数字\nint res = n >> k & 1;\n\n// 用法二：返回 x 的最后一位 1\npublic static int lowbit(int x) {\n    return x & -x;\n}\n\n// 求解一个二进制数中含有多少个1的问题时，可以每次减去最后一位1（用lowbit实现），减了多少次就代表有多少个1（状态压缩常用）\n// 或者使用 Integer 的静态方法 bitCount\nint cnt = Integer.bitCount(x);\n```\n\n<a name=\"e5nZx\"></a>\n\n### 1.11 离散化：[离散化](https://www.acwing.com/problem/content/804/)\n\n<a name=\"RuxyK\"></a>\n\n#### 算法思想：\n\n离散化的思想是将数值范围很大，但是数据量不大的一系列数映射到从`0`开始的有序递增的区间，从而降低算法的时间和空间复杂度。离散化不改变数据间的相对大小，压缩数据间无用的距离。例如，`1, 3, 200, 48, 67349, 6546646`这一系列数的范围为`1 ~ 6546646`，中间有许多无用的距离，我们将其压缩到`0 ~ 5`这几个位置（有时映射到从`1`开始更加方便），此时就产生了映射关系`0 -> 1, 1 -> 3, 2 -> 48, 3 -> 200, 4 -> 67349, 5 -> 6546646`。这与直接开一个数组将他们存进去再排序是有本质区别的，例如我们想对`200`这个值加上`50`，如果直接开数组，想要找到`200`这个值，需要遍历一遍，而如果是通过离散化映射，我们可以直接利用映射关系找到在什么位置，然后直接进行操作，该步骤时间复杂度直接降低到$\\mathcal{O}(1)$。在映射之前，我们需要对数据进行排序，便于后面用整数二分找到每个数对应的映射值（下标）。同时需要对数据进行去重，因为即使有两个`200`，我们每次对`200`操作时，也是在同一个位置上进行操作的，因此重复的那个`200`不但没有存在的意义，反而影响在二分时寻找其映射值（下标）。\n<a name=\"UmYOB\"></a>\n\n#### 代码实现：\n\n```java\n// 将所有值排序，然后去重\nArrays.sort(alls); \n\n// 二分找到每个数离散化后的值（核心）\npublic static int find(int x) {\n    int l = 0, r = alls.size() - 1;\n    while (l < r) {\n        int mid = l + r >> 1;\n        if (alls[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    // 将离散化后的值映射到 1 ~ n，便于可能需要求前缀和的情况。\n    return r + 1;\n}\n```\n\n<a name=\"XdJSs\"></a>\n\n### 1.12 区间合并：[区间合并](https://www.acwing.com/problem/content/805/)\n\n<a name=\"on9RB\"></a>\n\n#### 算法思想：\n\n区间合并是将数轴上所有有交集的区间进行合并，得到没有交集的区间。例如将区间`[0, 2], [3, 7], [4, 5], [7, 10], [13, 15]`合并后的区间为`[0, 2], [3, 10], [13, 15]`。其思想类似于贪心，先将所有区间按照左端点进行排序，每次维护一个区间，**如果**枚举的区间与当前区间无交集，则将维护的区间放入答案中去，再将维护的区间更新为枚举的区间，**否则**将维护的区间的右端点更新为维护区间与枚举区间右端点的最大值。\n<a name=\"xxgs3\"></a>\n\n#### 代码实现：\n\n```java\nclass PII implements Comparable<PII> {\n    int x, y;\n    public PII(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    public int compareTo(PII p) {\n        return x - p.x;\n    }\n}\n\n// 将所有区间合并\npublic static ArrayList<PII> merge(ArrayList<PII> segs) {\n    ArrayList<PII> res = new ArrayList();\n    Collections.sort(segs);\n    int l = -2000000000, r = -2000000000;\n    for (var seg : segs)\n        if (seg.x > r) {\n            if (l != -2000000000)\n                res.add(new PII(l, r));\n            l = seg.x;\n            r = seg.y;\n        }\n        else r = Math.max(r, seg.y);\n\n    if (l != -2000000000) res.add(new PII(l, r));\n    return res;\n}\n```\n\n<a name=\"fJFhl\"></a>\n\n#### 新总结的模板（2024-03-12）：\n\n```java\n// 求合并后的区间个数\nimport java.util.*;\n\npublic class Main {\n    static class Segement implements Comparable<Segement> {\n        int x, y;\n        public Segement(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public int compareTo(Segement s) {\n            if (x != s.x) return x - s.x;\n            return s.y - y;\n        }\n    }\n    static final int N = 100010;\n    static Segement[] segments = new Segement[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 0; i < n; i ++) \n            segments[i] = new Segement(sc.nextInt(), sc.nextInt());\n        Arrays.sort(segments, 0, n);\n        int lastEnd = segments[0].y, res = 1;\n        for (int i = 1; i < n; i ++) {\n            int x = segments[i].x, y = segments[i].y;\n            if (y <= lastEnd) continue;\n            if (x > lastEnd) res ++;\n            lastEnd = y;\n        }\n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"r4jwx\"></a>\n\n## 第二章：数据结构\n\n> `2.1 ~ 2.3节`在算法题中一般不会被直接用到，但是却是后面的邻接表（图论）和单调栈及单调队列的基础。\n\n<a name=\"hfS0i\"></a>\n\n### 2.1 单链表：[单链表](https://www.acwing.com/problem/content/828/)\n\n<a name=\"KWRjs\"></a>\n\n#### 算法思想：\n\n- 该部分主要通过数组模拟单链表，进行插入结点、删除结点等操作。之所以需要用数组进行模拟，是因为在`C ++`或`java`中，`new`操作是非常慢的，在数据范围比较大的情况和容易`TLE`，并且，在很多时候，容器可以做的数组都可以做，而数组可以做的，容器不一定可以做。那么利用数组模拟就显得十分有优势。通过数组模拟单链表，需要定义`head, e[], ne[], idx`，其中`head`表示头结点，`e[]`表示每个点的值，`ne[]`表示每个点所指向的下一个点的下标，`idx`表示当前已经用到了哪个点（此时`idx`还没被用）。\n- 该部分是后面邻接表（图论）部分的基础，十分重要。\n  <a name=\"X5uDH\"></a>\n\n#### 代码实现：\n\n```java\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nstatic int head;\nstatic int[] e = new int[N];\nstatic int[] ne = new int[N];\nstatic int idx;\n\n// 初始化\npublic static void init() {\n    head = -1;\n    idx = 0;\n}\n\n// 在表头插入一个数x\npublic static void addHead(int x) {\n    e[idx] = x;\n    ne[idx] = head;\n    // 此时 idx 未被使用过，现在使用 idx\n    head = idx;\n    // idx 移动到下一个位置备用\n    idx ++;\n}\n\n// 在下标为k的结点后面插入一个数x\npublic static void add(int k, int x) {\n    e[idx] = x;\n    ne[idx] = ne[k];\n    ne[k] = idx;\n    idx ++;\n}\n\n// 删除下标为k的结点后面的一个结点\npublic static void remove(int k) {\n    if (k == 0 && head != -1) head = ne[head]; // 特判是否为头结点，删除头结点时需要判断头结点是否存在\n\telse ne[k] = ne[ne[k]];\n}\n\n// 单链表的遍历\nfor (int i = head; i != -1; i = ne[i]) System.out.printf(\"%d \", e[i]);\n```\n\n<a name=\"LD5fE\"></a>\n\n### 2.2 双链表：[双链表](https://www.acwing.com/problem/content/829/)\n\n<a name=\"z7DAc\"></a>\n\n#### 算法思想：\n\n与单链表相似，用数组模拟双链表。需定义数组`e, l, r`和变量`idx`，其中`e`表示每个结点的值，`l`表示结点的上一个结点下标，`r`表示结点的下一个结点下标，`idx`表示当前用到了哪个点（此时`idx`还未被使用）。\n<a name=\"YAAEH\"></a>\n\n#### 代码实现：\n\n```java\nint e[N], l[N], r[N], idx;\n\n// 初始化链表\npublic static void init() {\n    // 0是左端点，1是右端点\n    r[0] = 1;\n    l[1] = 0;\n    idx = 2;\n}\n\n// 在节点k的右边插入一个数x\npublic static void insert(int k, int x) {\n    e[idx] = x;\n    l[idx] = k;\n    r[idx] = r[k];\n    l[r[k]] = idx;\n    r[k] = idx ++ ;\n}\n\n// 删除节点k\npublic static void remove(int k) {\n    // 先后顺序无所谓\n    l[r[k]] = l[k];\n    r[l[k]] = r[k];\n}\n\n// 遍历双链表\nfor (int i = r[0]; i != 1; i = r[i]) System.out.printf(\"%d \", e[i]);\n```\n\n<a name=\"HQyEP\"></a>\n\n### 2.3 栈和队列：[模拟栈](https://www.acwing.com/activity/content/problem/content/865/)[模拟队列](https://www.acwing.com/activity/content/problem/content/866/)\n\n<a name=\"tfBfT\"></a>\n\n#### 算法思想：\n\n用数组模拟栈和队列，操作相对简单，具体见代码实现。\n<a name=\"ynhRH\"></a>\n\n#### 代码实现：\n\n```java\n// 数组模拟栈\nstatic int[] stk = new int[N];\nstatic int tt = 0; // 栈顶指针\nstk[ ++ t] = x; // 在栈顶插入x\ntt --; // 栈顶元素出栈\n\n// 数组模拟队列\nstatic int[] queue = new int[N];\nstatic int hh = 0, tt = -1;\nqueue[ ++ tt] = x; // 在队尾插入元素x\nhh ++; // 弹出队头元素\n```\n\n<a name=\"q0EF5\"></a>\n\n### 2.4 单调栈：[单调栈](https://www.acwing.com/activity/content/problem/content/867/)\n\n<a name=\"YPTUg\"></a>\n\n#### 算法思想：\n\n单调栈用于维护一个递增或递减的序列，可以快速求出每个数左/右边离它最近的比它**大/小**的数。\n<a name=\"dBq3R\"></a>\n\n#### 代码实现：\n\n```java\nstatic final int N = 100010;\nint[] stk = new int[N];\n\nint n = sc.nextInt();\nint tt = 0;\nfor (int i = 0; i < n; i ++) {\n    int x = sc.nextInt();\n    while(tt > 0 && check(stk[tt])) tt --; // check为具体题目的判断\n    if (tt > 0) System.out.printf(\"%d \", stk[tt]);\n    else System.out.printf(\"%d \", -1);\n    stk[++ tt] = x; // 插入新元素\n}\n```\n\n<a name=\"Zm2Jf\"></a>\n\n### 2.5 单调队列：[滑动窗口](https://www.acwing.com/activity/content/problem/content/868/)\n\n<a name=\"alsl0\"></a>\n\n#### 算法思想：\n\n- 单调队列与单调栈比较类似，用一个队列动态维护一组有序序列。每次先判断队头是否需要出栈，然后从队尾开始向前检查队尾元素与当前枚举元素的关系，如果满足`check(a[i])`，则让队尾元素弹出，直到队尾元素不满足条件。最后再将当前枚举元素加入队列。值得注意的是，队列`q[]`存储的是数组中元素的下标。\n- 该算法常用的场景为求解滑动窗口中的最大值或最小值、单调队列优化 **`dp`**。\n- [Leetcode一题秒懂单调队列！](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/)（利用Deque实现单调队列）\n  <a name=\"dVo8o\"></a>\n\n#### 代码实现：\n\n```java\nint[] a = new int[N]; // 存储所有元素\nint[] q = new int[N]; // 用于动态维护队列，存储的是元素下标\n\n// n表示所有元素个数， k表示单调队列的大小\nint n = sc.nextInt(), k = sc.nextInt();\n\n// 这里的tt初始值是有说法的，如果队列开始没有元素，则tt = -1，否则tt = 0;\nint hh = 0, tt = -1;\nfor (int i = 0; i < n; i ++) {\n    if (hh <= tt && i - k + 1 > q[hh]) hh ++; // 判断队头元素是否需要出队\n    while (hh <= tt && a[i] <= a[q[tt]]) tt --; // 判断队尾元素是否需要弹出，a[i] <= a[q[tt]]可根据题目具体条件更换\n    q[++ tt] = i; // 将枚举的元素插入队尾\n}\n```\n\n> `tt = 0` 和 `tt = -1`的情况可参考[烽火传递](https://www.acwing.com/activity/content/problem/content/9808/)与[E. Rudolf and k Bridges](https://www.acwing.com/solution/content/235596/)这两题。\n\n<a name=\"vMWEj\"></a>\n\n#### 子串类问题(滑动窗口算法框架)：\n\n> 注意：单调队列并不一定对所有的滑动窗口题目好用，只是上面这道题使用单调队列能完美解决。当涉及到字串类问题时，优先选择滑动窗口框架。\n\n> 看不懂模板可以先做做[Leetcode 438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)，再看这个模板框架。\n\n```java\n/* 滑动窗口算法框架 */\npublic static void slidingWindow(String s, String p) {\n    char[] cs = s.toCharArray(), cp = p.toCharArray();\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    int L = p.length();\n    for (int i = 0; i < L; i ++) {\n        need.put(cp[i], need.getOrDefault(cp[i], 0) + 1);\n    }\n    // 有的题目只有一个字符串，甚至都不需要 need 和 valid\n    int n = s.length(), m = need.size();\n    int left = 0, right = 0;\n    int valid = 0;\n    while (right < n) {\n        // c 是将移入窗口的字符\n        char c = cs[right];\n        // 右指针后移\n        right ++;\n        // 进行窗口内数据的一系列更新（主要是将元素抓进窗口）\n        ...\n        /**\n        示例：\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c).equals(need.get(c))) {\n                // 如果窗口中的字符c已经够了，则需求数量的字母多了一个\n                valid ++;\n            }\n        }\n        */\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // if (right - left == L) res.add(left); 根据具体题目修改\n            // d 是将移出窗口的字符\n            char d = cs[left];\n            // 左指针后移\n            left ++;\n            // 进行窗口内数据的一系列更新（主要是将元素驱出窗口）\n            ...\n            /**\n            示例：\n            if (need.containsKey(d)) {\n                if (window.get(d).equals(need.get(d))) {\n                    valid --;\n                }\n                window.put(d, window.get(d) - 1);\n            }\n            */\n        }\n    }\n}\n```\n\n<a name=\"J0QJw\"></a>\n\n### 2.6 KMP算法：[KMP字符串](https://www.acwing.com/activity/content/problem/content/869/)\n\n<a name=\"OpmSj\"></a>\n\n#### 算法思想：\n\n`kmp`算法是比较经典的字符串匹配算法，`kmp`是其三个发明人名字缩写。`kmp`算法是将模式串`P`与主串`S`进行匹配，其核心思想是将已经匹配过的字符利用起来，例如主串`S`为`abaabac`，模式串`P`为`abac`，当匹配到第四个字符发现不匹配时，主串中前三个字符已经匹配成功，我们可以将这个信息利用起来，那么下次匹配可以将`P`串的第一个字符直接与`S`串的第四个字符开始匹配，跳过了中间的一段，从而降低算法时间复杂度。而`P`串最少可以往前移动多少且可能匹配成功只取决于`P`串本身以`P[i]`结束的字串的前缀和后缀相等的最大值`(next[i])`，这便是`KMP`算法中比较抽象的`next`数组的含义。\n\n> 掌握`kmp`算法的同时建议掌握**字符串哈希**，很多抽象的`kmp`题目能够使用字符串哈希通过。\n\n<a name=\"XOuo1\"></a>\n\n#### 代码实现：\n\n```java\n// s[]为主串，p[]为模式串，n为模式串的长度， m为主串的长度\n// 求next数组\nfor (int i = 2, j = 0; i <= n; i ++) { // ne[1] = 0\n    // 当不能匹配时，j跳转到ne[j]处\n    while (j != 0 && p[i] != p[j + 1]) j = ne[j]; \n    // 若能够匹配，则让j向后走一位\n    if (p[i] == p[j + 1]) j ++; \n    ne[i] = j;\n}\n\n// 匹配过程\nfor (int i = 1, j = 0; i <= m; i ++) {\n    while (j != 0 && s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j ++;\n    // 当j走到p串末尾时，则说明一个匹配完成，即在s串中找到一个子串与p串完全相同\n    if (j == n) { \n        // 匹配成功。之所以匹配成功还需要 j = ne[j]是因为一个主串里可能包含多个模式串(为下一段匹配做准备)\n        j = ne[j]; \n        // 每道题的具体逻辑，这里是输出匹配成功的开始下标\n        bw.write(i - n + \" \"); \n    }\n}\nbw.flush();\n\n// tip：最小循环节长度：i - ne[i]\n```\n\n<a name=\"hMsgG\"></a>\n\n### 2.7 Trie树/字典树：[字符串统计](https://www.acwing.com/problem/content/837/)\n\n<a name=\"mIUZw\"></a>\n\n#### 算法思想：\n\n`Tree`树是一种用于存储字符串的高效的数据结构，以一棵树的形式存储字符串中的每个字符，如果该字符已经存在，则不重新创建，否则创建该字符，并在树中每个字符串结尾的地方做标记，表示树中含有以该字符结尾的字符串。<br />![Trie树.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_5949ec9ed8-Trie树.png)\n<a name=\"v9hti\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[][] son = new int[N][26]; // 表示每个字符的所有儿子结点\nstatic int idx; // 表示当前son中用到了哪个下标\nstatic int[] cnt = new int[N]; // 表示以cnt[p]这个字符结尾的字符串个数\n\n// 插入字符串到Trie树中\npublic static void insert(char[] str) {\n    // 从根节点开始找\n    int p = 0;\n    // 遍历要插入字符串的每个字符\n    for (int i = 0; i < str.length; i ++) {\n        // 将该字符转换为0 ~ 25的数字\n        int u = str[i] - 'a';\n        // 如果p结点不存在u这个儿子，则创建一个，son[p][u] == 0表示指向空节点，开始时也是根节点，没有子节点也指向空节点\n        if(son[p][u] == 0) son[p][u] = ++ idx; \n        // 然后更新p的位置，p往后走一个（对于存在的往后走一个，对于不存在这个字母的，上一步创建了，也往后走一个位置）\n        p = son[p][u];\n    }\n    // 添加成功后将以p位置结尾的这个字符串数量 +1\n    cnt[p] ++;\n}\n\n// 查询字符串是否在Trie树中\npublic static int query(char[] str) {\n    int p = 0;\n    for (int i = 0; i < str.length; i ++) {\n        int u = str[i] - 'a';\n        // 如果发现某个字符在当前查询的路线中不存在，则说明该字符串不在树中，直接返回0个\n        if (son[p][u] == 0) return 0;\n        // 更新p的位置\n        p = son[p][u];\n    }\n    // 返回以p位置处的字符结尾的字符串个数\n    return cnt[p];\n}\n```\n\n<a name=\"CChR3\"></a>\n\n### 2.8 并查集：[连通块中点的数量](https://www.acwing.com/problem/content/839/)\n\n<a name=\"yxFnq\"></a>\n\n#### 算法思想：\n\n- 并查集的作用是在$\\mathcal{O}(1)$的时间内将两个集合合并。其原理为：让一个集合的根节点直接指向另一个集合的根节点，成为另一个集合的一个子集。可以通过寻找一个节点的祖宗节点判断该元素属于哪个集合，其时间复杂度与树的高度相关，所以，需要对其进行优化。\n- **优化思想** ：将每个节点直接指向其祖宗节点，该操作是在寻找祖宗节点的回溯过程中完成的。\n- 查找两个点是否在同一个集合当中时，可以通过其祖宗节点是否是同一个节点进行判断。\n- **规定：** 祖宗节点的父节点等于自己（递归的退出条件）\n  <a name=\"ut2oA\"></a>\n\n#### 代码实现：\n\n```java\n// find函数，并查集的核心\npublic static int find(int x) {\n    if(p[x] != x) p[x] = find(p[x]);\n\treturn p[x];\n}\n\n// 初始化父亲数组，即每个节点开始都是一个集合\nfor (int i = 1; i <= n; i ++) p[i] = i; \n\n// 将a, b两个点合并进一个集合，此处很容易出错(将b的祖宗节点变为a的祖宗节点的父亲)\np[find(a)] = find(b); \n\n// 判断两个点是否在同一个集合\nif (find(a) == find(b))\n```\n\n<a name=\"uYOuo\"></a>\n\n### 2.9 树状数组：[动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)\n\n<a name=\"Hhncl\"></a>\n\n#### 算法思想：\n\n树状数组是一种能在$\\mathcal{O}(\\log n)$时间复杂度内修改某个数，并动态求出前缀和的数据结构。<br />能够在$\\mathcal{O}(\\log n)$内求出前缀和的原因：动态维护了一个数组（树状数组）。<br />为什么树状数组修改某个数需要$\\mathcal{O}(\\log n)$：我们是在维护的树状数组上进行修改的，因此需要修改该数并维护该树状数组。\n\n> 注意，树状数组的下标必须从`1`开始，否则会死循环，因为$lowbit(x) \\equiv 0$。\n\n**树状数组的三个核心方法：**\n\n- `lowbit`：用于定位其关联的数组元素下标；\n- `add`：对元素增加一个值（修改操作需要转为增加操作来完成）；\n- `query`：查询以某个下标结尾的前缀和。\n\n![2.9 树状数组.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_885f94f6d8-2.9-树状数组.png)\n<a name=\"cmLwp\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 100010;\n    static int[] a = new int[N], tr = new int[N];\n    static int n, m;\n    public static int lowbit(int x) {\n        return x & -x;\n    }\n    public static void add(int x, int v) {\n        for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;\n    }\n    public static int query(int x) {\n        int res = 0;\n        for (int i = x; i > 0; i -= lowbit(i)) res += tr[i];\n        return res;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) add(i, a[i]);\n        while (m -- > 0) {\n            int k = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();\n            if (k == 0) System.out.println(query(y) - query(x - 1));\n            else add(x, y);\n        }\n    }\n}\n```\n\n<a name=\"wo62f\"></a>\n\n### 2.10 线段树：[数列区间最大值](https://www.acwing.com/problem/content/1272/)，[动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)\n\n<a name=\"yeT0z\"></a>\n\n#### 算法思想：\n\n线段树是一种能在$\\mathcal{O}(\\log n)$内求出一段区间内的某个属性（`最大值`、`最小值`、`sum`等）的数据结构。\n\n> 一般来说，树状数组能干的，线段树都能干，因为线段树更加灵活。但是，由于线段树的常数太大，所以会比树状数组慢比较多。\n\n**线段树的四个核心方法：**\n\n- `pushup`：用子节点的信息更新当前节点信息（有时不用显式的写出）；\n- `build`：在一段区间上初始化线段树；\n- `modify`：修改某个数的属性，同时维护线段树；\n- `query`：查询属性。\n\n![2.10线段树.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_e60477acd8-2.10线段树.png)\n<a name=\"TXA2l\"></a>\n\n#### 代码实现：\n\n- [数列区间最大值](https://www.acwing.com/problem/content/1272/)：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static class Segment {\n        int l, r, max;\n        public Segment(int l, int r, int max) {\n            this.l = l;\n            this.r = r;\n            this.max = max;\n        }\n    }\n    static final int N = 100010;\n    static int[] w = new int[N];\n    static Segment[] tr = new Segment[4 * N];\n    \n    public static void build(int u, int l, int r) {\n        if (l == r) tr[u] = new Segment(l, r, w[r]);\n        else {\n            tr[u] = new Segment(l, r, 0);\n            int mid = l + r >> 1;\n            build(u << 1, l, mid);\n            build(u << 1 | 1, mid + 1, r);\n            // 其实就是 pushup，只是没有单独写一个pushup函数\n            tr[u].max = Math.max(tr[u << 1].max, tr[u << 1 | 1].max);\n        }\n    }\n    \n    public static int query(int u, int l, int r) {\n        if (tr[u].l >= l && tr[u].r <= r) return tr[u].max;\n        int mid = tr[u].l + tr[u].r >> 1;\n        int max = Integer.MIN_VALUE;\n        if (l <= mid) max = query(u << 1, l, r);\n        if (r > mid) max = Math.max(max, query(u << 1 | 1, l, r));\n        return max;\n    }\n    \n    public static void main (String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]), m = Integer.parseInt(s1[1]);\n        String[] s2 = br.readLine().split(\" \");\n        for (int i = 1; i <= n; i ++) w[i] = Integer.parseInt(s2[i - 1]);\n        build(1, 1, n);\n        while (m -- > 0) {\n            String[] s = br.readLine().split(\" \");\n            int x = Integer.parseInt(s[0]), y = Integer.parseInt(s[1]);\n            bw.write(query(1, x, y) + \"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n\n- [动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static class Segment {\n        int l, r, sum;\n        public Segment(int l, int r, int sum) {\n            this.l = l;\n            this.r = r;\n            this.sum = sum;\n        }\n    }\n    static final int N = 100010;\n    static Segment[] tr = new Segment[4 * N];\n    static int[] w = new int[N];\n\n    // 显示的将pushup写出\n    public static void pushup(int u) {\n        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;\n    }\n    \n    public static void build(int u, int l, int r) {\n        if (l == r) tr[u] = new Segment(l, r, w[r]);\n        else {\n            tr[u] = new Segment(l, r, 0);\n            int mid = l + r >> 1;\n            build(u << 1, l, mid);\n            build(u << 1 | 1, mid + 1, r);\n            pushup(u);\n        }\n    }\n    \n    public static int query(int u, int l, int r) {\n        if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;\n        int mid = tr[u].l + tr[u].r >> 1;\n        int res = 0;\n        if (l <= mid) res = query(u << 1, l, r);\n        if (r >= mid + 1) res += query(u << 1 | 1, l, r);\n        return res;\n    }\n    \n    public static void modify(int u, int x, int v) {\n        if (tr[u].l == tr[u].r) tr[u].sum += v;\n        else {\n            int mid = tr[u].l + tr[u].r >> 1;\n            if (x <= mid) modify(u << 1, x, v);\n            else modify(u << 1 | 1, x, v);\n            pushup(u);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) w[i] = sc.nextInt();\n        build(1, 1, n);\n        while (m -- > 0) {\n            int k = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();\n            if (k == 0) System.out.println(query(1, x, y));\n            else modify(1, x, y);\n        }\n    }\n}\n```\n\n<a name=\"tETKk\"></a>\n\n### 2.11 字符串哈希：[字符串哈希](https://www.acwing.com/problem/content/843/)\n\n<a name=\"kOQld\"></a>\n\n#### 算法思想：\n\n这里的字符串哈希是一种特殊的哈希方式，即字符串前缀哈希，其思想是将字符串转换为一个`P`进制的数，`P`的经验取值为`131`或`13331`。<br />例如，将`SmallBoat`转换为`P`进制的数（该字符串的哈希值）为：$H[n] = H[9] = H[n - 1] \\times P + str[n] = H[8] \\times P + str[9]$\n\n> 计算时会自动将字母转换为对应的`ASCII`编码值\n\n那么，给定任意的$l, r \\in [0, n - 1]$，$l \\sim r$这段字符的哈希值为：$H[l \\sim r] = H[r] - H[l - 1] \\times P^{r - l + 1}$\n<a name=\"MsqUB\"></a>\n\n#### 代码实现：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 100010, P = 131;\n    static long[] h = new long[N], p = new long[N];\n    static int n, m;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] s1 = br.readLine().split(\" \");\n        n = Integer.parseInt(s1[0]); m = Integer.parseInt(s1[1]);\n        char[] str = (\" \" + br.readLine()).toCharArray();\n        \n        p[0] = 1;\n        for (int i = 1; i <= n; i ++) {\n            p[i] = p[i - 1] * P;\n            h[i] = h[i - 1] * P + str[i];\n        }\n        \n        while (m -- > 0) {\n            String[] s2 = br.readLine().split(\" \");\n            int l1 = Integer.parseInt(s2[0]), r1 = Integer.parseInt(s2[1]);\n            int l2 = Integer.parseInt(s2[2]), r2 = Integer.parseInt(s2[3]);\n            if (getHash(l1, r1) == getHash(l2, r2)) bw.write(\"Yes\\n\");\n            else bw.write(\"No\\n\");\n        }\n        bw.flush();\n    }\n    public static long getHash(int l, int r) {\n        // 注意公式正确性，并非 (h[r] - h[l]) * p[r - l + 1]\n        return h[r] - h[l - 1] * p[r - l + 1];\n    }\n}\n```\n\n<a name=\"eNGWs\"></a>\n\n## 第三章：搜索与图论\n\n<a name=\"ZEgA6\"></a>\n\n### 3.1 树与图的存储：\n\n- 树是一种特殊的图，所以只需要会图的存储方式即可。在图中，无向图又是特殊的有向图，例如，对于一无向边`a -- b`，只需要存储两条有向边即可，即`a -> b、b -> a`，故只需要会有向图的存储即可。\n- 图的存储常用的有两种，分别为**邻接矩阵**和**邻接表**存储法。一般用邻接矩阵存储稠密图，即使用二维数组`g[][]`存储，`g[a][b]`表示一条由`a`指向`b`权值为`g[a][b]`的边。使用邻接表存储稀疏图，`h[]`存储每一条单链表的头结点，`e[]`存储每个顶点的值，`ne[]`存储每个顶点的邻点的下标，有时还会用`w[]`存储边的权重。\n  <a name=\"Sdawu\"></a>\n\n### 3.2 树与图的遍历：\n\n<a name=\"w0r6P\"></a>\n\n#### 3.2.1 DFS：\n\n<a name=\"G5wPU\"></a>\n\n##### 注意：\n\n- 在`dfs`过程中，必要时需要**恢复现场**，同时对于有的问题需要进行**剪枝**，如`n`皇后问题。\n  <a name=\"bB05L\"></a>\n\n##### 代码实现：\n\n```java\npublic static void dfs(int u) {\n    if (check()) return; // dfs退出条件\n\tst[u] = true;\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n```\n\n<a name=\"fXcks\"></a>\n\n##### DFS技巧：\n\n- 优化搜索顺序：应当优先搜索分支较少的节点，或者以使得整体搜索次数更少的顺序搜索；\n- 排除等效冗余：例如先选一再选二和先选二再选一是同一种，在搜索的时候要避免重复搜索；\n- 可行性剪枝：搜索过程中发现该分支再往下已经不是想要的结果，直接`return`；\n- 最优化剪枝：例如查找某最小值时，当前分支已经大于当前的最优解时，直接`return`；\n- 记忆化搜索（`DP`）：加缓存，每次要搜寻某个方案时，先看缓存中是否已存在，存在直接返回，不存在再搜索。\n  <a name=\"sU7te\"></a>\n\n#### 3.2.2 BFS：\n\n<a name=\"iiD9j\"></a>\n\n##### 注意：\n\n- 在`BFS`过程中没有递归，初学时要分清`BFS`和`DFS`的区别，`BFS`是维护一个队列。\n  <a name=\"atRG2\"></a>\n\n##### 代码实现（基于双端队列）：\n\n```java\nstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\npublic static void bfs() {\n    Deque<int[]> q = new ArrayDeque<>();\n    q.addLast(new int[]{0, 0});\n    st[0][0] = true;\n    \n    while (!q.isEmpty()) {\n        int[] t = q.pollFirst();\n        int x = t[0], y = t[1];\n        for (int i = 0; i < 4; i ++) {\n            int a = x + dx[i], b = y + dy[i];\n            if (a < 0 || a >= n || b < 0 || b >= m || st[a][b])\n                continue;\n            // 具体题目可能的逻辑\n            ...\n            st[a][b] = true;\n            q.addLast(new int[] {a, b});\n        }\n    }\n}\n```\n\n<a name=\"NGkui\"></a>\n\n### 3.3 拓扑排序：[有向图的拓扑排序](https://www.acwing.com/problem/content/850/)\n\n<a name=\"wtS5v\"></a>\n\n#### 算法思想：\n\n拓扑排序（`Topological Sorting`）是一个有向无环图（`DAG, Directed Acyclic Graph`）的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n- 每个顶点出现且只出现一次；\n- 若存在一条从顶点`A` 到顶点 `B` 的路径，那么在序列中顶点`A` 必须出现在顶点 `B`的前面。\n\n拓扑排序利用队列，先将所有入度为`0`的点放进队列中（用`d`数组记录每个点的入度），然后从队头元素开始遍历，并让队头元素出队，对每个点的所有邻边遍历一遍，每次遍历让其入度减一，当某个点入度为`0`时，将其放进队列中。当队列为空时，排序结束。\n<a name=\"Mo14J\"></a>\n\n#### 代码实现：\n\n> 数组模拟队列可以不用单独存储答案，出队操作时逻辑出队，因此可以直接输出。\n\n```java\npublic static boolean topSort() {\n    int hh = 0, tt = -1; // 数组模拟队列\n    for (int i = 1; i <= n; i ++) // 先将所有入度为0的点放进队列中\n        if (d[i] == 0) q[++ tt] = i;\n    // 当队列不空时，遍历队列中点的所有邻点\n    while (hh <= tt) {\n        int t = q[hh ++]; // 取出队头元素\n        for (int i = h[t]; i != -1; i = ne[i]) { // 遍历其所有邻点\n            int j = e[i];\n            d[j] --; // 每次遍历后将其入度减一\n            if (d[j] == 0) q[++ tt] = j; // 当其入度为零时，将其放进队列\n        }\n    }\n    return tt == n - 1; // 返回是否成功进行拓扑排序，当tt == n - 1时，表示已经遍历完所有点\n}\n```\n\n<a name=\"MzTMR\"></a>\n\n#### 代码实现（基于双端队列）：\n\n> 基于双端队列的实现则需要单独存一下序列，以便输出。下面代码中不用`st`也可以，因为`d[j]`每次都会被 `-1`，所以不可能有元素能重复入队，只是习惯这样。\n\n```java\nstatic List<Integer> res = new ArrayList<>();\n// 建图省略\npublic static boolean top_sort() {\n    Deque<Integer> q = new ArrayDeque<>();\n    for (int i = 1; i <= n; i ++) {\n        if (d[i] == 0) {\n            q.addLast(i);\n            st[i] = true;\n        }\n    }\n    while (!q.isEmpty()) {\n        int t = q.pollFirst();\n        res.add(t);\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (st[j]) continue;\n            d[j] --;\n            if (d[j] == 0) {\n                st[j] = true;\n                q.addLast(j);\n            }\n        }\n    }\n    return res.size() == n;\n}\n```\n\n<a name=\"a3j71\"></a>\n\n### 3.4 朴素Dijkstra算法$\\mathcal{O}(n^2 + m)$：[Dijkstra求最短路Ⅰ](https://www.acwing.com/activity/content/problem/content/918/)\n\n<a name=\"tmQFB\"></a>\n\n#### 算法思想：\n\n- 迪杰斯特拉算法只能用于求解**非负权**图的**单源路径问题**。\n- 迪杰斯特拉算法基于贪心，将第一个点到第一个点的距离赋值为`0`，其他赋值为无穷大`INF`，然后进行`n - 1`次迭代，每次从还未确定与起点最短距离的点中选出与起点距离最小的点，然后用这个点更新其他点到起点的距离，并将这个点的状态改为已确定最短距离（即`st[t] = true`）。\n- 使用**邻接矩阵**存储。\n\n> 一般都不用朴素版Dijkstra，~~有堆优化版，谁还用朴素版啊~~~\n\n> 有关图论的几个算法必须熟记时间复杂度，便于选择。\n\n<a name=\"ci5op\"></a>\n\n#### 代码实现：\n\n```java\npublic static int dijkstra() {\n    // INF = 0x3f3f3f3f表示无穷大\n    Arrays.fill(dist, INF);\n    // 初始化起点到起点的距离为0\n    dist[1] = 0; \n    // 进行n - 1次迭代，每次确定一个最小距离点\n    for (int i = 0; i < n - 1; i ++) {\n        // t只作为一个临时变量，用于筛选当前还未确定的距离最小的点\n        int t = -1;\n        for (int j = 1; j <= n; j ++) {\n            // 寻找当前还未确定最小距离的点中的最小值（t == -1 表示最开始的状态，刚开始循环。）\n            if (!st[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        }\n        // 如果当前确定这个点是n号点(求的就是1~n的距离)，则直接退出循环（剪枝）\n        if (t == n) break;\n        // 将t（此次确定的最小距离点）放入集合中\n        st[t] = true;\n        // 用此次确定的最小距离点更新其他点到起点的距离\n        for (int j = 1; j <= n; j ++)\n            dist[j] = Math.min(dist[j], dist[t] + g[t][j]);\n    }\n    if (dist[n] == INF) return -1;\n    return dist[n];\n}\n```\n\n<a name=\"rqwwa\"></a>\n\n### 3.5 堆优化版Dijkstra算法$\\mathcal{O}(m \\log n)$：[Dijkstra求最短路Ⅱ](https://www.acwing.com/activity/content/problem/content/919/)\n\n<a name=\"j7RsN\"></a>\n\n#### 算法思想：\n\n- 算法思想同朴素版，朴素版中，每次寻找当前距离最小的点时，该操作是$\\mathcal{O}(n)$级别，但是如果用堆进行维护，则该步骤时间复杂度降低为$\\mathcal{O}(1)$，降低了瓶颈处复杂度，不过当用堆维护后，在后面需要用该点更新其他点到起点的距离时，需要对堆进行操作，所以最终时间复杂度为$\\mathcal{O}(m \\log n)$。\n- 使用**邻接表**存储。\n  <a name=\"Lwsjq\"></a>\n\n#### 代码实现：\n\n```java\nstatic class PII implements Comparable<PII> {\n    // x表示该点到起点的距离，y表示节点编号\n    int x, y;\n    public int compareTo(PII p) {\n        return this.x - p.x;\n    }\n}\n\nstatic int n, m, idx;\nstatic final int N = 150010;\nstatic final int INF = 0x3f3f3f3f;\nstatic int[] h = new int[N], e = new int[N], ne = new int[N], dist = new int[N], w = new int[N]; // w表示权值\nstatic boolean[] st = new boolean[N];\nstatic PriorityQueue<PII> heap = new PriorityQueue<>();\n// 或者也可以 PriorityQueue<int[]> heap = new PriorityQueue<>((o1,o2)->o1[1]-o2[1]); <int[]>这块是一个泛型的参数声明，在集合中只能存取指定类型的元素，这里限定堆中每个元素都是一个一维数组，后面传入了一个重写compare()方法的Lambda表达式，表示每个数组元素按下标为1处的元素distance进行升序排序，堆顶元素就是还未确定最终距离的点到源点距离最近的点。\n// 大根堆写法：PriorityQueue<Integer> q = new PriorityQueue<>((o1, o2)->o2.compareTo(o1));\n\npublic static void add(int a, int b, int c) {\n    e[idx] = b;\n    w[idx] = c;\n    ne[idx] = h[a];\n    h[a] = idx ++;\n}\n\npublic static int dijkstra() {\n    // 初始化距离为无穷大\n    Arrays.fill(dist, INF); \n    // 将起点到起点的距离定义为0\n    dist[1] = 0; \n    // 将起点放进堆中(小根堆)\n    heap.add(new PII(0, 1));\n    // st[1] = true; 这里不需要提前将1的状态改为确定，因为要先用其更新其他点的距离之后再确定\n    while(!heap.isEmpty()) {\n        // 取出堆顶元素\n        PII t = heap.remove(); \n        // vertex为顶点编号,diatance为当前点到起点的距离\n        int vertex = t.y, distance = t.x; \n        // 如果当前点已经确定过最小距离，则跳过该点（因为有的点可能不止进堆一次）\n        if (st[vertex]) continue;\n        // 将该点标记为已经确定最小距离\n        st[vertex] = true;\n        // 用该点更新其他点到起点距离\n        for (int i = h[vertex]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] > distance + w[i]) {\n                dist[j] = distance + w[i];\n                // 更新后再次进堆，原来堆中的该点将会在 if (st[vertex]) continue; 这里被跳过\n                heap.add(new PII(dist[j], j));\n            }\n        }\n    }\n    if (dist[n] == INF) return -1; // 如果n号点到起点的距离不存在，返回-1即可（注意，dijkstra不存在负权值，无需考虑距离为-1的情况，bellmanFord和spfa需要考虑）\n    return dist[n];\n}\n```\n\n<a name=\"os1kn\"></a>\n\n### 3.6 Bellman-Ford算法$\\mathcal{O}(nm)$：[有边数限制的最短路](https://www.acwing.com/problem/content/855/)\n\n<a name=\"Ei2FI\"></a>\n\n#### 算法思想：\n\n- `Bellman-Ford`算法以边为单位，进行`n`次迭代，每次迭代更新一遍每个点到起点的距离。`Bellman-Ford`算法对边的存储没什么要求，直接用一个类存储即可。\n- 当题目规定求只能经过`k`条边的最短路径时，只能用`Bellman-Ford`算法，此时算法复杂度为$\\mathcal{O}(mk)$。\n- 值得一提的是每次更新时应该用上一次迭代后的`dist`数组进行更新。如果用当前的`dist`，则在更新过几条边后，`dist`数组已经改变，此时再用当前的`dist`去更新会导致本来不能更新的点也被更新掉了。例如下图中，如果要求`k = 1`时，第一次迭代，会扫面一遍所有的边，当更新完编号为`2`这个点的距离后，`dist`数组已经发生变化，当扫描到`2->3`这条边时，`dist[3]`就会被更新为`2`，而题目要求只经过`1`条边，因此答案应该为`3`，显然不对。而我们每扫描一条边，利用上一次迭代的结果，就不会因为当前一次迭代过程中`dist`数组的改变而出现错误，这就是代码实现中`backup`数组的作用。\n\n![backup数组的意义.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_0e7bae3dd8-backup数组的意义.PNG)\n<a name=\"XcUeL\"></a>\n\n#### 代码实现：\n\n```java\n// 定义边类，a表示起点，b表示终点，w表示权值\nstatic class Edge {\n    public int a, b, w;\n    public Edge(int a, int b, int w) {\n        this.a = a;\n        this.b = b;\n        this.w = w;\n    }\n}\n\npublic static int bellmanFord() {\n    // 初始化距离为无穷大\n    Arrays.fill(dist, INF); \n    // 起点距离为 0\n    dist[1] = 0;\n    // 进行k次迭代（k为题目要求的只能经过k条边）\n    for (int i = 0; i < k; i ++) { \n        // 拷贝上一次迭代后的dist数组\n        int[] backup = Arrays.copyOf(dist, dist.length); \n        // 扫描每一条边\n        for (int j = 0; j < m; j ++) { \n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            dist[b] = Math.min(dist[b], backup[a] + w); // 更新距离\n        }\n    }\n    if (dist[n] > INF / 2) flag = true; // 这种写法是为了避免下图中起点根本到达不了n这个点，而n-1这个点将dist[n]的无穷大更新为INF - 1，如下图所示\n    return dist[n];\n}\n```\n\n![无穷大被更新.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_1c31d19ad8-无穷大被更新.PNG)\n<a name=\"aMltP\"></a>\n\n### 3.7 SPFA算法$\\mathcal{O}(m) \\sim \\mathcal{O}(nm)$：[SPFA求最短路](https://www.acwing.com/problem/content/853/)\n\n<a name=\"UZGr2\"></a>\n\n#### 算法思想：\n\n- `SPFA`算法是对`Bellman-Ford`算法的**宽搜优化**，但是失去了`k`的限制（有些题目就是要在`k`次内），`Bellman-Ford`每次都用当前点去更新其他点到起点的距离，如果当前点的距离没有变小的话，那么这个操作就是在浪费时间，所以`SPFA`算法在此处进行了优化，利用一个队列，每当遍历到的点距离变小时，将其放入队列中，之后会用它去更新其他点的距离。\n- 并且，`SPFA`算法一般情况下很快，很多`Dijkstra`的题都可以用`SPFA`过掉，除非出题人故意编造数据，将`SPFA`算法时间复杂度卡成$\\mathcal{O}(nm)$。`SPFA`算法时间复杂度一般为$\\mathcal{O}(m)$，最坏$\\mathcal{O}(nm)$。\n- `Bellman-Ford`使用**类**存储每条边，`SPFA`使用**邻接表**存储图。\n- 一句话总结`SPFA`，用更新过距离的点再去更新其他点的距离。\n  <a name=\"P57kl\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean spfa() {\n    Arrays.fill(dist, INF);\n    Deque<Integer> q = new ArrayDeque<>();\n    // st数组表示当前的点是否在队列当中，防止存储重复的点(不校验基本都会TLE，因为spfa中有的点可能会重读入队)\n    q.addLast(1); dist[1] = 0; st[1] = true;\n    \n    while (!q.isEmpty()) {\n        int t = q.pollFirst();\n        // 维护st\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            // d = dist[t] + dist{t -> j}\n            int d = dist[t] + w[i];\n            // 能被更新才更新\n            if (dist[j] > d) {\n                dist[j] = d;\n                // 未在队列中才入队\n                if (!st[j]) {\n                    q.addLast(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n] != INF;\n}\n```\n\n<a name=\"ZfGqz\"></a>\n\n### 3.8 SPFA判负环：[SPFA判负环](https://www.acwing.com/activity/content/problem/content/921/)\n\n<a name=\"ozEcG\"></a>\n\n#### 算法思想：\n\n该算法基于`SPFA`算法，在该过程中增加一个`cnt`数组，表示从起点到该点经过了多少个点，如果某条最短路径上除了自己有`n`个点（假设总共有`n`个点），那么加上自己之后一共有`n + 1`个点，由[抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776)一定有两个点相同，所以存在环。并且在该背景下，这个环一定是负环，否则不会一直更新距离从而导致死循环。（当然，因为有`cnt`限制，一旦`cnt[j] >= n`，则直接`return ture`，所以代码中不会存在死循环）。\n<a name=\"pnlzU\"></a>\n\n#### 代码实现：\n\n```java\n// 队列里存储节点编号（早期代码，用LinkedList写的，实际并非队列，集合而已）\nstatic List<Integer> q = new LinkedList();\npublic static boolean spfa() {\n    // 之所以将所有点放进队列，是因为可能1号点根本到不了负环\n    for (int i = 1; i <= n; i ++) {\n        q.add(i);\n        st[i] = true;\n    }\n    while (!q.isEmpty()) {\n        int t = q.remove();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            // 一开始所有dist都等于0（不用初始化为INF），如果满足dist[j] > dist[t] + w[i]说明有负权值\n            if (dist[j] > dist[t] + w[i]) {\n                dist[j] = dist[t] + w[i];\n                // 每更新一次，将cnt[j]也更新\n                cnt[j] = cnt[t] + 1;\n                if (!st[j]) {\n                    // 如果当前点不在队列中，就将其放进队列\n                    q.add(j);\n                    st[j] = true;\n                }\n                // 如果发现某个点的cnt大于等于n，说明已经在里面转了n次了，因为如果这个环的权值之和大于等于0的话，是不会在里面一直转的，所以直接return，避免死循环\n                if(cnt[j] >= n) return true;\n            }\n        }\n    }\n    return false; // 如果一切顺利，则说明没有负环\n}\n```\n\n<a name=\"uZxnG\"></a>\n\n### 3.9 Floyd算法：[Floyd求最短路](https://www.acwing.com/problem/content/856/)\n\n<a name=\"TleJN\"></a>\n\n#### 算法思想：\n\n`Floyd`算法基于动态规划，使用三重循环，可以求解**多源汇问题**。<br />由于`Floyd`算法是最短路算法的最后一个算法，所以在此进行总结：\n\n- 朴素`Dijkstra`（单元最短路）常用于求解非负权图中的**稠密图**，时间复杂度$\\mathcal{O}(n^2 + m)$；\n- 堆优化版`Dijkstra`（单元最短路）常用于求解非负权图中的**稀疏图**，时间复杂度$\\mathcal{O}(m \\log n)$；\n- `Bellman-Ford`算法常用于求解**有边数限制的最短路问题**，时间复杂度$\\mathcal{O}(nm)$；\n- `spfa`算法常用于求解**存在负权边**的最短路问题（也可以求正权边最短路，有被卡风险），时间复杂度$\\mathcal{O}(m)$；\n- `Floyd`算法常用于求解**多源汇最短路**问题，时间复杂度$\\mathcal{O}(n^3)$，`Floyd`算法的代码实现较简单，理解不了先直接背过即可，后面学了`dp`后就好理解了。\n  <a name=\"ToS1U\"></a>\n\n#### 代码实现：\n\n```java\npublic static void floyd() {\n    for (int k = 1; k <= n; k ++)\n        for (int i = 1; i <= n; i ++)\n            for (int j = 1; j <= n; j ++)\n                // d为图的邻接矩阵，Floyd算法完成后d变成每个点到其他点的最短距离矩阵\n                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n}\n```\n\n<a name=\"G0Mdp\"></a>\n\n### 3.10 朴素Prim算法：[prim算法求最小生成树](https://www.acwing.com/problem/content/860/)\n\n<a name=\"MlZpa\"></a>\n\n#### 算法思想：\n\n- `Prim`算法是求最小生成树的一种算法，原理是从一个点出发，每次找到离集合最近的点，并将其加入到集合中，然后用这个点来更新剩下的点到集合的距离。常常用于求解**稠密图**的最小生成树问题。\n- 集合中维护的元素就是生成树中的节点，每个点到集合的距离定义为该点到集合中任意一点距离的最小值。\n- 用邻接矩阵存储图。\n  <a name=\"tWnNl\"></a>\n\n#### 代码实现：\n\n```java\npublic static int prim() {\n    Arrays.fill(dist, INF);\n    // res表示生成树中每条边的权值之和\n    int res = 0;\n    // 迭代n次，每次确定一个节点\n    for (int i = 0; i < n; i ++) {\n        // t为临时变量，用于寻找到集合的最短节点\n        int t = -1;\n        // 寻找到集合距离最短的节点\n        for (int j = 1; j <= n; j ++)\n            if (!st[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        // 如果不是第一个点，并且到集合距离最短的点的距离为无穷大，则说明最小生成树不存在\n        if (i != 0 && dist[t] == INF) return INF;\n        // 将该条边的权值加到res中\n        if (i != 0) res += dist[t];\n        // st表示是否加入到集合中\n        st[t] = true;\n        // 用该点更新其他点到集合的距离，注意不是 dist[t] + g[t][j]\n        for (int j = 1; j <= n; j ++) dist[j] = Math.min(dist[j], g[t][j]);\n    }\n    return res;\n}\n```\n\n<a name=\"qxFoi\"></a>\n\n### 3.11 Kruskal算法：[Kruskal算法求最小生成树](https://www.acwing.com/activity/content/problem/content/925/)\n\n<a name=\"ydNLU\"></a>\n\n#### 算法思想：\n\n- `Kruskal`是以边为对象，首先将所有边按照权值进行排序，然后枚举每一条边，如果一条边对应的两个顶点不在同一个集合中，那么我们就将其加入到一个集合中，在枚举过程中记录一个`cnt`变量，每次有点加入集合中，则`cnt ++`，如果枚举完成之后，`cnt < n - 1`，则说明并不是所有点都加入集合了，故最小生成树不存在。\n- 在以上过程中，判断两个是否在集合中，可以通过并查集进行查询并维护。\n  <a name=\"sx7IW\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int a, b, w;\n        public Edge(int a, int b, int w) {\n            this.a = a;\n            this.b = b;\n            this.w = w;\n        }\n    }\n    static final int N = 100010, INF = 0x3f3f3f3f;\n    static Edge[] edges = new Edge[2 * N];\n    static int[] p = new int[N];\n    static int n, m;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt(); m = sc.nextInt();\n        for (int i = 0; i < m; i ++) {\n            int a = sc.nextInt(), b = sc.nextInt(), w = sc.nextInt();\n            edges[i] = new Edge(a, b, w);\n        }\n        Arrays.sort(edges, 0, m, (o1, o2) -> o1.w - o2.w);\n        int res = kruskal();\n        System.out.println(res == INF ? \"impossible\" : res);\n    }\n    public static int kruskal() {\n        int res = 0, cnt = 0;\n        for (int i = 0; i <= n; i ++) p[i] = i;\n        for (int i = 0; i < m; i ++) {\n            int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n            a = find(a); b = find(b);\n            if (a != b) {\n                p[a] = b;\n                cnt ++;\n                res += w;\n            }\n            if (cnt == n - 1) return res;\n        }\n        return INF;\n    }\n    public static int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n}\n```\n\n<a name=\"qNQGg\"></a>\n\n### 3.12 染色法判别二分图：[染色法判别二分图](https://www.acwing.com/problem/content/862/)\n\n<a name=\"U9xRN\"></a>\n\n#### 算法思想：\n\n- **二分图：** 当且仅当图中不存在奇数环，可以利用抽屉原理进行证明；\n- **染色法**顾名思义，就是将每个点染色，染色过程中需要保证每个点与它相邻的点的颜色不同，一共两种颜色。如果在染色过程中出现矛盾，那么该图就一定不是二分图。\n  <a name=\"xnuYL\"></a>\n\n#### 代码实现：\n\n```java\n// u表示当前节点编号，c表示当前颜色\npublic static boolean dfs(int u, int c) { \n    // color表示颜色，0表示未染色，1和2表示两种不同颜色\n    color[u] = c; \n    for (int i = h[u]; i != -1; i = ne[i]) { \n        int j = e[i];\n        // 如果这个邻点未被染色，则将其染为与u不同的另一种颜色，如果染色不成功，则说明发生矛盾，直接退出\n        if (color[j] == 0 && !dfs(j, 3 - c)) return false;\n        // 如果当前节点的一个邻点与当前节点颜色相同，则发生矛盾，直接退出\n        else if (color[j] == c) return false; \n    }\n    return true;\n}\n\n// 开始时 flag 为 true，表示不存在染色失败的情况\nboolean flag = true; \n// 枚举每一个点\nfor (int i = 1; i <= n; i ++) \n    // 对还没有染色的节点染色\n    if (color[i] == 0 && !dfs(i, 1)) {\n        // 染色失败，则说明不是二分图\n        flag = false; \n        break;\n    }\n// 循环结束之后 flag 还是 true 则说明染色成功，为二分图\n```\n\n<a name=\"lwi86\"></a>\n\n### 3.13 匈牙利算法：[二分图的最大匹配](https://www.acwing.com/activity/content/problem/content/927/)\n\n<a name=\"zfSqL\"></a>\n\n#### 算法思想：\n\n- 匈牙利算法由两位匈牙利的数学家提出，因此得名。用一个形象的例子解释，一个二分图中，所有顶点分为左右两个部分，左半部分的点与右半部分的点之间存在许多边，如果其中一条边与其他任意的边都不依附于同一个顶点，则称这条边为一个匹配。例如图`1`的二分图中，图`4`就是该二分图的最大匹配，最大匹配数为`4`。\n- 在整个匹配过程中，最开始`1`号与`5`号匹配，`2`号和`7`号匹配，此时没有任何问题，当`3`号点匹配时，发现`7`号点已经被匹配过了，此时，我们看看与`7`号匹配的`2`号点能否换个点匹配，而`2`号点的另一个可匹配点`5`号点被`1`号点匹配，我们再看`1`号点能不能换个点匹配，此时发现`1`号点还可以和`6`号点匹配，于是，`1、2、3`号点都可以匹配，如图`3`所示。\n\n![二分图的最大匹配.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_370a50f7d8-二分图的最大匹配.PNG)\n<a name=\"EeLdc\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean find(int x) {\n    for (int i = h[x]; i != -1; i = ne[i]) {\n        int j = e[i];\n        // 如果j还没被考虑过\n        if (!st[j]) {\n            // 将j的状态设置为已考虑过\n            st[j] = true;\n            // 如果j还没有与其他点匹配，或者可以为与j匹配的点找到其他点进行匹配\n            if (match[j] == 0 || find(match[j])) {\n                // 那么就将j 这个点与x进行匹配(match[j]表示与j这个点匹配的点的节点编号)\n                match[j] = x;\n                // 匹配成功返回true\n                return true;\n            }\n        }\n    }\n    // 如果实在匹配不了，就返回false\n    return false;\n}\n\nint res = 0;\n// 左半部分点的编号为1~n1，依次枚举每个点，看能否找到匹配\nfor (int i = 1; i <= n1; i ++) {\n    // st表示当前点是否被考虑过，并非匹配成功与否\n    Arrays.fill(st, false);\n    // 如果找到匹配，最大匹配数加一\n    if (find(i)) res ++;\n}\n```\n\n<a name=\"my7pd\"></a>\n\n## 第四章：数学知识\n\n<a name=\"XmRxl\"></a>\n\n### 4.1 试除法判定质数：[试除法判定质数](https://www.acwing.com/problem/content/868/)\n\n<a name=\"urRDE\"></a>\n\n#### 算法思想：\n\n判定一个数`n`是否是质数，主要判定$2 \\sim \\sqrt{n}$之间是否有其约数。（所有小于`2`的数不是质数）\n<a name=\"UNmRa\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean isPrime(int x) {\n    if (x < 2) return false;\n    // 由于sqrt()比较慢，且i * i 可能爆int，所以采用此种写法\n    for (int i = 2; i <= x / i; i ++)\n        if (x % i == 0) return false;\n\treturn true;\n}\n```\n\n<a name=\"HaCNB\"></a>\n\n### 4.2 试除法分解质因数：[试除法分解质因数](https://www.acwing.com/problem/content/869/)\n\n<a name=\"Mne7Y\"></a>\n\n#### 算法思想：\n\n- 想要对一个数`x`分解质因数，主要是通过从小到大枚举其约数，当枚举到一个约数`i`时，通过一个循环，将`x`反复更新为`x = x / i`，并记录更新了多少次，这个次数就是`i`这个质因子的指数。\n- 当上述过程结束后，需要判定一下最后的`x`是否被除成了`1`，如果不是，则说明被除剩下的这个`x`也是最开始的`x`的一个质因子，且该质因子不能再被分解。\n  <a name=\"aAKGd\"></a>\n\n#### 代码实现：\n\n```java\npublic static void devide(int x) {\n    for (int i = 2; i <= x / i; i ++) {\n        // 如果i是x的约数\n        if (x % i == 0) {\n            int cnt = 0;\n            // 求出i的指数cnt，并且更新x（将这个质因子除干净）\n            while (x % i == 0) {\n                x /= i;\n                cnt ++;\n            }\n            // 输出这个质因子和它的指数\n            System.out.println(i + \" \" + cnt);\n        }\n\t}\n\tif (x > 1) System.out.println(x + \" \" + 1);\n}\n```\n\n<a name=\"sAAyB\"></a>\n\n### 4.3 筛质数：[筛质数](https://www.acwing.com/problem/content/870/)\n\n<a name=\"MgFAi\"></a>\n\n#### 4.3.1 朴素筛法：\n\n<a name=\"AeFfu\"></a>\n\n##### 算法思想：\n\n- 筛质数的目的在于求出`1 ~ n`之间的质数。那么比较快速的办法就是将`1 ~ n`当中不是质数的数给筛出去\n- 朴素筛法是利用已经确定了的质数进行筛除，其原理是将一个质数的所有小于等于`n`的倍数全部筛除\n\n> 一般都不用朴素筛法，~~都有线性筛了，谁还用朴素筛法呀~~~\n\n<a name=\"Luzjo\"></a>\n\n##### 代码实现：\n\n```java\n// 记录质数的个数\nint cnt = 0;\n// 存储所有的质数\nint[] primes = new int[n];\n// st 表示当前数是否被筛掉\nboolean[] st = new boolean[n + 10];\n// 从 2 开始枚举每个数\nfor (int i = 2; i <= n; i ++) {\n    // 如果当前的数已经被筛掉，则跳过该次循环\n    if (st[i]) continue;\n    // 否则将其加到质数数组中，同时cnt ++\n    primes[cnt ++] = i;\n    // 用当前质数筛掉其所有的倍数（如2i，3i都被筛掉）\n    for (int j = i + i; j <= n; j += i) st[j] = true;\n}\n```\n\n<a name=\"yJZtE\"></a>\n\n#### 4.3.2 线性筛法：\n\n<a name=\"FdYH1\"></a>\n\n##### 算法思想：\n\n- 线性筛法可以理解为是对朴素筛法的优化，因为朴素筛法里会多次筛除同一个数，而线性筛法中，每个合数只会被筛掉一次。\n- 其主要思想是通过每个合数的最小质因子将其筛掉。\n  <a name=\"QhNqL\"></a>\n\n##### 代码实现：\n\n```java\nint cnt = 0;\nint[] primes = new int[n];\nboolean[] st = new boolean[n + 10];\nfor (int i = 2; i <= n; i ++) {\n    // if (st[i]) continue; 此处不能continue，因为还需要用i来筛掉后面的合数\n    if (!st[i]) primes[cnt ++] = i;\n    // 每次筛掉的数为primes[j] * i，所以需要primes[j] * i <= n\n    for (int j = 0; primes[j] <= n / i; j ++) { \n        st[primes[j] * i] = true;\n        // 保证primes[j]为primes[j] * i的最小质因子，当这个条件发生后，下一个枚举的元素一定大于primes[j] * i的最小质因子，所以需要break\n        if (i % primes[j] == 0) break;\n    }\n}\n```\n\n<a name=\"IU3UX\"></a>\n\n### 4.4 试除法求约数：[试除法求约数](https://www.acwing.com/activity/content/problem/content/938/)\n\n<a name=\"ffFpl\"></a>\n\n#### 算法思想：\n\n与求质数差不多，从`0`开始枚举到$\\sqrt{n}$，对每个数`i`进行判断，如果是`x`的约数，且`i != x / i`，则将`i`与`x / i`放进答案中，最后排序输出即可。\n<a name=\"bcF27\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int T = sc.nextInt(); \n        while (T -- > 0) {\n            List<Integer> devisors = new ArrayList();\n            int x = sc.nextInt();\n            for (int i = 1; i <= x / i; i ++) {\n                if (x % i == 0) {\n                    devisors.add(i);\n                    if (x / i != i) devisors.add(x / i);\n                }\n            }\n            Collections.sort(devisors);\n            for (int a : devisors) bw.write(a + \" \");\n            bw.write(\"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n\n<a name=\"FGRaw\"></a>\n\n### 4.5 约数个数：[约数个数](https://www.acwing.com/activity/content/problem/content/939/)\n\n<a name=\"cQEAe\"></a>\n\n#### 算法思想：\n\n- 该算法求解的是一个数`x`的所有`2 ~ x - 1`中的约数个数\n- 该算法基于约数个数公式：$(\\alpha_1 + 1) \\times (\\alpha_2 + 1) \\times ... \\times (\\alpha_k + 1)$，其中$\\alpha_1$为`x`的第一个质因子的指数，$\\alpha_2$为`x`的第二个质因子的指数，依次类推。\n  <a name=\"iD8yv\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int mod = (int)1e9 + 7;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> primes = new HashMap<>();\n        while (n -- > 0) {\n            int x = sc.nextInt();\n            for (int i = 2; i <= x / i; i ++) {\n                int s = 0;\n                while (x % i == 0) {\n                    x /= i;\n                    s ++;\n                }\n                primes.put(i, primes.getOrDefault(i, 0) + s);\n            }\n            if (x > 1) {\n                primes.put(x, primes.getOrDefault(x, 0) + 1);\n            }\n        }\n        long res = 1;\n        for (int value : primes.values()) \n            res = res * (value + 1) % mod;\n        \n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"wUi0e\"></a>\n\n### 4.6 约数之和：[约数之和](https://www.acwing.com/activity/content/problem/content/940/)\n\n<a name=\"C9FxK\"></a>\n\n#### 算法思想：\n\n- `4.5`节是求一个数的约数个数，而`4.6`则是求这些约数的和。\n- 该算法同样基于公式：$(p_1^0 + p_1^1 + ... + p_1^{\\alpha_1}) \\times ... \\times (p_k^0 + p_k^1 + ... + p_k^{\\alpha_k})$。其中，$p_1$是第一个质因子，$\\alpha_1$是第一个质因子的指数。\n- 上式中，可以利用$t = t \\times p + 1$求解每一项，例如第一项$t_{\\alpha_1}$：$t_0 = 1, t_1 = p + 1, t_2 = p^2 + p + 1, ..., t_{\\alpha_1} = p^{\\alpha_1} + ... + 1$。\n  <a name=\"ROvDE\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\n// 求n个数的乘积，再求这个数的所有约数之和\npublic class Main {\n    static final int mod = (int)1e9 + 7;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> primes = new HashMap<>();\n        while (n -- > 0) {\n            int x = sc.nextInt();\n            for (int i = 2; i <= x / i; i ++) {\n                int s = 0;\n                while (x % i == 0) {\n                    x /= i; // 同4.5节\n                    s ++;\n                }\n                primes.put(i, primes.getOrDefault(i, 0) + s);\n            }\n            if (x > 1) primes.put(x, primes.getOrDefault(x, 0) + 1);\n        }\n        long res = 1;\n        for (Map.Entry prime : primes.entrySet()) { // 遍历容器中的每一项\n            long t = 1;\n            int key = (int)prime.getKey(), value = (int)prime.getValue();\n            while (value -- > 0) t = (t * key + 1) % mod; // 求解公式的每一项\n            res = res * t % mod; // 将公式的每一项相乘\n        }\n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"Yh4jS\"></a>\n\n#### 补充`map`遍历方式：\n\n```java\nfor (int key : map.keySet()) {} // 遍历每项key\nfor (int value : map.values()) {} // 遍历每项value\nfor (Map.Entry<Integer, Integer> p : entrySet()) {} // 遍历map的每个对象\n```\n\n<a name=\"wBmtv\"></a>\n\n### 4.7 最大公约数：[最大公约数](https://www.acwing.com/activity/content/problem/content/941/)\n\n<a name=\"MdBOV\"></a>\n\n#### 算法思想：\n\n如果一个数`d`能整除`a`，且能整除`b`，那么`d`一定能整除`c₁ * a + c₂ * b`。所以`d`也能够整除`a - c * b`，令`c = (a / b)`向下取整，则`a - c * b = a mod b`，所以`d`也能整除`a mod b`，故`a、 b`两个数的最大公约数等于`b、 a mod b`这两个数的最大公约数。这就是欧几里得算法的核心之处。\n<a name=\"fZu8N\"></a>\n\n#### 代码实现：\n\n```java\npublic static int gcd(int a, int b) {\n    // 如果b等于0，那么最大公约数就是a，否则就是gcd(b, a % b)\n    return b > 0 ? gcd(b, a % b) : a;\n}\n```\n\n<a name=\"HpVrm\"></a>\n\n### 4.8 欧拉函数：[欧拉函数](https://www.acwing.com/activity/content/problem/content/943/)\n\n<a name=\"Qe8xq\"></a>\n\n#### 算法思想：\n\n- 欧拉函数是指：对于一个正整数`x`，小于或等于`x`的正整数中与`x`互质的正整数个数（包括`1`）的个数，记作$\\varphi(n)$。\n- 欧拉函数的公式推导大致为：\n\n![欧拉公式.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_86291071d8-欧拉公式.png) <br />其中$p_i$为`x`的每一个质因子。上述公式的除法均为整除（即下取整），上述公式的思想为：`1 ~ x`中总共有`x`个数，减去与`x`有相同质因子的数后，剩下的数均与`x`互质，而每次会重复减去相同的数，所以再加回来（容斥原理）。\n<a name=\"BMqZD\"></a>\n\n#### 代码实现：\n\n```java\npublic static int getEuler(int x) {\n    int res = x;\n    for (int i = 2; i <= x / i; i ++) {\n        if (x % i == 0) {\n            // 公式，这种写法是避免出现小数，等价于res = res *(1 - 1 / i);\n            res = res - res / i; \n            // 把 i 除干净\n            while (x % i == 0) x /= i;\n        }\n    }\n    if (x > 1) res = res - res / x;\n    return res;\n}\n```\n\n<a name=\"rfpgz\"></a>\n\n### 4.9 筛法求欧拉函数：[筛法求欧拉函数](https://www.acwing.com/activity/content/problem/content/943/)\n\n<a name=\"GSbdg\"></a>\n\n#### 算法思想：\n\n主要思想还是基于`4.8`中的公式，此算法适用于题目要求求解`1 ~ x`中的每一个数的欧拉函数值。\n<a name=\"Y9Vxz\"></a>\n\n#### 代码实现：\n\n```java\nstatic final int N = 1000010;\nstatic int[] primes = new int[N];\nstatic boolean[] st = new boolean[N];\nstatic int[] phi = new int[N]; // 用于存放每个数的欧拉函数值\npublic static void getEuler(int x) {\n    int cnt = 0;\n    phi[1] = 1; // 对于phi[]，由于其实际意义，i从1开始\n    for (int i = 2; i <= x; i ++) {\n        if (!st[i]) {\n            primes[cnt ++] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= x / i; j ++) {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) {\n                phi[i * primes[j]] = primes[j] * phi[i]; // 公式1\n                break;\n            }\n            // 不需要else，因为如果执行了if,就会break\n            phi[i * primes[j]] = (primes[j] - 1) * phi[i]; // 公式2\n        }\n    }\n}\n```\n\n<a name=\"mrIbq\"></a>\n\n#### 公式推导：\n\n- **公式1：** 由于此时`i % primes[j] == 0`，说明`primes[j]`是`i`的最小质因子，则在计算`phi[i * primes[j]]`时，`(1 - 1 / primes[j])`已经在求解`phi[i]`时被乘过一次，所以此时不需要乘这一项。\n\n$\\varphi(i \\times\\: \\text{primes}[j]) = i \\times\\: \\text{primes}[j] \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\cdots \\times \\left(1 - \\frac{1}{p_k}\\right) =  \\text{primes}[j]  \\times \t\\varphi(i)$\n\n- **公式2：** 由于此时`i % primes[j] != 0`，说明`primes[j]`不是`i`的质因子，则在计算`phi[i * primes[j]]`时，需要乘`(1 - 1 / primes[j])`这一项，化简即可。\n\n$&\\varphi(i \\times\\: \\text{primes}[j]) = i \\times\\: \\text{primes}[j] \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\cdots \\times \\left(1 - \\frac{1}{p_k}\\right) \\times (1 - \\frac{1}{\\text{primes}[j]}) \\\\ &= \\text{primes}[j] \\times (1 -\\frac{1}{\\text{primes}[j]}) \\times \\varphi(i) \\\\ &= (\\text{primes}[j] - 1) \\times \\varphi(i)$\n\n<a name=\"BEGYT\"></a>\n\n### 4.10 快速幂：[快速幂](https://www.acwing.com/problem/content/877/)\n\n<a name=\"XDMyV\"></a>\n\n#### 算法思想：\n\n- 快速幂可以快速求解$a^b \\% p$的结果。$a^b$在`java`中虽然有方法`pow`可以使用，但是在计算过程中很容易就爆`long`，而快速幂计算的每一步都会$\\% p$，一般不会爆`long`。\n- 其思想为先预处理出$a^{2^0}, a^{2^1}, ..., a^{2^{\\log b}}$的结果，这些数每一个都是前一个的平方。这一步显然是$\\mathcal{O}(\\log b)$复杂度的。\n- 再将$a^b$分解为若干个前面预处理出来的值相乘，即将`b`分解为前面预处理出来的值的指数相加，这一步可以使用二进制进行计算，例如：十进制中的$a^5$，`5`的二进制的`101`，则`5`可以写为$2^0 + 2^2$，那么$a^5$就被分解为$a^{2^0} \\times a^{2^2}$，此时就可以用预处理出来的值相乘得到。而这一步也是$\\mathcal{O}(\\log b)$的，因此时间复杂度为$\\mathcal{O}(\\log b)$。\n  <a name=\"XiN7v\"></a>\n\n#### 代码实现：\n\n> 该模板相当精妙，在每次`while`循环时，算出$a^{2^i}$，同时判断这一个预处理出来的值需不需要乘进去，并达到了更新`a`和`b`的效果\n\n```java\npublic static int qmi(int a, int b, int p) {\n    // 防止p=1，当p=1时，答案为0\n    int res = 1 % p;\n    while(b > 0) {\n        // (b & 1)要加括号，否则&会被当作逻辑运算符，(b & 1) == 1 表示b的二进制中最后一位是否是1，& 运算符表示参与计算的两个数二进制中对应位置的数都是1才是1，否则为0\n        if ((b & 1) == 1) res = (int)((long)res * a % p);\n        // 将a更新为a^2(java为强类型语言，比c++严格，必须最后手动强转为int再复制给a)\n        a = (int)((long)a * a % p);\n        // 删除b的二进制中最后一位数\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n<a name=\"Xkti4\"></a>\n\n### 4.11 快速幂求逆元：[快速幂求逆元](https://www.acwing.com/activity/content/problem/content/945/)\n\n<a name=\"mUBgJ\"></a>\n\n#### 算法思想：\n\n- **乘法逆元定义**：若整数`b, m`互质，并且对于任意的整数`a`，如果满足`b|a`，则存在一个整数`x`，使得`a/b ≡ a * x (mod m)`，则称`x`为`b`的模`m`乘法逆元，记作`b⁻¹ (mod m)`。`b`存在乘法逆元的充分必要条件是`b`与模数`m`互质。\n\n$&\\frac{a}{b} = a \\cdot x \\pmod{m} \\\\ &b \\cdot x \\equiv 1 \\pmod{m} \\\\ &\\because m\\text{为质数，由费马小定理知,} \\\\ &b^{m-1} \\equiv 1 \\pmod{m} \\\\ &\\text{又} \\because b^{m-1} = b \\cdot b^{m-2}\\quad (m \\geq 2) \\\\ & \\therefore x \\equiv b^{m-2}\\quad (\\text{mod } m)$\n\n- 当`b`为`m`的倍数时，显然，`b % m = 0`，不存在逆元；\n- 当`b`不是`m`的倍数时，`b`的逆元为$b^{m - 2} \\% m$。\n  <a name=\"j3cuP\"></a>\n\n#### 代码实现：\n\n```java\npublic static int qmi(int a, int b, int p) {\n    int res = 1 % p;\n    while (b != 0) {\n        if ((b & 1) == 1) res = (int)((long)res * a % p);\n        a = (int)((long)a * a % p);\n        b >>= 1;\n    }\n    return res;\n}\n\nint a = sc.nextInt(), p = sc.nextInt();\nint res = qmi(a, p - 2, p);\nif (b % m != 0) System.out.println(res);\nelse System.out.println(\"impossible\");\n```\n\n<a name=\"k1url\"></a>\n\n### 4.12 扩展欧几里得算法：[扩展欧几里得算法](https://www.acwing.com/activity/content/problem/content/946/)\n\n<a name=\"DPzHN\"></a>\n\n#### 算法思想：\n\n- 想了解扩展欧几里得算法，先引入**裴属定理：** 若`a, b` 是整数,且 `gcd(a , b) = d` ，那么对于任意的整数`x, y`, `ax + by`都一定是`d`的倍数，特别地，一定存在整数`x, y`，使`ax + by = d`成立。而扩展欧几里得算法则可以很方便的求解任意正整数`a, b`的`x, y`这两个系数。即通过函数`exgcd(a, b, x, y)`求得系数`x, y`。注意：`x, y`并不唯一。\n- 由欧几里得算法知，`gcd(a, b) = gcd(b, a % b)`，而`a % b = a - a / b * b` ，那么在递归求`exgcd(b, a % b, y, x)`时有`by + (a % b)x = d`，化简得`ax + (y - a / b * x)b = d`，说明在递归时系数`x`不用更新（这里的`x`是指`exgcd`函数里的`x`，因为在每次进行递归时，会将实参交换后再复制给形参），只需要更新`y`。\n- 在`java`中没有类似`C ++`的引用类型，可以用数组进行代替。\n  <a name=\"a6D15\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[] x = new int[1];\nstatic int[] y = new int[1];\n// 形式上是把gcd拆开写\npublic static int exgcd(int a, int b, int[] x, int[] y) {\n    if (b == 0) {\n        x[0] = 1;\n        y[0] = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    // 核心，更新系数，这里实际上不只是更新y，只是变量名统一为y了，实际上是交替更新x, y\n    y[0] -= a / b * x[0];\n    return d;\n}\n```\n\n<a name=\"kX05h\"></a>\n\n### 4.13 线性同余方程：[线性同余方程](https://www.acwing.com/activity/content/problem/content/947/)\n\n<a name=\"IPFL1\"></a>\n\n#### 算法思想：\n\n- 可以通过扩展欧几里得算法求解线性同余方程`ax ≡ b (mod m)`。从取模的定义出发，可以根据`ax ≡ b (mod m)`构造出`ax = my' + b`，令`y = -y'`，整理得`ax + my = b`，当`b`为`a, m`的最小公倍数的倍数时，可以利用扩展欧几里得算法进行求解，而当`b`不是其倍数时，则无解。\n- 当用扩展欧几里得求出一组$x_0, y_0$后，此时的$x_0, y_0$满足的是$ax_0 + my_0 = gcd(a, m)$，此时，我们将等式两边同时乘以$\\frac {b}{gcd(a, m)}$，得到$ax_0(\\frac {b}{gcd(a, m)}) + my_0(\\frac {b}{gcd(a, m)}) = b$，令$x = x_0(\\frac{b}{gcd(a, m)})$，$y= y_0(\\frac{b}{gcd(a, m)})$，则此时的`x, y`即为原线性同余方程的一组解。\n  <a name=\"C7GMd\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[] x = new int[1];\nstatic int[] y = new int[1];\npublic static int exgcd(int a, int b, int[] x, int[] y) {\n    if (b == 0) {\n        x[0] = 1;\n        y[0] = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y[0] -= a / b * x[0];\n    return d;\n}\n\nint d = exgcd(a, m, x, y);\n// 若b不为d的倍数，则原线性同余方程无解\nif (b % d != 0) bw.write(\"impossible\\n\"); \n// mod m是为了将其转换为int范围内的解\nelse bw.write((long)x[0] * (b / d) % m + \"\\n\"); \nbw.flush();\n```\n\n<a name=\"bh32e\"></a>\n\n### 4.14 高斯消元$\\mathcal{O}(n^3)$：[高斯消元解线性方程组](https://www.acwing.com/problem/content/885/)\n\n<a name=\"EYJpX\"></a>\n\n#### 算法思想：\n\n高斯消元的原理是将线性方程组的增广矩阵进行初等行变换，使之成为上三角矩阵，再通过上三角矩阵倒着解出未知数。<br />**步骤如下：**\n\n- 依次遍历每一列`c`;\n- 找到这一列中绝对值最大的元素行号，若最大元素为`0`，则不需要处理此列；\n- 将其交换到第`r`行（`r`从`0`开始）;\n- 将第`r`行第`c`列元素化为`1`（初等行变换）；\n- 最后通过上三角矩阵判断解的情况。\n  <a name=\"rQdqY\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int n;\n    static double[][] a = new double[N][N];\n    static final double eps = 1e-6;\n    // 便于交换数组中的元素\n    public static void swap(int x1, int y1, int x2, int y2) { \n        double t = a[x1][y1];\n        a[x1][y1] = a[x2][y2];\n        a[x2][y2] = t;\n    }\n    public static int gauss() {\n        int c, r; // col row\n        for (c = 0, r = 0; c < n; c ++) {\n            // 标记当前列中最大元素行号\n            int t = r; \n            // 找到最大元素行号\n            for (int i = r; i < n; i ++) \n                if (Math.abs(a[i][c]) > Math.abs(a[t][c])) \n                    t = i;\n\n            // 若最大的一个元素为0，则该列不需要再进行处理\n            if(Math.abs(a[t][c]) < eps) continue; \n\n            // 将找到的这行换到第r行,从第c列开始（c列之前的全为零且能与之交换的也是0）\n            for (int i = c; i <= n; i ++)  swap(t, i, r, i); \n\n            // 将这一行所有的数除以这一行的第c个数（将第c个数化为1）\n            for (int i = n; i >= c; i --) a[r][i] /= a[r][c]; \n\n            // 将该列在该行一下的元素化为0，初等行变换（某一行减去某一行的若干倍）\n            for (int i = r + 1; i < n; i ++) { \n                // 若该列r行一下有元素本身是0，则元素所在行不需要进行处理\n                if (Math.abs(a[i][c]) > eps) \n                    for (int j  = n; j >= c; j --)  \n                        a[i][j] -= a[r][j] * a[i][c]; // 初等行变换\n            }\n            // 此处r也可以理解为增广矩阵的秩，可以通过秩判定唯一解/无穷多解/无解\n            r ++; \n        }\n\n        if (r < n) {\n            for (int i = r; i < n; i ++) {\n                // 如果系数为0，但多项式和不为0，则说明无解\n                if (Math.abs(a[i][n]) > eps) return 2; \n            }\n            // 否则为无穷多解\n            return 1; \n        }\n        // 唯一解的情况\n        else {\n            // 从倒数第二行往上解方程\n            for (int i = n - 2; i >= 0; i --) { \n                for (int j = i + 1; j < n; j ++) // i为行数，j为列数\n                    // 系数乘以未知数的值(值在该行的下一行(第j行)已经解出，并存放在a[][n])\n                    a[i][n] -= a[i][j] * a[j][n]; \n            }\n            return 0;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        n = Integer.parseInt(br.readLine());\n\n        // 读入增广矩阵\n        for (int i = 0; i < n; i ++) { \n            String[] s = br.readLine().split(\" \");\n            // 每行会多一个多项式的和\n            for (int j = 0; j <= n; j ++) { \n                a[i][j] = Double.parseDouble(s[j]);\n            }\n        }\n\n        int ans = gauss();\n        // 唯一解\n        if (ans == 0)  \n            for (int i = 0; i < n; i ++)\n                if(Math.abs(a[i][n]) < eps)\n                    // 避免数据存储时精度误差（例如存的答案为-0.00000000000001，如果保留两位小数会输出-0.00，答案应为0.00）\n                    System.out.printf(\"0.00\\n\"); \n                else\n                    System.out.printf(\"%.2f\\n\", a[i][n]);\n        else if (ans == 1) System.out.println(\"Infinite group solutions\"); // 无穷多解\n        else System.out.println(\"No solution\"); // 无解\n    }\n}\n```\n\n<a name=\"AdqL6\"></a>\n\n### 4.15 简单博弈论：[Nim游戏](https://www.acwing.com/activity/content/problem/content/961/)\n\n<a name=\"LQfgi\"></a>\n\n#### 算法思想：\n\n博弈论又被称为对策论(Game Theory)，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究已公式化的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。<br />以`Nim`游戏为例：给定`n`堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作（即没有石子可拿）的人视为失败。<br />问如果两人都采用最优策略，先手是否必胜？<br />**结论：**\n\n- 每堆石子的异或为`0`，则先手必败\n- 每堆石子的异或为`1`，则先手必胜\n  <a name=\"ksM19\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s = br.readLine().split(\" \");\n        int[] a = new int[100010];\n        int res = 0; \n        for (int i = 0; i < n; i ++) {\n            a[i] = Integer.parseInt(s[i]);\n            res ^= a[i];\n        }\n        if (res == 0) System.out.print(\"No\"); \n        else System.out.print(\"Yes\");\n    }\n}\n```\n\n<a name=\"NcXWE\"></a>\n\n## 第五章：动态规划\n\n<a name=\"C82gy\"></a>\n\n### 5.1背包问题\n\n> 考虑背包问题的时候，状态表示为：前`i`个物品（第一维），每增加一个限制，增加一维，然后再考虑对代码做等价变形优化空间。\n\n<a name=\"JIgg3\"></a>\n\n#### 5.1.1 01背包问题\n\n<a name=\"P5n2l\"></a>\n\n##### 问题描述：\n\n`01`背包问题描述的是：有`N`件物品和一个容量为`V`的背包。每件物品**只能使用一次**。其中，第`i`件物品的体积是`vi`，价值是`wi`，问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"WvGy2\"></a>\n\n##### 问题分析：\n\n![01背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_b1d88ac9d8-01背包.png)\n<a name=\"X3V7p\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 空间优化\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++) {\n            for (int j = m; j >= v[i]; j --) {\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);\n            }\n        }\n        System.out.println(f[m]);\n    }\n}\n```\n\n优化成一维的说明：[对于01背包一维优化的理解](https://www.acwing.com/file_system/file/content/whole/index/content/4813/)\n<a name=\"nVgj8\"></a>\n\n#### 5.1.2 完全背包问题\n\n<a name=\"IayfS\"></a>\n\n##### 问题描述：\n\n有`N`种物品和一个容量为`V`的背包，每种物品都有**无限**件可以使用。其中，第`i`件物品的体积是`vi`，价值是`wi`。问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"jk44j\"></a>\n\n##### 问题分析：\n\n![完全背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_c1528506d8-完全背包.png) <br />**注：** 上图中的`k`从`1`开始枚举。也可以从`0`开始枚举，则`f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i])`\n<a name=\"aI24l\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    public static final int N = 1010;\n    public static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        int[] v = new int[N];\n        int[] w = new int[N];\n\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s2[0]);\n            w[i] = Integer.parseInt(s2[1]);\n        }\n\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++)\n                for (int k = 0; k * v[i] <= j; k ++)\n                    // 之所以没有写f[i][j] = f[i - 1][j]是因为完全背包在于第i个物品的个数，k层的f[i][j]实际上是k-1层算出来的f[i][j]。\n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 优化时间\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++) {\n                f[i][j] = f[i - 1][j];\n                // 根据f[i][j]与f[i][j - v[i]]的关系推出\n                if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]); \n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 优化时间+空间\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = v[i]; j <= m; j ++) \n                // 完全背包终极写法与01背包很像，此处是从小到大遍历体积\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]); \n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"ipHIk\"></a>\n\n#### 5.1.3 多重背包问题\n\n<a name=\"eDfs7\"></a>\n\n##### 问题描述：\n\n有`N`种物品和一个容量为`V`的背包。第`i`件物品最多有`si`件，每件的体积为`vi`，价值为`wi`。问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"Gc4DY\"></a>\n\n##### 问题分析：\n\n多重背包问题的分析与完全背包问题几乎一样，只是对`k`多了一个限制（`k <= s[i]`）。\n<a name=\"Cp7OI\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[] v = new int[N], w = new int[N], s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s2[0]);\n            w[i] = Integer.parseInt(s2[1]);\n            s[i] = Integer.parseInt(s2[2]);\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) \n                for (int k = 0; k <= s[i] && k * v[i] <= j; k ++) \n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); // 代码几乎与完全背包差不多\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 二进制优化版\n\n> 多重背包二进制优化主要是将多重背包问题转换为01背包问题：将每种物品分解为若干堆，这些堆的数量总是能够凑出这种物品原来数量的任意一种取法（例如一种物品总共有8个，则将其分为1、2、4、1这几堆），然后将分堆后的每一堆物品都看作是一件新物品，再对这个些物品做一遍01背包就能求出最终的解。\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 25000;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]), m = Integer.parseInt(s1[1]);\n        int cnt = 0; // 表示最终物品的堆数，每一对物品只有拿和不拿两种状态\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            int a = Integer.parseInt(s2[0]); // 当前物品的单个体积\n            int b = Integer.parseInt(s2[1]); // 当前物品的单个价值\n            int s = Integer.parseInt(s2[2]); // 当前物品的总数量\n            int k = 1; // 将当前物品划分为很多堆，k表示每一堆的数量\n            while (k <= s) { // 二进制优化，将其转为01背包问题\n                cnt ++; // 每划分出一堆，总堆数加一\n                v[cnt] = k * a; // 计算出这一堆的总体积\n                w[cnt] = k * b; // 计算出这一对的总价值\n                s -= k; // 更新这种物品还剩的数量\n                k *= 2; // 更新k\n            }\n            if (s > 0) { // 若物品还有剩的，但是已经不足2^(k + 1)个，就直接将其看作新的一堆\n                cnt ++;\n                v[cnt] = a * s;\n                w[cnt] = b * s;\n            }\n        }\n        n = cnt; // 更新总物品堆数\n        // 做一遍 01 背包\n        for (int i = 1; i <= n; i ++)\n            for (int j = m; j >= v[i]; j --)\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);\n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"pNrJk\"></a>\n\n#### 5.1.4 分组背包问题：\n\n<a name=\"zTFFv\"></a>\n\n##### 问题描述：\n\n有`N`组物品和一个容量是`V`的背包。每组物品有若干个，同一组内的物品**最多只能选一个**。且每件物品的体积是 `v[i][j]`，价值是 `w[i][j]`，其中`i`是组号，`j`是组内编号。问：将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\n<a name=\"guQiS\"></a>\n\n##### 问题分析：\n\n![分组背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_df2a2e04d8-分组背包.png)\n<a name=\"jwkdC\"></a>\n\n##### 代码实现：\n\n- **朴素版：**\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[][] v = new int[N][N], w = new int[N][N];\n    static int[] s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            s[i] = sc.nextInt();\n            for (int j = 1; j <= s[i]; j ++) {\n                v[i][j] = sc.nextInt();\n                w[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) \n                for (int k = 1; k <= s[i]; k ++) \n                    if(v[i][k] <= j)\n                        f[i][j] = Math.max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);\n        System.out.print(f[n][m]);\n    }\n}\n```\n\n- **一维版本：**\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[][] v = new int[N][N], w = new int[N][N];\n    static int[] s = new int[N], f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        // 读入数据\n        for (int i = 1; i <= n; i ++) {\n            s[i] = Integer.parseInt(br.readLine());\n            for (int j = 1; j <= s[i]; j ++) {\n                String[] s2 = br.readLine().split(\" \");\n                v[i][j] = Integer.parseInt(s2[0]);\n                w[i][j] = Integer.parseInt(s2[1]);\n            }\n        }\n        // 有些许类似于01背包对于每个物品选或不选，倒着枚举j\n        for (int i = 1; i <= n; i ++)\n            for (int j = m; j >= 0; j --)\n                for (int k = 1; k <= s[i]; k ++)\n                    if (v[i][k] <= j)\n                        f[j] = Math.max(f[j], f[j - v[i][k]] + w[i][k]);\n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"q8rfI\"></a>\n\n### 5.2 线性dp\n\n<a name=\"U57un\"></a>\n\n#### 算法思想：\n\n这一类`Dp`先思考需要用几维来表示集合、每个集合表示的是什么、然后再思考需要将每个集合分成哪几个部分，且这几个部分均能够用已知集合推导出来。<br />线性`Dp`以**最长公共子序列**这道题为例，进行分析。\n\n- **问题描述：** 给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\n- **问题分析：**\n    - 首先思考需要用几维来表示集合：本题是两个字符串，且问的是这两个字符串之间的关系，那么根据经验，可以使用二维数组表示集合；\n    - 每个集合分别表示什么：`f[i][j]`表示所有在第一个字符串的前`i`个字母中出现，且在第二个字符串的前`j`个字母中出现的子序列；\n    - 每个集合需要分为哪几个部分：可以按照是否包含第`i`个字母或是否包含第`j`个字母分为`4`部分。\n\n![最长公共子序列.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_59623a75d8-最长公共子序列.png)\n<a name=\"qVhdh\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\npublic class Main {\n    static final int N = 1010;\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        char[] a = (\" \" + sc.next()).toCharArray();\n        char[] b = (\" \" + sc.next()).toCharArray();\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) {\n                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n                if (a[i] == b[j]) \n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n<a name=\"P7uPa\"></a>\n\n### 5.3 区间dp\n\n<a name=\"BIPvq\"></a>\n\n#### 算法思想：\n\n区间`Dp`的题目通常的枚举顺序是：先枚举区间长度，再枚举左端点、再枚举决策。<br />下面将以[石子合并](https://www.acwing.com/problem/content/284/)这道题为例进行分析：<br />**题目描述：** 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。<br />每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。<br />每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br />例如有 $4$ 堆石子分别为 `1 3 5 2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1、2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；<br />如果第二步是先合并 $2、3$ 堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。<br />问题是：找出一种合理的方法，使总的代价最小，输出最小代价。\n\n- **问题分析：**\n\n![合并石子分析.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_76a65135d8-合并石子分析.png)\n<a name=\"LMDk7\"></a>\n\n#### 代码实现：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 310, INF = 0x3f3f3f3f;\n    static int[] s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s1 = br.readLine().split(\" \");\n        for (int i = 1; i <= n; i ++) s[i] = Integer.parseInt(s1[i - 1]);\n        for (int i = 1; i <= n; i ++) s[i] += s[i - 1]; // 预处理前缀和\n\n        for (int len = 2; len <= n; len ++) { // 按照区间长度从小到大枚举\n            for (int i = 1; i + len - 1 <= n; i ++) { // i实际上就是左端点\n                int l = i, r = i + len - 1; // 定义左右端点\n                f[l][r] = INF; // 初始化f[l][r]，否则全是0，最小代价会被错误地更新\n                for (int k = l; k < r; k ++) { // 从左端点开始，遍历每个分界点\n                    // f[l][r]最终是由两个大区间合并，f[l][r]等于这两个大区间自身合并所需代价加合并这两个区间的代价\n                    f[l][r] = Math.min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n                }\n            }\n        }\n        System.out.print(f[1][n]); // 输出合并1~n这个区间的最小代价\n    }\n}\n```\n\n**区间`dp`总结：**\n\n1. 枚举区间长度`len`，`len`通常为`2 ~ n`;\n2. 枚举区间左端点（一般`i` 从第一个元素开始，右端点`i + len - 1`不能越界）；\n3. 进行决策：\n\n- 若有区间分界点，则枚举分界点（一般左端点位置为第一个分界点，右端点上一个位置为最后一个分界点）\n- 若不需要分界点，则直接进行决策\n  <a name=\"iKwRF\"></a>\n\n### 5.4 计数类dp\n\n<a name=\"qpN02\"></a>\n\n#### 算法思想：\n\n计数类`Dp`实际上就是计数类完全背包问题，只是在集合表示和集合属性上略有不同。计数类`Dp`中，`f[i][j]`的每一部分代表的就是该部分的数量，不需要加上价值，而完全背包则需要加上其价值。\n<a name=\"f4FaA\"></a>\n\n#### 问题分析：\n\n笔误：集合表示只从前`i`个数中选，且总体积恰好是`j`的选法<br />![计数类Dp.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_858eefcdd8-计数类Dp.png)\n<a name=\"t8sQG\"></a>\n\n#### 代码实现：\n\n- 优化时间\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static final int N = 1010, MOD = (int)(1e9 + 7);\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        f[0][0] = 1;\n        for (int i = 1; i <= n; i ++) {\n            for (int j = 0; j <= n; j ++) {\n                // j需要从0开始遍历，当 j >= i 时，才有f[i] [j] = (f[i - 1] [j] + f[i] [j - i])这一步的转移，同完全背包朴素版。如果上面初始化时，将f[1~n][0]都初始化成1，那么这里的j可以从1开始\n                f[i][j] = f[i - 1][j] % MOD;\n                if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % MOD;\n            }\n        }\n        System.out.print(f[n][n]);\n    }\n}\n```\n\n- 优化时间+空间\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static final int N = 1010, MOD = (int)(1e9 + 7);\n    static int[] f = new int[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        f[0] = 1;\n        for (int i = 1; i <= n; i ++) \n            for (int j = i; j <= n; j ++) \n                f[j] = (f[j] + f[j - i]) % MOD;\n        System.out.print(f[n]);\n    } \n}\n```\n\n<a name=\"UdzpI\"></a>\n\n### 5.5 状态压缩dp\n\n<a name=\"hY4p6\"></a>\n\n#### 算法思想：\n\n状态压缩dp的思想就是用一个数的二进制表现形式表示二维状态中某一维的状态。<br />**以蒙德里安的梦想这道题为例：**\n\n> [蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)：求把$N \\times M$的棋盘分割成若干个$1 \\times 2$的长方形，有多少种方案。\n> 例如$2 \\times 4$的棋盘的方案有：![5.5状态压缩dp.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_d419c420d8-5.5状态压缩dp.png)\n\n题目中要求使用`1 × 2`的小方格把棋盘填满，那么我们可以横着填，也可以竖着填。当我们把横着填的长方形填完，那么竖着填的小方格的方案就是唯一的。因此我们只需要考虑横着填的长方形有多少种填法。<br />我们分析每一列，用一个二进制数表示该列长方形的摆放状态。如果该列的某一行是`0`，则表示该列的这行没有摆放长方形，`1`则是摆放了长方形。例如上面例图中的`2 × 4`棋盘，第二个摆放方案对应的状态表示为$\\begin{bmatrix}\n1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 0\n\\end{bmatrix}$，那么我们可以用`3`表示第一列和第二列的状态，用`0`表示第三列和第四列的状态。<br />**如何判断每一列的状态是不是一个合法的状态？**<br />我们要知道，不是每一个数都能表示一个列的状态的，因为这是实际问题。例如，`11`的二进制表示`1011`就不是一个合法的状态，因为如果当前列这样摆放，那么竖着的长方形就无法摆放。<br />因此，只要一个数的二进制表示中出现了连续的奇数个`0`时，则该数就不是一个合法的状态。<br />**如何进行状态转移？**<br />首先我们定义状态数组$f[i][j]$表示前$i$列摆放完成的所有方案数。<br />$f[i][j]$表示所有能从上一个列的状态转移过来的方案数之和。\n\n> 假设第$i - 1$列被戳的状态为$k$，第$i$列被戳状态为$j$。（只考虑二进制表示中的$1$全部由上一列戳出的情况），**那么这样第**$i - 1$**列被戳和戳出的情况的考虑完了（即第**$i - 1$**列的状态为**$j \\mid k$**）**。\n\n**能够从第**$i - 1$**列戳到第**$i$**列的条件（能转移的条件，实际就是在判断第**$i- 1$**列的状态和转移方式是否合法）：**\n\n- 第$i - 1$与第$i$列不能同时被戳（`j & k = 0`）\n- 在确定第$i- 1$列被戳或向后戳出后所剩下的位置要能够摆放竖着的长方形（状态的二进制表示不能有连续奇数个`0`：即`j | k`的二进制表示不能有连续奇数个`0`）\n\n**状态转移方程：**\n\n```java\nif (满足能够从第i - 1列戳到第i列的条件)\n    f[i][j] += f[i - 1][k];\n```\n\n**初始化与答案：**<br />根据$f[i][j]$的含义，第$0$列是不会被戳的，因此其上一列（虚拟）全是竖着摆放方块的（只有这一种方案），所以$f[0][0] = 1$。<br />当我们将全部的$m$列（$0 \\sim m - 1$）摆好时，第$m$列（不需要摆放方块的列）没有被戳的所有方案数之和即为答案，即$f[m][0]$。\n<a name=\"c9j85\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 12, M = 1 << 12;\n    static long[][] f = new long[N][M];\n    static boolean[] st = new boolean[M];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt(), m = sc.nextInt();\n            if (n == 0 && m == 0) break;\n            // 预处理每个状态的合法性\n            Arrays.fill(st, true);\n            for (int i = 0; i < 1 << n; i ++) {\n                int cnt = 0;\n                for (int j = 0; j < n; j ++)\n                    if (((i >> j) & 1) == 1) {\n                        if ((cnt & 1) > 0) {\n                            st[i] = false;\n                            break;\n                        }\n                    }\n                    else cnt ++;\n                if ((cnt & 1) > 0) st[i] = false;\n            }\n            for (int i = 0; i < N; i ++) Arrays.fill(f[i], 0);\n            f[0][0] = 1;\n            // 状态转移\n            for (int i = 1; i <= m; i ++)\n                for (int j = 0; j < 1 << n; j ++)\n                    for (int k = 0; k < 1 << n; k ++)\n                        if ((j & k) == 0 && st[j | k])\n                            f[i][j] += f[i - 1][k];\n            System.out.println(f[m][0]);\n        }\n    }\n}\n```\n\n<a name=\"DZPyh\"></a>\n\n## 第六章：由不同数据范围反推时间复杂度和算法内容\n\n1. $n \\leq 30 \\Rightarrow$指数级别：`dfs + 剪枝`、`状态压缩dp`\n2. $n \\leq 100 \\Rightarrow \\mathcal{O}(n^3)$：`floyd`、`dp`、`高斯消元`\n3. $n \\leq 1000 \\Rightarrow \\mathcal{O}(n^2) 或 \\mathcal{O}(n^2 \\log n)$：`dp`、`二分`、`朴素Dijkstra`、`朴素版Prim`、`Bellman-Ford`\n4. $n \\leq 10000 \\Rightarrow \\mathcal{O}(n \\times \\sqrt{n})$：`块状链表`、`分块`、`莫队`\n5. $n \\leq 10^5 \\Rightarrow \\mathcal{O}(n \\log n)$：`各种sort`、`线段树`、`树状数组`、`set/map`、`heap`、`拓扑排序`、`dijkstra + heap`、`prim + heap`、`Kruskal`、`spfa`、`求凸包`、`求半平面交`、`二分`、`CDQ分治`、`整体二分`、`后缀数组`、`树链剖分`、`动态树`\n6. $n \\leq 10^6 \\Rightarrow \\mathcal{O}(n)或常数较小的\\mathcal{O}(n \\log n)$：`单调队列`、`hash`、`双指针`、`并查集`，`kmp`、`AC自动机`、`sort`、`树状数组`、`heap`、`dijkstra`、`spfa`\n7. $n \\leq 10^7 \\Rightarrow \\mathcal{O}(n)$：`双指针`、`kmp`、`AC自动机`、`线性筛质数`\n8. $n \\leq 10^9 \\Rightarrow \\mathcal{O}(\\sqrt{n})$：`试除法判断质数`\n9. $n \\leq 10^{18} \\Rightarrow \\mathcal{O}(\\log n)$：`最大公约数`，`快速幂`，`数位dp`\n10. $n \\leq 10^{1000} \\Rightarrow \\mathcal{O}((\\log n)^2)(\\log n 表示位数)$：`高精度加减乘除`\n11. $n \\leq 10^{100000} \\Rightarrow \\mathcal{O}(\\log k \\times \\log\\log k)(k表示位数)$：`高精度加减`、`FFT/NTT`","categories":["算法"]}]