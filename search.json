[{"title":"Redis 实战篇","url":"/2024/03/18/Redis实战篇/","content":"\n> Author：SmallBoat\n\n<a name=\"LQFnK\"></a>\n\n## 内容概述\n\n**当下主流模型介绍：**<br />手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的是HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量。我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，最多能处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。<br />在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器一般是16或32核心cpu，32或64G内存，就算是企业级mysql加上固态硬盘能够支撑的并发，大概就是4000~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满。所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。<br />**短信登录：**\n\n- 代码实现登录相关内容：如实现短信验证码登录、登录校验拦截、解决Session共享问题等\n- 通过Redis共享Session实现短信登录的验证\n\n**商户查询缓存：**\n\n- 常见的缓存更新策略\n- 分析并解决缓存穿透、缓存雪崩、缓存击穿等问题\n- 封装Redis工具类\n\n**优惠券秒杀（4-8章）：**\n\n- 通过乐观锁、悲观锁解决优惠券下单业务的线程安全问题\n- Lua脚本实现原子操作\n- Redis实现分布式锁及分布式解决框架Redisson\n- Redis实现消息队列\n\n**达人探店：**\n\n- 利用Set对点赞用户判重\n- 利用SortedSet对点赞用户进行排名\n\n**好友关注：**\n\n- 利用Set集合快速求出共同关注（交集）\n- 利用Feed流实现消息推送\n\n**附近商户：**\n\n- 利用GEO数据结构实现附近商户的查询\n\n**用户签到：**\n\n- 利用BitMap实现用户签到功能及连续签到天数统计\n- 简单分析布隆过滤器解决缓存穿透问题思路\n\n**UV统计：**\n\n- 利用HyperLogLog数据结构实现百万UV统计\n  <a name=\"d2Ghb\"></a>\n\n## 短信登录\n\n<a name=\"rbqgw\"></a>\n\n### 基于Session实现登录流程\n\n!![1.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_5fe0ce7427-1.png) <br />**实现发送验证码：**\n\n```java\n@Override\npublic Result sendCode(String phone, HttpSession session) {\n    // 1.校验手机号\n    if (RegexUtils.isPhoneInvalid(phone)) {\n        // 2.如果不符合，返回错误信息\n        return Result.fail(\"手机号格式错误！\");\n    }\n    // 3.符合，生成验证码\n    String code = RandomUtil.randomNumbers(6);\n\n    // 4.保存验证码到 session\n    session.setAttribute(\"code\", code);\n\n    // 5.发送验证码（并没有真正发送，只是存到日志里）\n    log.debug(\"发送短信验证码成功，验证码：{}\", code);\n    // 返回ok\n    return Result.ok();\n}\n```\n\n**实现验证码登录与注册：**\n\n```java\n@Override\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n    // 1.校验手机号\n    String phone = loginForm.getPhone();\n    if (RegexUtils.isPhoneInvalid(phone)) {\n        // 2.如果不符合，返回错误信息\n        return Result.fail(\"手机号格式错误！\");\n    }\n    // 3.从session获取验证码并校验\n    Object cacheCode = session.getAttribute(\"code\");\n    String code = loginForm.getCode();\n    if (cacheCode == null || !cacheCode.toString().equals(code)) {\n        // 不一致，报错\n        return Result.fail(\"验证码错误\");\n    }\n\n    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?\n    User user = query().eq(\"phone\", phone).one();\n\n    // 5.判断用户是否存在\n    if (user == null) {\n        // 6.不存在，创建新用户并保存\n        user = createUserWithPhone(phone);\n    }\n\n    // 7.保存用户信息到 session中\n    session.setAttribute(\"user\", BeanUtil.copyProperties(user, UserDTO.class));\n    return Result.ok();\n}\n\nprivate User createUserWithPhone(String phone) {\n    // 1.创建用户\n    User user = new User();\n    user.setPhone(phone);\n    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));\n    // 2.保存用户\n    save(user);\n    return user;\n}\n```\n\n<a name=\"Yr548\"></a>\n\n### 实现登录拦截功能\n\n**前置知识：**\n\n- **tomcat运行原理：** 每次用户请求过来时，会访问我们在tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接时，就会由监听线程创建socket连接，socket都是成对出现的，用户通过socket传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应。\n\n![2.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_646c078627-2.png)\n\n- **线程隔离：** 每个用户都是去找tomcat线程池中的一个线程来完成工作，使用完成后再进行回收，并且每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，使得每个线程操作自己的一份数据。\n\n基于以上情况，我们可以在线程转发到对应的controller之前对用户身份进行校验，检查Session中的user是否为null。<br />![3.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_6849d26327-3.png) <br />**实现拦截器：**\n\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.获取session\n        HttpSession session = request.getSession();\n        // 2.获取session中的用户\n        Object user = session.getAttribute(\"user\");\n        // 3.判断用户是否存在\n        if(user == null) {\n              // 4.不存在，拦截，返回401状态码\n              response.setStatus(401);\n              return false;\n        }\n        // 5.存在，保存用户信息到Threadlocal\n        UserHolder.saveUser((User)user);\n        // 6.放行\n        return true;\n    }\n}\n```\n\n**将拦截器配置到MvcConfig使其生效：**\n\n```java\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        \"/shop/**\",\n                        \"/voucher/**\",\n                        \"/shop-type/**\",\n                        \"/upload/**\",\n                        \"/blog/hot\",\n                        \"/user/code\",\n                        \"/user/login\"\n                ).order(1);\n        // token刷新的拦截器\n        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\"/**\").order(0);\n    }\n}\n```\n\n<a name=\"io1HZ\"></a>\n\n### 集群下的Session共享问题\n\n<a name=\"gd7dp\"></a>\n\n#### Session共享问题\n\n在集群模式下，nginx可能会将同一个用户的多次请求分配到不同的tomcat进行处理，每个tomcat中都有一份属于自己的session，假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时整个登录拦截功能就会出现问题。这就是集群下的Session共享问题。\n<a name=\"BXVG1\"></a>\n\n#### session拷贝\n\n早期的方案是session拷贝：每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样就能实现session的共享了。<br />但是这种方案会存在**两大问题**：\n\n- 每台服务器中都有完整的一份session数据，服务器压力过大；\n- session拷贝数据时，可能会出现延迟。\n\n**_于是，强大的Redis登场了。↓_**\n<a name=\"EzKug\"></a>\n\n### Redis实现Session共享\n\n<a name=\"FsCAJ\"></a>\n\n#### 设计key结构\n\n首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，但是会多占用一点空间。<br />![4.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_6a972e3927-4.png) <br />如果使用哈希，则他的value中只会存储他数据本身。如果不是特别在意内存，其实使用String就可以了。<br />![5.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_6e2470a327-5.png) <br />所以我们选择简单的String结构。关于key的处理，每个用户有自己的Session，但是redis的key是共享的，所以需要为每个用户生成一个token，按照“前缀 + token”的方式作为key存储用户的信息。\n<a name=\"QmdzF\"></a>\n\n#### 引入Redis后的登录业务流程\n\n![6.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_70eb198427-6.png) <br />**实现发送验证码：**\n\n```java\n@Override\npublic Result sendCode(String phone, HttpSession session) {\n    // 1.校验手机号\n    if (RegexUtils.isPhoneInvalid(phone)) {\n        // 2.如果不符合，返回错误信息\n        return Result.fail(\"手机号格式错误！\");\n    }\n    // 3.符合，生成验证码\n    String code = RandomUtil.randomNumbers(6);\n\n    // 4.保存验证码到 redis\n    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);\n\n    // 5.发送验证码\n    log.debug(\"发送短信验证码成功，验证码：{}\", code);\n    // 返回ok\n    return Result.ok();\n}\n```\n\n**实现验证码登录与注册：**\n\n```java\n@Override\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n    // 1.校验手机号\n    String phone = loginForm.getPhone();\n    if (RegexUtils.isPhoneInvalid(phone)) {\n        // 2.如果不符合，返回错误信息\n        return Result.fail(\"手机号格式错误！\");\n    }\n    // 3.从redis获取验证码并校验\n    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);\n    String code = loginForm.getCode();\n    if (cacheCode == null || !cacheCode.equals(code)) {\n        // 不一致，报错\n        return Result.fail(\"验证码错误\");\n    }\n\n    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?\n    User user = query().eq(\"phone\", phone).one();\n\n    // 5.判断用户是否存在\n    if (user == null) {\n        // 6.不存在，创建新用户并保存\n        user = createUserWithPhone(phone);\n    }\n\n    // 7.保存用户信息到 redis中\n    // 7.1.随机生成token，作为登录令牌\n    String token = UUID.randomUUID().toString(true);\n    // 7.2.将User对象转为HashMap存储\n    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);\n    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),\n            CopyOptions.create()\n                    .setIgnoreNullValue(true)\n                    .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));\n    // 7.3.存储\n    String tokenKey = LOGIN_USER_KEY + token;\n    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);\n    // 7.4.设置token有效期\n    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);\n\n    // 8.返回token\n    return Result.ok(token);\n}\n```\n\n<a name=\"zlEde\"></a>\n\n### Redis实现Session的刷新\n\n**现在有这样一个场景：** 用户已经登录，然后过了一阵访问了一个不需要拦截的路径。结果再访问需要拦截的路径时发现登录过期了。<br />**问题分析：** 由于用户访问的是不需要拦截的路径，因此在访问时，token不会被刷新，于是下一次访问时，发现token已经过期。<br />![7.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_742ff9a827-7.png) <br />**解决方案：** 既然已登录用户在访问无需拦截的路径不会刷新token，那么我们就在拦截器前面再加一个拦截器，这个拦截器专门用来刷新token或者放行未登录用户。再到第二个拦截器时再判断是否需要登录才能访问。<br />![8.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_7679eb5b27-8.png) <br />**实现拦截器1：**\n\n```java\npublic class RefreshTokenInterceptor implements HandlerInterceptor {\n\n    private StringRedisTemplate stringRedisTemplate;\n\n    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.获取请求头中的token\n        String token = request.getHeader(\"authorization\");\n        if (StrUtil.isBlank(token)) {\n            return true;\n        }\n        // 2.基于TOKEN获取redis中的用户\n        String key  = LOGIN_USER_KEY + token;\n        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);\n        // 3.判断用户是否存在\n        if (userMap.isEmpty()) {\n            return true;\n        }\n        // 5.将查询到的hash数据转为UserDTO\n        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);\n        // 6.存在，保存用户信息到 ThreadLocal\n        UserHolder.saveUser(userDTO);\n        // 7.刷新token有效期\n        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);\n        // 8.放行\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        // 移除用户\n        UserHolder.removeUser();\n    }\n}\n```\n\n**简化拦截器2：**\n\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.判断是否需要拦截（ThreadLocal中是否有用户）\n        if (UserHolder.getUser() == null) {\n            // 没有，需要拦截，设置状态码\n            response.setStatus(401);\n            // 拦截\n            return false;\n        }\n        // 有用户，则放行\n        return true;\n    }\n}\n```\n\n<a name=\"Wc2O4\"></a>\n\n## 商户查询缓存\n\n<a name=\"JupxW\"></a>\n\n### 什么是缓存\n\n生活中，与缓存相似的就好比越野车的“减震器”，它可以防止越野车因硬着陆导致车体损伤。<br />在我们的项目开发中，我们也需要类似的功能来解决大量的数据猛冲进系统，导致其操作线程无法处理过量信息而导致瘫痪的问题。<br />并且在企业中，如果这种情况处理不好，会极大的降低用户的口碑，所以企业十分重视缓存技术。<br />**缓存：** 即数据的交换缓冲区，平时我们所说的缓存其实就是缓冲区中的数据，一般来讲是从数据库中获取，并存储在本地。<br />**例如：**\n\n```java\n// 本地用于高并发\nstatic final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>();\n\n// 用于redis等缓存\nstatic final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build();\n\n// 本地缓存\nstatic final Map<K,V> map = new HashMap();\n```\n\n> 由于其被**static**修饰，所以随着类的加载而被加载到**内存之中**,作为本地缓存；由于其又被**final**修饰，所以其引用(map)和对象(new HashMap())之间的关系是固定的，不能改变，因此不用担心赋值(=)导致缓存失效。\n\n当然，使用缓存也是有一定的成本的：<br />![9.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_78d84f5e27-9.png)\n<a name=\"Rq1m6\"></a>\n\n### 缓存的使用场景\n\n实际开发中，会构筑多级缓存来使系统运行速度进一步提升，例如：本地缓存与redis中的缓存并发使用。<br />常见的缓存主要有一下几种：\n\n- **浏览器缓存：** 主要是存在于浏览器端的缓存；\n- **应用层缓存：** 可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存；\n- **数据库缓存：** 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中；\n- **CPU缓存：** 当代计算机最大的问题是cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存。\n\n![10.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_7b5ed7d527-10.png)\n<a name=\"JCbbI\"></a>\n\n### 添加商户缓存\n\n我们在查询商户信息的时候，如果直接去数据库里查修，速度就会比较慢，所以需要在这里添加商户的缓存。<br />标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。<br />![11.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_7f7b24e027-11.png) <br />**代码实现：**\n\n```java\n@Override\npublic Result queryById(Long id) {\n    // 先从Redis中查，这里的常量值是固定的前缀 + 店铺id\n    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);\n    // 如果不为空（查询到了），则转为Shop类型直接返回\n    if (StrUtil.isNotBlank(shopJson)) {\n        Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n        return Result.ok(shop);\n    }\n    // 否则去数据库中查\n    Shop shop = getById(id);\n    // 查不到返回一个错误信息或者返回空都可以，根据自己的需求来\n    if (shop == null) {\n        return Result.fail(\"店铺不存在！！\");\n    }\n    // 查到了则转为json字符串\n    String jsonStr = JSONUtil.toJsonStr(shop);\n    // 并存入redis\n    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr);\n    // 最终把查询到的商户信息返回给前端\n    return Result.ok(shop);\n}\n```\n\n<a name=\"RcKoX\"></a>\n\n### 缓存更新策略\n\n缓存更新是redis为了节约内存而设计出来的，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他称作淘汰更合适。<br />**缓存更新主要策略：**\n\n- **内存淘汰：** redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)；\n- **超时剔除：** 当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存；\n- **主动更新：** 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。\n\n![12.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_8285320c27-12.png)\n<a name=\"jdUjM\"></a>\n\n#### 数据库与缓存数据不一致问题\n\n由于我们的缓存的数据源来自于数据库，而数据库的数据是会发生变化的。因此，如果当数据库中数据发生变化，而缓存却没有同步，此时就会有**一致性问题**存在，其后果是：用户使用缓存中的过时数据,就会产生类似多线程数据安全问题，从而影响业务，产品口碑等。<br />**当前几种较为常见的解决方案（主动更新的几种方式）：**\n\n- Cache Aside Pattern（旁路缓存模式）：先更新数据库，然后再更新缓存（双写方案）；\n- Read/Write Through Pattern（读写穿透）：将缓存和数据库整合为一个服务，由服务来维护数据一致性；\n- Write Behind Caching Pattern（异步缓存写入）：调用者只操作缓存，由其他线程异步将缓存持久化到数据库。\n  <a name=\"tAEei\"></a>\n\n#### 缓存不一致采用的最终方案\n\n各个方案的特点：\n\n- Cache Aside Pattern：需要写代码，较为复杂，但可以人为控制；\n- Read/Write Through Pattern：调用者无需关心一致性问题，维护这样一个服务是比较复杂的，开发成本高；\n- Write Behind Caching Pattern：可以将多次对数据库的写操作合并为一次，但是可能会丢失数据，维护任务较为复杂，并且一致性不能及时保证。\n\n综上，最终方案使用方案一：**Cache Aside Pattern！**<br />![13.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_85f2044e27-13.png) <br />**采用方案一衍生的问题：**\n\n- 更新缓存时是更新缓存还是删除缓存？\n    - 更新缓存：每次更新数据库都更新缓存，无效写操作较多\n    - **删除缓存：** 更新数据库时让缓存失效，查询时再更新缓存 **√**\n- 如何保证缓存与数据库的操作的同时成功或失败？\n    - 对于单体系统，将缓存与数据库操作放在一个事务\n    - 对于分布式系统，利用TCC等分布式事务方案\n- 先操作缓存还是先操作数据库？\n    - 先删除缓存，再操作数据库\n    - **先操作数据库，再删除缓存 √**\n\n> 我们应当是先操作数据库，再删除缓存，原因在于，如果两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\n\n遇到线程安全问题时的“先删除缓存，再操作数据库”（导致将旧数据又写回缓存中）：<br />![14.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_88fd0c6a27-14.png) <br />遇到线程安全问题时的“先操作数据库，再删除缓存”：<br />![16.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_8db3c3a327-16.png) <br />所以最终的方案是：**先更新数据库，再删除缓存**。\n<a name=\"smvH7\"></a>\n\n### 实现商户缓存与数据库双写一致\n\n根据上述分析，最终我们选择**在查询缓存时**，如果缓存中没有数据，则查询数据库，并设置过期时间作为超时剔除方案兜底。**更新缓存时**，先删除数据库再删除缓存。\n<a name=\"hgcFv\"></a>\n\n#### 添加缓存时设置过期时间\n\n```java\n@Override\npublic Result queryById(Long id) {\n    // 先从Redis中查，这里的常量值是固定的前缀 + 店铺id\n    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);\n    // 如果不为空（查询到了），则转为Shop类型直接返回\n    if (StrUtil.isNotBlank(shopJson)) {\n        Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n        return Result.ok(shop);\n    }\n    // 否则去数据库中查\n    Shop shop = getById(id);\n    if (shop == null) {\n        return Result.fail(\"店铺不存在！\");\n    }\n    // 查到了则转为json字符串\n    String jsonStr = JSONUtil.toJsonStr(shop);\n    // 并存入redis，设置TTL\n    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr,CACHE_SHOP_TTL, TimeUnit.MINUTES);\n    // 最终把查询到的商户信息返回给前端\n    return Result.ok(shop);\n}\n```\n\n<a name=\"evZrU\"></a>\n\n#### 更新缓存时先修改数据库再删除缓存\n\n```java\n@Override\n@Transactional\npublic Result update(Shop shop) {\n    // 判空\n    if (shop.getId() == null) {\n        return Result.fail(\"店铺id不能为空！！\");\n    }\n    // 先修改数据库\n    updateById(shop);\n    // 再删除缓存\n    stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());\n    return Result.ok();\n}\n```\n\n<a name=\"EBbDL\"></a>\n\n### 缓存穿透问题解决方案及实现\n\n<a name=\"RS8FD\"></a>\n\n#### 缓存穿透及解决方案\n\n**缓存穿透 ：**缓存穿透是指客户端请求的数据在**缓存中和数据库中都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。<br />**常见解决方案：**\n\n- 缓存空对象：实现简单，维护方便。但是会有额外的内存消耗，可能会造成短期的数据不一致。\n- 布隆过滤：内存占用少，没有多余的key。但是实现较为复杂，存在误判可能。\n- 增强id的复杂度，避免被猜测id规律\n- 做好数据的基础格式校验\n- 加强用户权限校验\n- 做好热点参数的限流\n\n**缓存空对象的思路分析：** 当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了。<br />**布隆过滤：** 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在（多个独立的哈希函数同时校验），如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中。假设布隆过滤器判断这个数据不存在，则直接返回。这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突。<br />![17.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_900f701527-17.png)\n<a name=\"Vfeb4\"></a>\n\n#### 编码解决缓存穿透\n\n在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404，这样会存在缓存穿透问题。\n\n```java\n@Override\npublic Result queryById(Long id) {\n    // 先从Redis中查，这里的常量值是固定的前缀 + 店铺id\n    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);\n    // 如果不为空（查询到了），则转为Shop类型直接返回\n    if (StrUtil.isNotBlank(shopJson)) {\n        Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n        return Result.ok(shop);\n    }\n    // 否则去数据库中查\n    Shop shop = getById(id);\n    // 查不到返回一个错误信息或者返回空都可以，根据自己的需求来\n    if (shop == null) {\n        return Result.fail(\"店铺不存在！！\");\n    }\n    // 查到了则转为json字符串\n    String jsonStr = JSONUtil.toJsonStr(shop);\n    // 并存入redis，设置TTL\n    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr,CACHE_SHOP_TTL, TimeUnit.MINUTES);\n    // 最终把查询到的商户信息返回给前端\n    return Result.ok(shop);\n}\n```\n\n**优化逻辑：** 如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。<br />![18.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_928f870c27-18.png)\n\n```java\n@Override\npublic Result queryById(Long id) {\n    // 先从Redis中查，这里的常量值是固定的前缀 + 店铺id\n    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);\n    // 如果不为空（查询到了），则转为Shop类型直接返回\n    if (StrUtil.isNotBlank(shopJson)) {\n        Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n        return Result.ok(shop);\n    }\n    // 如果查询到的是空字符串，则说明是我们缓存的空数据\n    if (shopjson != null) {\n        return Result.fail(\"店铺不存在！！\");\n    }\n    // 否则去数据库中查\n    Shop shop = getById(id);\n    // 查不到，则将空字符串写入Redis\n    if (shop == null) {\n        // 这里的常量值是2分钟\n        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n        return Result.fail(\"店铺不存在！\");\n    }\n    // 查到了则转为json字符串\n    String jsonStr = JSONUtil.toJsonStr(shop);\n    // 并存入redis，设置TTL\n    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);\n    // 最终把查询到的商户信息返回给前端\n    return Result.ok(shop);\n}\n```\n\n<a name=\"ZP9Ku\"></a>\n\n### 缓存雪崩问题解决方案\n\n**缓存雪崩：**缓存雪崩是指在**同一时段**大量的缓存key**同时失效**或者**Redis服务宕机**，导致大量请求到达数据库，带来巨大压力。<br />![19.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_9509c7b727-19.png) <br />**常见解决方案：**\n\n- 给不同的Key的TTL添加随机值（针对数据同时失效）；\n- 利用Redis集群提高服务的可用性（针对Redis宕机，使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。）；\n- 给缓存业务添加降级限流策略（主动限流保全数据库）；\n- 给业务添加多级缓存（增加缓存高可用，浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库）。\n  <a name=\"CeHTm\"></a>\n\n### 缓存击穿问题解决方案及实现\n\n<a name=\"pWInW\"></a>\n\n#### 缓存击穿问题分析\n\n**缓存击穿：**缓存击穿也叫**热点Key问题**，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击。<br />**常见解决方案：**\n\n- 互斥锁\n- 逻辑过期\n\n**逻辑分析：** 假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了。但是，假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大。<br />!![20.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_986f821f27-20.png) <br />**方案一：互斥锁分析：**\n\n- 利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题。\n- 假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\n\n![21.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_9c0717f827-21.png) <br />**方案二：逻辑过期分析：**\n\n- 我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案。\n- 我们把过期时间设置在redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\n- 这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是**脏数据**。\n\n![22.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_9e62a3c227-22.png) <br />**对比互斥锁与逻辑删除：**\n\n- **互斥锁方案：** 由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响。\n- **逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦。\n\n![23.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_a201856827-23.png)\n<a name=\"uAmX7\"></a>\n\n#### 利用互斥锁解决缓存击穿问题\n\n**核心思路：** 相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。<br />![24.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_a4978e1427-24.png) <br />**操作锁的代码：**<br />利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。\n\n```java\n// 获取锁\nprivate boolean tryLock(String key) {\n    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);\n    return BooleanUtil.isTrue(flag);\n}\n\n// 释放锁\nprivate void unlock(String key) {\n    stringRedisTemplate.delete(key);\n}\n```\n\n**实际查询代码：**\n\n```java\n public Shop queryWithMutex(Long id)  {\n    String key = CACHE_SHOP_KEY + id;\n    // 1、从redis中查询商铺缓存\n    String shopJson = stringRedisTemplate.opsForValue().get(\"key\");\n    // 2、判断是否存在\n    if (StrUtil.isNotBlank(shopJson)) {\n        // 存在,直接返回\n        return JSONUtil.toBean(shopJson, Shop.class);\n    }\n    // 判断命中的值是否是空值\n    if (shopJson != null) {\n        // 返回一个错误信息\n        return null;\n    }\n    // 4.实现缓存重构\n    // 4.1 获取互斥锁\n    String lockKey = \"lock:shop:\" + id;\n    Shop shop = null;\n    try {\n        boolean isLock = tryLock(lockKey);\n        // 4.2 判断否获取成功\n        if(!isLock) {\n            // 4.3 失败，则休眠重试\n            Thread.sleep(50);\n            return queryWithMutex(id);\n        }\n        // 4.4 成功，根据id查询数据库\n         shop = getById(id);\n        // 5.不存在，返回错误\n        if(shop == null) {\n             // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key,\"\",CACHE_NULL_TTL,TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.写入redis\n        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);\n\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n    finally {\n        // 7.释放互斥锁\n        unlock(lockKey);\n    }\n    return shop;\n}\n```\n\n<a name=\"YrlYl\"></a>\n\n#### 利用逻辑过期解决缓存击穿\n\n**核心思路：** 当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。<br />![25.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_a6eb26d327-25.png) <br />**实现步骤：**\n\n- 封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改（或者继承）原来的实体类，要么新建一个类包含原有的数据和过期时间。\n\n```java\n// 这里我们选择新建一个实体类，包含原有数据(Object)和过期时间，这样对原有的代码没有侵入性\n@Data\npublic class RedisData {\n    private LocalDateTime expireTime;\n    private Object data;\n}\n```\n\n- 利用逻辑过期实现解决缓存击穿\n\n```java\n// 这里需要声明一个线程池，因为下面我们需要新建一个线程来完成重构缓存\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);\n\n@Override\npublic Shop queryWithLogicalExpire(Long id) {\n    // 1. 从redis中查询商铺缓存\n    String json = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);\n    // 2. 如果未命中，则返回空\n    if (StrUtil.isBlank(json)) {\n        return null;\n    }\n    // 3. 命中，将json反序列化为对象\n    RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n    // 3.1 将data转为Shop对象\n    JSONObject shopJson = (JSONObject) redisData.getData();\n    Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n    // 3.2 获取过期时间\n    LocalDateTime expireTime = redisData.getExpireTime();\n    // 4. 判断是否过期\n    if (LocalDateTime.now().isBefore(time)) {\n        // 5. 未过期，直接返回商铺信息\n        return shop;\n    }\n    // 6. 过期，尝试获取互斥锁\n    boolean flag = tryLock(LOCK_SHOP_KEY + id);\n    // 7. 获取到了锁\n    if (flag) {\n        // 8. 开启独立线程\n        CACHE_REBUILD_EXECUTOR.submit(() -> {\n            try {\n                this.saveShop2Redis(id, LOCK_SHOP_TTL);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            } finally {\n                unlock(LOCK_SHOP_KEY + id);\n            }\n        });\n        // 9. 直接返回商铺信息\n        return shop;\n    }\n    // 10. 未获取到锁，直接返回商铺信息\n    return shop;\n}\n```\n\n<a name=\"hhwVD\"></a>\n\n### 封装Redis工具类\n\n<a name=\"rPmUo\"></a>\n\n#### 工具类的各方法说明\n\n本节将基于StringRedisTemplate封装一个缓存工具类，该工具类的方法如下：\n\n- **方法1：** 将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间\n\n```java\npublic void set(String key, Object value, Long time, TimeUnit timeUnit) {\n    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);\n}\n```\n\n- **方法2：** 将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间（用于处理缓存击穿问题）\n\n```java\npublic void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {\n    // 设置逻辑过期\n    RedisData redisData = new RedisData();\n    redisData.setData(value);\n    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));\n    // 写入Redis\n    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));\n}\n```\n\n- **方法3：** 根据指定的Key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\n\n> **注意：**\n> （1）通用方法查询的就不一定是shop了，所以这里使用泛型代替，同时id也需要使用泛型。\n> （2）key的前缀会随着业务不同而变更，所以需要作为参数传入\n> （3）如果通过传入的id在redis中查询不到是需要去数据库查询的，所以需要传入查询数据库的逻辑函数\n> （4）对于TTL的设置需要传入时间长度和时间单位\n\n```java\npublic <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, \n                                     Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n    String key = keyPrefix + id;\n    // 1.从redis查询商铺缓存\n    String json = stringRedisTemplate.opsForValue().get(key);\n    // 2.判断是否存在\n    if (StrUtil.isNotBlank(json)) {\n        // 3.存在，直接返回\n        return JSONUtil.toBean(json, type);\n    }\n    // 判断命中的是否是空值\n    if (json != null) {\n        // 返回一个错误信息\n        return null;\n    }\n\n    // 4.不存在，根据id查询数据库\n    R r = dbFallback.apply(id);\n    // 5.不存在，返回错误\n    if (r == null) {\n        // 将空值写入redis\n        stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n        // 返回错误信息\n        return null;\n    }\n    // 6.存在，写入redis\n    this.set(key, r, time, unit);\n    return r;\n}\n```\n\n- **方法4：** 根据指定的Key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\n\n```java\npublic <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Class<R> type, \n                                        Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n    String key = keyPrefix + id;\n    // 1.从redis查询商铺缓存\n    String json = stringRedisTemplate.opsForValue().get(key);\n    // 2.判断是否存在\n    if (StrUtil.isBlank(json)) {\n        // 3.存在，直接返回\n        return null;\n    }\n    // 4.命中，需要先把json反序列化为对象\n    RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n    R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n    LocalDateTime expireTime = redisData.getExpireTime();\n    // 5.判断是否过期\n    if(expireTime.isAfter(LocalDateTime.now())) {\n        // 5.1.未过期，直接返回店铺信息\n        return r;\n    }\n    // 5.2.已过期，需要缓存重建\n    // 6.缓存重建\n    // 6.1.获取互斥锁\n    String lockKey = LOCK_SHOP_KEY + id;\n    boolean isLock = tryLock(lockKey);\n    // 6.2.判断是否获取锁成功\n    if (isLock) {\n        // 6.3.成功，开启独立线程，实现缓存重建\n        CACHE_REBUILD_EXECUTOR.submit(() -> {\n            try {\n                // 查询数据库\n                R newR = dbFallback.apply(id);\n                // 重建缓存\n                this.setWithLogicalExpire(key, newR, time, unit);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }finally {\n                // 释放锁\n                unlock(lockKey);\n            }\n        });\n    }\n    // 6.4.返回过期的商铺信息\n    return r;\n}\n```\n\n- **方法5：** 根据指定的Key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题\n\n```java\npublic <R, ID> R queryWithMutex(String keyPrefix, ID id, Class<R> type, \n                                Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n    String key = keyPrefix + id;\n    // 1.从redis查询商铺缓存\n    String shopJson = stringRedisTemplate.opsForValue().get(key);\n    // 2.判断是否存在\n    if (StrUtil.isNotBlank(shopJson)) {\n        // 3.存在，直接返回\n        return JSONUtil.toBean(shopJson, type);\n    }\n    // 判断命中的是否是空值\n    if (shopJson != null) {\n        // 返回一个错误信息\n        return null;\n    }\n\n    // 4.实现缓存重建\n    // 4.1.获取互斥锁\n    String lockKey = LOCK_SHOP_KEY + id;\n    R r = null;\n    try {\n        boolean isLock = tryLock(lockKey);\n        // 4.2.判断是否获取成功\n        if (!isLock) {\n            // 4.3.获取锁失败，休眠并重试\n            Thread.sleep(50);\n            return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n        }\n        // 4.4.获取锁成功，根据id查询数据库\n        r = dbFallback.apply(id);\n        // 5.不存在，返回错误\n        if (r == null) {\n            // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.存在，写入redis\n        this.set(key, r, time, unit);\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }finally {\n        // 7.释放锁\n        unlock(lockKey);\n    }\n    // 8.返回\n    return r;\n}\n```\n\n<a name=\"IvrPv\"></a>\n\n#### 工具类完整代码\n\n```java\n@Slf4j\n@Component\npublic class CacheClient {\n\n    private final StringRedisTemplate stringRedisTemplate;\n\n    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);\n\n    public CacheClient(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    private boolean tryLock(String key) {\n        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);\n        return BooleanUtil.isTrue(flag);\n    }\n\n    private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n    }\n\n    public void set(String key, Object value, Long time, TimeUnit timeUnit) {\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);\n    }\n\n    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {\n    // 设置逻辑过期\n        RedisData redisData = new RedisData();\n        redisData.setData(value);\n        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));\n        // 写入Redis\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));\n    }\n\n    public <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, \n                                     Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(json)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(json, type);\n        }\n        // 判断命中的是否是空值\n        if (json != null) {\n            // 返回一个错误信息\n            return null;\n        }\n    \n        // 4.不存在，根据id查询数据库\n        R r = dbFallback.apply(id);\n        // 5.不存在，返回错误\n        if (r == null) {\n            // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.存在，写入redis\n        this.set(key, r, time, unit);\n        return r;\n    }\n\n    public <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Class<R> type, \n                                            Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isBlank(json)) {\n            // 3.存在，直接返回\n            return null;\n        }\n        // 4.命中，需要先把json反序列化为对象\n        RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        // 5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return r;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock) {\n            // 6.3.成功，开启独立线程，实现缓存重建\n            CACHE_REBUILD_EXECUTOR.submit(() -> {\n                try {\n                    // 查询数据库\n                    R newR = dbFallback.apply(id);\n                    // 重建缓存\n                    this.setWithLogicalExpire(key, newR, time, unit);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }finally {\n                    // 释放锁\n                    unlock(lockKey);\n                }\n            });\n        }\n        // 6.4.返回过期的商铺信息\n        return r;\n    }\n\n    public <R, ID> R queryWithMutex(String keyPrefix, ID id, Class<R> type, \n                                Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(shopJson, type);\n        }\n        // 判断命中的是否是空值\n        if (shopJson != null) {\n            // 返回一个错误信息\n            return null;\n        }\n    \n        // 4.实现缓存重建\n        // 4.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        R r = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            // 4.2.判断是否获取成功\n            if (!isLock) {\n                // 4.3.获取锁失败，休眠并重试\n                Thread.sleep(50);\n                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n            }\n            // 4.4.获取锁成功，根据id查询数据库\n            r = dbFallback.apply(id);\n            // 5.不存在，返回错误\n            if (r == null) {\n                // 将空值写入redis\n                stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n                // 返回错误信息\n                return null;\n            }\n            // 6.存在，写入redis\n            this.set(key, r, time, unit);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            // 7.释放锁\n            unlock(lockKey);\n        }\n        // 8.返回\n        return r;\n    }\n}\n```\n\n<a name=\"xXz83\"></a>\n\n## 优惠券秒杀\n\n<a name=\"p06OE\"></a>\n\n### Redis实现全局唯一ID\n\n<a name=\"s9qYz\"></a>\n\n#### 全局唯一ID的意义\n\n- 需要对订单做唯一标识（id）\n- id 的规律性不能太明显\n- 不能受到表单数量的限制（可能会进行分库分表）\n  <a name=\"bGmzZ\"></a>\n\n#### 全局唯一生成器需满足的特征\n\n- 唯一性\n- 安全性\n- 递增性\n- 高可用\n- 高性能\n  <a name=\"klFjG\"></a>\n\n#### 全局唯一ID的实现\n\n为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息。<br />![26.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_aa4cd5a927-26.png)\n\n```java\n@Component\npublic class RedisIdWorker {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    // 设置起始时间，我这里设定的是2022.01.01 00:00:00\n    public static final Long BEGIN_TIMESTAMP = 1640995200L;\n    // 序列号长度\n    public static final Long COUNT_BIT = 32L;\n\n    public long nextId(String keyPrefix) {\n        // 1. 生成时间戳\n        LocalDateTime now = LocalDateTime.now();\n        long currentSecond = now.toEpochSecond(ZoneOffset.UTC);\n        long timeStamp = currentSecond - BEGIN_TIMESTAMP;\n        // 2. 生成序列号\n        String date = now.format(DateTimeFormatter.ofPattern(\"yyyy:MM:dd\"));\n        long count = stringRedisTemplate.opsForValue().increment(\"inc:\"+keyPrefix+\":\"+date);\n        // 3. 拼接并返回，简单位运算\n        return timeStamp << COUNT_BIT | count;\n    }\n}\n```\n\n<a name=\"hnA5h\"></a>\n\n### 实现秒杀下单基本流程\n\n首先，根据分析，秒杀的下单流程如下：<br />![27.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_ac59d1a427-27.png) <br />**Controller：**\n\n```java\n@RestController\n@RequestMapping(\"/voucher-order\")\npublic class VoucherOrderController {\n    @Autowired\n    private IVoucherOrderService voucherOrderService;\n    @PostMapping(\"/seckill/{id}\")\n    public Result seckillVoucher(@PathVariable(\"id\") Long voucherId) {\n        return voucherOrderService.seckillVoucher(voucherId);\n    }\n}\n```\n\n**Service：**\n\n```java\npublic interface IVoucherOrderService extends IService<VoucherOrder> {\n    Result seckillVoucher(Long voucherId);\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Autowired\nprivate ISeckillVoucherService seckillVoucherService;\n\n@Autowired\nprivate RedisIdWorker redisIdWorker;\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n    // 5. 扣减库存\n    boolean success = seckillVoucherService.update()\n        .setSql(\"stock = stock - 1\")\n        .eq(\"voucher_id\",voucherId)\n        .update();\n    if (!success) {\n        return Result.fail(\"库存不足\");\n    }\n    // 6. 创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 6.1 设置订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    // 6.2 设置用户id\n    Long id = UserHolder.getUser().getId();\n    // 6.3 设置代金券id\n    voucherOrder.setVoucherId(voucherId);\n    voucherOrder.setId(orderId);\n    voucherOrder.setUserId(id);\n    // 7. 将订单数据保存到表中\n    save(voucherOrder);\n    // 8. 返回订单id\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"N2Lom\"></a>\n\n### 解决超卖问题\n\n<a name=\"C12nl\"></a>\n\n#### 超卖问题分析\n\n在完成秒杀基本下单流程后，我们发现，在测试的时候会产生线程安全问题：\n\n- 线程1查询，发现商品数量大于0（商品数量为1）\n- 线程2查询，发现商品数量大于0（商品数量为1）\n- 线程1创建订单，并扣减库存\n- 线程1创建订单，并扣减库存（此时库存已经为0，但仍然创建了订单，并扣减库存，导致超卖问题）\n\n![28.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_afb7ccee27-28.png)\n<a name=\"eaXCP\"></a>\n\n#### 超卖问题解决思路\n\n超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：\n\n1. **悲观锁**\n\n- 悲观锁认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行\n- 例如Synchronized、Lock等，都是悲观锁\n\n2. **乐观锁**\n\n- 乐观锁认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改\n    - 如果没有修改，则认为自己是安全的，自己才可以更新数据\n    - 如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常\n\n**悲观锁：** 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁等等。<br />**乐观锁：** 乐观锁则是增加版本号字段，每次操作数据会对版本号+1，提交操作时会校验当前版本号是否与刚才查询的版本号一致，如果不一致则说明已经被修改过。\n\n> 此处采用针对当前业务优化的乐观锁解决超卖问题。我们在实现的时候并不需要增加一个版本号字段，而是利用库存是否发生变化进行版本的判断（更进一步可以只是校验库存是否大于0）\n\n**代码实现：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n    // 5. 扣减库存\n    boolean success = seckillVoucherService.update()\n            .setSql(\"stock = stock - 1\")\n            .eq(\"voucher_id\", voucherId)\n            .gt(\"stock\", 0)\n            .update();\n    if (!success) {\n        return Result.fail(\"库存不足\");\n    }\n    // 6. 创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 6.1 设置订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    // 6.2 设置用户id\n    Long id = UserHolder.getUser().getId();\n    // 6.3 设置代金券id\n    voucherOrder.setVoucherId(voucherId);\n    voucherOrder.setId(orderId);\n    voucherOrder.setUserId(id);\n    // 7. 将订单数据保存到表中\n    save(voucherOrder);\n    // 8. 返回订单id\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"Xc5L9\"></a>\n\n### 一人一单限制\n\n<a name=\"apNlJ\"></a>\n\n#### 一人一单问题分析\n\n在优惠券场景当中，往往会有同一个用户对于同一种优惠券只能购买一单的需求。<br />**逻辑分析：**<br />![29.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_b2423a1527-29.png)\n<a name=\"f058H\"></a>\n\n#### 初步代码实现\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n\n    // 新增一人一单逻辑\n    Long userId = UserHolder.getUser().getId();\n    int count = query().eq(\"voucher_id\", voucherId).eq(\"user_id\", userId).count();\n    if (count > 0) {\n        return Result.fail(\"你已经抢过优惠券了哦\");\n    }\n\n    // 5. 扣减库存\n    boolean success = seckillVoucherService.update()\n            .setSql(\"stock = stock - 1\")\n            .eq(\"voucher_id\", voucherId)\n            .gt(\"stock\", 0)\n            .update();\n    if (!success) {\n        return Result.fail(\"库存不足\");\n    }\n    // 6. 创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 6.1 设置订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    // 6.2 设置用户id\n    Long id = UserHolder.getUser().getId();\n    // 6.3 设置代金券id\n    voucherOrder.setVoucherId(voucherId);\n    voucherOrder.setId(orderId);\n    voucherOrder.setUserId(id);\n    // 7. 将订单数据保存到表中\n    save(voucherOrder);\n    // 8. 返回订单id\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"yiWt2\"></a>\n\n#### 初步代码问题分析与二次代码实现\n\n与超卖问题类似，一人一单也存在着同样的线程安全问题（当一个用户同时使用多个设备秒杀优惠券时）：\n\n- 线程1查询，发现当前用户未购买过该优惠券\n- 线程2查询，发现当前用户未购买过该优惠券\n- 线程1创建订单，并扣减库存\n- 线程2创建订单，并扣减库存（导致线程安全问题）\n\n于是乎，我们只能被迫进行加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作。<br />首先我们将创建订单部分抽取出来，并加上**synchronized 锁**，同时加上事务@Transactional。\n\n```java\n@Transactional\npublic synchronized Result createVoucherOrder(Long voucherId) {\n\n\tLong userId = UserHolder.getUser().getId();\n         // 5.1.查询订单\n        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n        // 5.2.判断是否存在\n        if (count > 0) {\n            // 用户已经购买过了\n            return Result.fail(\"用户已经购买过一次！\");\n        }\n\n        // 6.扣减库存\n        boolean success = seckillVoucherService.update()\n                .setSql(\"stock = stock - 1\") // set stock = stock - 1\n                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock > 0\n                .update();\n        if (!success) {\n            // 扣减失败\n            return Result.fail(\"库存不足！\");\n        }\n\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId(\"order\");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(userId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        save(voucherOrder);\n\n        // 7.返回订单id\n        return Result.ok(orderId);\n}\n```\n\n<a name=\"ElomY\"></a>\n\n#### 二次代码问题分析与三次代码实现\n\n我们发现，二次代码中加锁的粒度太大了（在使用锁过程中，控制锁粒度 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住）。<br />在当前业务中，我们只需要对同一个用户加锁即可，于是有了版本3。\n\n```java\n@Transactional\npublic  Result createVoucherOrder(Long voucherId) {\n\tLong userId = UserHolder.getUser().getId();\n    // intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new 出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法\n\tsynchronized(userId.toString().intern()) {\n         // 5.1.查询订单\n        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n        // 5.2.判断是否存在\n        if (count > 0) {\n            // 用户已经购买过了\n            return Result.fail(\"用户已经购买过一次！\");\n        }\n\n        // 6.扣减库存\n        boolean success = seckillVoucherService.update()\n                .setSql(\"stock = stock - 1\") // set stock = stock - 1\n                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock > 0\n                .update();\n        if (!success) {\n            // 扣减失败\n            return Result.fail(\"库存不足！\");\n        }\n\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId(\"order\");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(userId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        save(voucherOrder);\n\n        // 7.返回订单id\n        return Result.ok(orderId);\n    }\n}\n```\n\n<a name=\"vE7h3\"></a>\n\n#### 三次代码问题分析与最终版本代码实现\n\n在第三个版本中依然存在两个问题：\n\n- 问题1：当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放，导致并发问题再次出现\n- 问题2：但是如果将锁加在调用createVoucherOrder的地方（问题1的解决办法），我们的事务是无法正常生效的，因为我们调用这个函数其实是`this.`的方式调用的，想要事务生效，必须通过代理来进行调用。\n\n于是，我们这里可以将锁加在调用createVoucherOrder的地方，同时利用`AopContext.currentProxy()`来获取当前对象的代理对象，然后再用代理对象调用方法\n\n> 需要在接口中创建createVoucherOrder方法。\n> 需要引入aspectjweaver依赖\n> 在启动类上加上@EnableAspectJAutoProxy(exposeProxy = true)注解\n\n**最终代码实现：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n\n    Long userId = UserHolder.getUser().getId();\n\n    // 在调用处加锁，同时利用代理使事务生效\n    synchronized (userId.toString().intern()) {\n        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();\n        return proxy.createVoucherOrder(voucherId);\n    }\n}\n\n@Transactional\npublic  Result createVoucherOrder(Long voucherId) {\n    // 5.1.查询订单\n    int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n    // 5.2.判断是否存在\n    if (count > 0) {\n        // 用户已经购买过了\n        return Result.fail(\"用户已经购买过一次！\");\n    }\n\n    // 6.扣减库存\n    boolean success = seckillVoucherService.update()\n            .setSql(\"stock = stock - 1\") // set stock = stock - 1\n            .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock > 0\n            .update();\n    if (!success) {\n        // 扣减失败\n        return Result.fail(\"库存不足！\");\n    }\n\n    // 7.创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 7.1.订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    voucherOrder.setId(orderId);\n    // 7.2.用户id\n    voucherOrder.setUserId(userId);\n    // 7.3.代金券id\n    voucherOrder.setVoucherId(voucherId);\n    save(voucherOrder);\n\n    // 7.返回订单id\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"Vost4\"></a>\n\n### 集群环境下的并发问题\n\n通过上面的一人一单限制，解决了在单台tomcat服务器上的并发问题，但是当我们对tomcat进行集群部署时，又会出现并发安全问题：\n\n- jvm1中的线程1获取锁成功\n- jvm1中的线程2获取锁失败（单台tomcat并发问题成功抗住）\n- jvm2中的线程1获取锁成功（**此时出现了集群环境下的并发安全问题**）\n- jvm2中的线程2获取锁失败\n\n![30.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_b6883d1c27-30.png) <br />那么，上面这个棘手的并发安全问题该如何解决呢？<br />**_这时候，就该分布式锁登场了！_**\n<a name=\"CUL1F\"></a>\n\n## 分布式锁\n\n<a name=\"kitAt\"></a>\n\n### 分布式锁的基本原理\n\n**分布式锁：**满足分布式系统或集群模式下多线程课件并且可以互斥的锁。<br />分布式锁的**核心思想**就是让大家共用同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。<br />![31.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_bc35e46a27-31.png) <br />**分布式锁应当满足如下条件：**\n\n- 可见性：多个线程都能看到相同的结果\n\n> 注意：这里说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思\n\n- 互斥：互斥是分布式锁的最基本条件，使得程序串行执行\n- 高可用：程序不易崩溃，时时刻刻都保证较高的可用性\n- 高性能：由于加锁本身就让性能降低，所以对于分布式锁需要他较高的加锁性能和释放锁性能\n- 安全性：安全也是程序中必不可少的一环\n\n**常见的分布式锁的实现：**\n\n- MySQL：MySQL本身就带有锁机制，但是由于MySQL的性能一般，所以采用分布式锁的情况下，使用MySQL作为分布式锁比较少见\n- Redis：Redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都是用Redis或者Zookeeper作为分布式锁，利用`SETNX`这个方法，如果插入Key成功，则表示获得到了锁，如果有人插入成功，那么其他人就回插入失败，无法获取到锁，利用这套逻辑完成`互斥`，从而实现分布式锁\n- Zookeeper：其实Zookeeper也是企业级开发中较好的一种实现分布式锁的方案，本文主要讲解Redis的实现\n\n![32.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_bfd27eef27-32.png)\n<a name=\"DmVJH\"></a>\n\n### Redis分布式锁实现的核心思路\n\n实现分布式锁时需要实现两个基本方法\n\n- 获取锁\n    - 互斥：确保只能有一个线程获取锁\n    - 非阻塞：尝试一次，成功返回true，失败返回false\n- 释放锁\n    - 手动释放\n    - 超时释放：获取锁的时候添加一个超时时间（作为兜底）\n\n**核心思路**：我们利用redis的`SETNX`方法，当有多个线程进入时，我们就利用该方法来获取锁。第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑。没有抢到锁（返回了0）的线程，等待一定时间后重试即可（对于当前业务，说明用户的当前操作不合法，直接返回失败即可）。<br />![33.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_c69db1e427-33.png)\n<a name=\"DaZYf\"></a>\n\n### 实现分布式锁\n\n<a name=\"F4Mxk\"></a>\n\n#### 创建锁的基本接口\n\n```java\npublic interface ILock {\n    /**\n     * 尝试获取锁\n     *\n     * @param timeoutSec 锁持有的超时时间，过期自动释放\n     * @return true表示获取锁成功，false表示获取锁失败\n     */\n    boolean tryLock(long timeoutSec);\n\n    /**\n     * 释放锁\n     */\n    void unlock();\n}\n```\n\n<a name=\"Ly616\"></a>\n\n#### 实现锁的基本接口\n\n```java\npublic class SimpleRedisLock implements ILock {\n    // 锁的前缀\n    private static final String KEY_PREFIX = \"lock:\";\n    // 具体业务名称，将前缀和业务名拼接之后当做Key\n    private String name;\n    // 这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入\n    private StringRedisTemplate stringRedisTemplate;\n\n    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {\n        this.name = name;\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    @Override\n    public boolean tryLock(long timeoutSec) {\n        // 获取线程标识\n        long threadId = Thread.currentThread().getId();\n        // 获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁\n        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + \"\", timeoutSec, TimeUnit.SECONDS);\n        // 自动拆箱可能会导致NPE问题，这样写更稳妥\n        return Boolean.TRUE.equals(success);\n    }\n\n    @Override\n    public void unlock() {\n        // 通过DEL来删除锁\n        stringRedisTemplate.delete(KEY_PREFIX + name);\n    }\n}\n```\n\n<a name=\"kEcW7\"></a>\n\n#### 基于分布式锁修改秒杀业务\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n    Long userId = UserHolder.getUser().getId();\n    // 创建锁对象\n    SimpleRedisLock redisLock = new SimpleRedisLock(\"order:\" + userId, stringRedisTemplate);\n    // 获取锁对象\n    boolean isLock = redisLock.tryLock(30);\n    // 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）\n    if (!isLock) {\n        return Result.fail(\"你已经抢过一张啦，留给别人吧！\");\n    }\n    try {\n        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();\n        return proxy.createVoucherOrder(voucherId);\n    } finally {\n        // 释放锁\n        redisLock.unlock();\n    }\n}\n```\n\n<a name=\"CHbb8\"></a>\n\n### Redis分布式锁错误释放问题\n\n<a name=\"zmUUX\"></a>\n\n#### Redis分布式锁的错误释放问题\n\n持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除。<br />![34.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_cbd1000527-34.png)\n<a name=\"Ak2Q5\"></a>\n\n#### Redis分布式锁的错误释放问题解决方案\n\n解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。<br />![35.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_d01613d827-35.png)\n<a name=\"Cajwm\"></a>\n\n#### 解决后重新模拟错误释放问题\n\n假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁。<br />![36.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_d414f28827-36.png)\n<a name=\"qimR5\"></a>\n\n#### 解决Redis分布式锁误删问题代码实现\n\n```java\n// 加锁\nprivate static final String ID_PREFIX = UUID.randomUUID().toString(true) + \"-\";\n@Override\npublic boolean tryLock(long timeoutSec) {\n   // 获取线程标示\n   String threadId = ID_PREFIX + Thread.currentThread().getId();\n   // 获取锁\n   Boolean success = stringRedisTemplate.opsForValue()\n                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);\n   return Boolean.TRUE.equals(success);\n}\n\n// 释放锁\npublic void unlock() {\n    // 获取线程标示\n    String threadId = ID_PREFIX + Thread.currentThread().getId();\n    // 获取锁中的标示\n    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);\n    // 判断标示是否一致\n    if(threadId.equals(id)) {\n        // 释放锁\n        stringRedisTemplate.delete(KEY_PREFIX + name);\n    }\n}\n```\n\n<a name=\"vagru\"></a>\n\n### 分布式锁的原子性问题\n\n<a name=\"g6zRK\"></a>\n\n#### 什么是分布式锁的原子性问题\n\n所谓分布式锁的原子性问题，就是在上面的误删问题的基础上，即使判断了是自己的线程标识，但是由于判断和释放锁的这两个步骤并不具有原子性，在一些极端情况，可能会在判断成功后，阻塞住了，然后被超时释放，结果这个锁被其他的线程获取，这时阻塞住的线程恢复后直接进行了锁的释放，又导致了误删问题。\n<a name=\"vmx7z\"></a>\n\n#### 利用Lua脚本解决分布式锁的原子性问题\n\n**Lua脚本：**\n\n- Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性\n- Lua是一种编程语言，其基本语法可在[菜鸟教程](https://www.runoob.com/lua/lua-tutorial.html)查看\n- 这里重点介绍Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现拿锁，判断标识，删锁是一个原子性动作了\n\n**Redis调用Lua脚本：**\n\n- Lua脚本格式\n\n```lua\nredis.call('命令名称', 'key', '其它参数', ...)\n```\n\n- 示例\n\n```lua\n-- 先执行 set name jack\nredis.call('set', 'name', 'Rose')\n-- 再执行 get name\nlocal name = redis.call('get', 'name')\n-- 返回\nreturn name\n```\n\n- Redis调用Lua脚本\n\n![37.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_d982af8327-37.png) <br />**Lua脚本实现判断标识与释放锁：**\n\n```lua\n-- 这里的KEYS[1]就是传入锁的key\n-- 这里的ARGV[1]就是线程标识\n-- 比较锁中的线程标识与线程标识是否一致\nif (redis.call('get', KEYS[1]) == ARGV[1]) then\n    -- 一致则释放锁\n    return redis.call('del', KEYS[1])\nend\nreturn 0\n```\n\n<a name=\"o30fA\"></a>\n\n#### 利用Java调用Lua脚本解决分布式锁的原子性问题\n\n在RedisTemplate中，可以利用`excute`方法执行`Lua`脚本\n\n```java\npublic <T> T execute(RedisScript<T> script, List<K> keys, Object... args) {\n    return this.scriptExecutor.execute(script, keys, args);\n}\n```\n\n**代码实现：**\n\n```java\nprivate static final DefaultRedisScript<Long> UNLOCK_SCRIPT;\n\nstatic {\n    UNLOCK_SCRIPT = new DefaultRedisScript();\n    UNLOCK_SCRIPT.setLocation(new ClassPathResource(\"unlock.lua\"));\n    UNLOCK_SCRIPT.setResultType(Long.class);\n}\n\n@Override\npublic void unlock() {\n    stringRedisTemplate.execute(UNLOCK_SCRIPT,\n            Collections.singletonList(KEY_PREFIX + name),\n            ID_PREFIX + Thread.currentThread().getId());\n}\n```\n\n<a name=\"wHOSL\"></a>\n\n### 基于Redis实现分布式锁的不足\n\n基于Redis中的`setnx`命令实现分布式锁具有以下几个问题：<br />![38.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_de66d9e027-38.png) <br />如果没有以上几种需求，基于Redis实现的分布式锁是完全没有问题的，但是，如果业务中的确有以上需求，那么该怎么解决呢？<br />**_于是，强大的Redisson诞生了！_**<br />在以后需要使用分布式锁的时候，直接使用Redisson的分布式解决方案即可。\n<a name=\"LKg9j\"></a>\n\n## 分布式锁-Redisson\n\n<a name=\"zszOv\"></a>\n\n### Redisson基础\n\nRedisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。<br />**Redisson实现了分布式锁的各种功能：**\n\n- 可重入锁(Reentrant Lock)\n- 公平锁(Fair Lock)\n- 联锁(MultiLock)\n- 红锁(RedLock)\n- 读写锁(ReadWriteLock)\n- 信号量(Semaphore)\n- 可过期性信号量(PermitExpirableSemaphore)\n- 闭锁(CountDownLatch)\n  <a name=\"HwSXo\"></a>\n\n### 项目引入Redisson\n\n- 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.13.6</version>\n</dependency>\n```\n\n- 配置`RedissonConfig`类\n\n```java\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class RedissonConfig {\n    @Bean\n    public RedissonClient redissonClient() {\n        Config config = new Config();\n        config.useSingleServer()\n            .setAddress(\"redis:// 127.0.0.1:6379\")\n            .setPassword(\"123456\");\n        return Redisson.create(config);\n    }\n}\n```\n\n- 使用Redisson的分布式锁修改秒杀业务\n\n```java\n@Resource\nprivate RedissonClient redissonClient;\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    LambdaQueryWrapper<SeckillVoucher> queryWrapper = new LambdaQueryWrapper<>();\n    // 1. 查询优惠券\n    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);\n    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);\n    // 2. 判断秒杀时间是否开始\n    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) {\n        return Result.fail(\"秒杀还未开始，请耐心等待\");\n    }\n    // 3. 判断秒杀时间是否结束\n    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) {\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4. 判断库存是否充足\n    if (seckillVoucher.getStock() < 1) {\n        return Result.fail(\"优惠券已被抢光了哦，下次记得手速快点\");\n    }\n    Long userId = UserHolder.getUser().getId();\n    RLock redisLock = redissonClient.getLock(\"order:\" + userId);\n    boolean isLock = redisLock.tryLock();\n    if (!isLock) {\n        return Result.fail(\"不允许抢多张优惠券\");\n    }\n    try {\n        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();\n        return proxy.createVoucherOrder(voucherId);\n    } finally {\n        redisLock.unlock();\n    }\n}\n```\n\n<a name=\"BOYTV\"></a>\n\n### Redisson实现可重入锁原理\n\n参考JDK实现锁的原理，Redisson实现可重入也是基于计数机制，即有人获取当前锁时，`count = 1`，再次获取该锁时，`count ++`，当释放该锁时，`count --`，直到`count == 0`时表示当前锁未被持有。\n\n> 能再次获取锁的必要条件是处于同一线程。\n\nRedisson实现计数机制使用的是Redis的Hash结构，用外层的“大”key表示当前锁是否被持有，用Hash结构的“小”Key来记录被哪个线程持有。<br />![39.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_e089985f27-39.png) <br />**尝试自己实现获取锁和释放锁：**\n\n> 由于需要保证原子性，所以也需要使用Lua实现。\n\n- 获取锁\n\n```lua\nlocal key = KEYS[1]; -- 锁的key\nlocal threadId = ARGV[1]; -- 线程唯一标识\nlocal releaseTime = ARGV[2]; -- 锁的自动释放时间\n-- 锁不存在\nif (redis.call('exists', key) == 0) then\n    -- 获取锁并添加线程标识，state设为1\n    redis.call('hset', key, threadId, '1');\n    -- 设置锁有效期\n    redis.call('expire', key, releaseTime);\n    return 1; -- 返回结果\nend;\n-- 锁存在，判断threadId是否为自己\nif (redis.call('hexists', key, threadId) == 1) then\n    -- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长\n    redis.call('hincrby', key, thread, 1);\n    -- 设置锁的有效期\n    redis.call('expire', key, releaseTime);\n    return 1; -- 返回结果\nend;\nreturn 0; -- 代码走到这里，说明获取锁的不是自己，获取锁失败\n```\n\n- 释放锁\n\n```lua\nlocal key = KEYS[1];\nlocal threadId = ARGV[1];\nlocal releaseTime = ARGV[2];\n-- 如果锁不是自己的\nif (redis.call('HEXISTS', key, threadId) == 0) then\n    return nil; -- 直接返回\nend;\n-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1\nlocal count = redis.call('hincrby', key, threadId, -1);\n-- 判断重入次数为多少\nif (count > 0) then\n    -- 大于0，重置有效期\n    redis.call('expire', key, releaseTime);\n    return nil;\nelse\n    -- 否则直接释放锁\n    redis.call('del', key);\n    return nil;\nend;\n```\n\n**查看Redisson实现获取锁与释放锁的源码：**\n\n- 获取锁\n\n```java\n<T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {\n    this.internalLockLeaseTime = unit.toMillis(leaseTime);\n    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, command, \n                                \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                                    \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                                    \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                                    \"return nil; \" +\n                                \"end; \" +\n                                \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n                                    \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                                    \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                                    \"return nil; \" +\n                                 \"end; \" +\n                                \"return redis.call('pttl', KEYS[1]);\", \n                                Collections.singletonList(this.getName()), \n                                this.internalLockLeaseTime, \n                                this.getLockName(threadId));\n}\n```\n\n- 释放锁\n\n```java\nprotected RFuture<Boolean> unlockInnerAsync(long threadId) {\n    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, \n                                \"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \" +\n                                    \"return nil;\" +\n                                \"end; \" +\n                                \"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \" +\n                                \"if (counter > 0) then \" +\n                                    \"redis.call('pexpire', KEYS[1], ARGV[2]); \" +\n                                    \"return 0; \" +\n                                \"else \" +\n                                    \"redis.call('del', KEYS[1]); \" +\n                                    \"redis.call('publish', KEYS[2], ARGV[1]); return 1; \" +\n                                \"end; \" +\n                                \"return nil;\", \n                                Arrays.asList(this.getName(), \n                                this.getChannelName()), \n                                LockPubSub.UNLOCK_MESSAGE, \n                                this.internalLockLeaseTime, \n                                this.getLockName(threadId));\n}\n```\n\n> 我们发现，源码实现和我们的预期几乎一样。\n\n<a name=\"BxTHZ\"></a>\n\n### Redisson锁重试与WatchDog机制\n\n通过对源码的解读，我们发现Redisson锁重试的实现如下图所示：<br />![40.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_e4d195d827-40.png)\n<a name=\"PDMsd\"></a>\n\n### Redisson的MultiLock锁实现原理\n\n<a name=\"GdtjL\"></a>\n\n#### 原理分析\n\n为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例。<br />此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。<br />![41.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_eaf3f43a27-41.png)   <br />为了解决这个问题，Redisson提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功。<br />假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。<br />![42.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_ef8ba45027-42.png) <br />**Redisson的MultiLock锁源码分析图：**<br />![43.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_f2916f4127-43.png)\n<a name=\"VCGh5\"></a>\n\n#### 实践\n\n- 使用虚拟机额外搭建两个Redis节点，然后重新配置`RedissonConfig`类\n\n```java\n@Configuration\npublic class RedissonConfig {\n    @Bean\n    public RedissonClient redissonClient() {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis:// 192.168.137.130:6379\")\n                .setPassword(\"root\");\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public RedissonClient redissonClient2() {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis:// 92.168.137.131:6379\")\n                .setPassword(\"root\");\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public RedissonClient redissonClient3() {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis:// 92.168.137.132:6379\")\n                .setPassword(\"root\");\n        return Redisson.create(config);\n    }\n}\n```\n\n- 要使用联锁，我们需要注入三个`RedissonClient`对象\n\n```java\n@Resource\nprivate RedissonClient redissonClient;\n@Resource\nprivate RedissonClient redissonClient2;\n@Resource\nprivate RedissonClient redissonClient3;\n\nprivate RLock lock;\n\n@BeforeEach\nvoid setUp() {\n    RLock lock1 = redissonClient.getLock(\"lock\");\n    RLock lock2 = redissonClient2.getLock(\"lock\");\n    RLock lock3 = redissonClient3.getLock(\"lock\");\n    lock = redissonClient.getMultiLock(lock1, lock2, lock3);\n}\n\n@Test\nvoid method1() {\n    boolean success = lock.tryLock();\n    redissonClient.getMultiLock();\n    if (!success) {\n        log.error(\"获取锁失败，1\");\n        return;\n    }\n    try {\n        log.info(\"获取锁成功\");\n        method2();\n    } finally {\n        log.info(\"释放锁，1\");\n        lock.unlock();\n    }\n}\n\nvoid method2() {\n    RLock lock = redissonClient.getLock(\"lock\");\n    boolean success = lock.tryLock();\n    if (!success) {\n        log.error(\"获取锁失败，2\");\n        return;\n    }\n    try {\n        log.info(\"获取锁成功，2\");\n    } finally {\n        log.info(\"释放锁，2\");\n        lock.unlock();\n    }\n}\n```\n\n<a name=\"F6pIl\"></a>\n\n### Redisson分布式锁小结\n\n- 不可重入Redis分布式锁\n    - 原理：利用`SETNX`的互斥性；利用`EX`避免死锁；释放锁时判断线程标识\n    - 缺陷：不可重入、无法重试、锁超时失效\n- 可重入Redis分布式锁\n    - 原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待\n    - 缺陷：Redis宕机引起锁失效问题\n- Redisson的multiLock\n    - 原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功\n    - 缺陷：运维成本高、实现较为复杂\n      <a name=\"CAuyj\"></a>\n\n## 秒杀优化\n\n<a name=\"BmOsK\"></a>\n\n### 异步秒杀思路\n\n我们先来回顾一下秒杀下单流程：<br />当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤：\n\n- 查询优惠券\n- 判断秒杀库存是否足够\n- 查询订单\n- 校验是否一人一单\n- 扣减库存\n- 创建订单\n\n![44.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_f85e818027-44.png) <br />在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？<br />**优化方案：** 我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br />**但是这里存在两个难点：**\n\n- 我们怎么在Redis中快速校验是否一人一单，还有库存判断\n- 我们校验一人一单和将下单数据写入数据库，这是两个线程，我们怎么知道下单是否完成\n\n**解决难点：** 为了完成这件事我们在redis操作完（执行Lua脚本以保证原子性）之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。<br />![45.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_fb5a6fec27-45.png) <br />**我们现在来看整体思路：** 当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将userId和优惠券存入到Redis中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作。同时，由于我们需要在Redis中查询优惠券信息，所以在我们新增秒杀优惠券的同时，需要将优惠券信息保存到Redis中。<br />完成以上逻辑判断时，我们只需要判断当前Redis中的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单，前端可以通过返回订单的id来查询是否下单成功<br />![46.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_ff90994727-46.png)\n<a name=\"Z8kJX\"></a>\n\n### Redis完成用户秒杀资格校验\n\n本节需求：\n\n- 新增秒杀优惠券的同时，将优惠券信息保存到Redis中\n- 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功\n\n**保存优惠券代码：**\n\n```java\n@Override\n@Transactional\npublic void addSeckillVoucher(Voucher voucher) {\n    // 保存优惠券\n    save(voucher);\n    // 保存秒杀信息\n    SeckillVoucher seckillVoucher = new SeckillVoucher();\n    seckillVoucher.setVoucherId(voucher.getId());\n    seckillVoucher.setStock(voucher.getStock());\n    seckillVoucher.setBeginTime(voucher.getBeginTime());\n    seckillVoucher.setEndTime(voucher.getEndTime());\n    seckillVoucherService.save(seckillVoucher);\n    // 保存秒杀优惠券信息到Reids，Key名中包含优惠券ID，Value为优惠券的剩余数量\n    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); \n}\n```\n\n**编写Lua脚本：**\n\n> Lua的字符串拼接使用 ..，字符串转数字是 tonumber()\n\n```lua\n-- 订单id\nlocal voucherId = ARGV[1]\n-- 用户id\nlocal userId = ARGV[2]\n-- 优惠券key\nlocal stockKey = 'seckill:stock:' .. voucherId\n-- 订单key\nlocal orderKey = 'seckill:order:' .. voucherId\n-- 判断库存是否充足\nif (tonumber(redis.call('get', stockKey)) <= 0) then\n    return 1\nend\n-- 判断用户是否下单\nif (redis.call('sismember', orderKey, userId) == 1) then\n    return 2\nend\n-- 扣减库存\nredis.call('incrby', stockKey, -1)\n-- 将userId存入当前优惠券的set集合\nredis.call('sadd', orderKey, userId)\nreturn 0\n```\n\n**修改秒杀下单逻辑：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    // 1. 执行lua脚本\n    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,\n            Collections.emptyList(), voucherId.toString(),\n            UserHolder.getUser().getId().toString());\n    // 2. 判断返回值，并返回错误信息\n    if (result.intValue() != 0) {\n        return Result.fail(result.intValue() == 1 ? \"库存不足\" : \"不能重复下单\");\n    }\n    long orderId = redisIdWorker.nextId(\"order\");\n    // TODO 保存阻塞队列\n\n    // 3. 返回订单id\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"akU5S\"></a>\n\n### 基于阻塞队列实现秒杀优化\n\n在上一小节中，我们在判断用户具有秒杀资格后还未创建订单并放进异步队列实现异步下单。<br />本节任务：\n\n- 创建订单并放进异步队列\n- 开启线程任务对异步队列中的订单进行消费\n  <a name=\"TbwQu\"></a>\n\n#### 创建异步队列\n\n**创建阻塞队列：**\n\n```java\nprivate final BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024 * 1024);\n```\n\n**封装优惠券订单并放进异步队列：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,\n            Collections.emptyList(), voucherId.toString(),\n            UserHolder.getUser().getId().toString());\n    if (result.intValue() != 0) {\n        return Result.fail(result.intValue() == 1 ? \"库存不足\" : \"不能重复下单\");\n    }\n    long orderId = redisIdWorker.nextId(\"order\");\n    // 封装到voucherOrder中\n    VoucherOrder voucherOrder = new VoucherOrder();\n    voucherOrder.setVoucherId(voucherId);\n    voucherOrder.setUserId(UserHolder.getUser().getId());\n    voucherOrder.setId(orderId);\n    // 加入到阻塞队列\n    orderTasks.add(voucherOrder);\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"WjhdT\"></a>\n\n#### 实现异步下单\n\n**创建线程池：**\n\n```java\nprivate static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();\n```\n\n**创建线程任务：**\n\n```java\n// 秒杀业务需要在类初始化之后，就立即执行，所以这里需要用到@PostConstruct注解\n@PostConstruct\nprivate void init() {\n    SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());\n}\n\nprivate class VoucherOrderHandler implements Runnable {\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // 1. 获取队列中的订单信息\n                VoucherOrder voucherOrder = orderTasks.take();\n                // 2. 创建订单\n                handleVoucherOrder(voucherOrder);\n            } catch (Exception e) {\n                log.error(\"订单处理异常\", e);\n            }\n        }\n    }\n}\n```\n\n**创建订单业务：**\n\n```java\nprivate IVoucherOrderService proxy;\nprivate void handleVoucherOrder(VoucherOrder voucherOrder) {\n    // 1. 获取用户\n    Long userId = voucherOrder.getUserId();\n    // 2. 创建锁对象，作为兜底方案\n    RLock redisLock = redissonClient.getLock(\"order:\" + userId);\n    // 3. 获取锁\n    boolean isLock = redisLock.tryLock();\n    // 4. 判断是否获取锁成功         \n    if (!isLock) {\n        log.error(\"不允许重复下单!\");\n        return;\n    }\n    try {\n        // 5. 使用代理对象，由于这里是另外一个线程，\n        proxy.createVoucherOrder(voucherOrder);\n    } finally {\n        redisLock.unlock();\n    }\n}\n```\n\n> 这里有一个细节的地方，我们通过查看AopContext的源码发现，其获取代理对象的方式是通过ThreadLocal，由于我们现在是异步下单，已经不在主线程中了，所以直接获取是不行的。\n\n```java\nprivate static final ThreadLocal<Object> currentProxy = new NamedThreadLocal(\"Current AOP proxy\");\n```\n\n**修改秒杀业务（在主线程中获取代理对象并存放在成员变量中）：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,\n            Collections.emptyList(), voucherId.toString(),\n            UserHolder.getUser().getId().toString());\n    if (result.intValue() != 0) {\n        return Result.fail(result.intValue() == 1 ? \"库存不足\" : \"不能重复下单\");\n    }\n    long orderId = redisIdWorker.nextId(\"order\");\n    // 封装到voucherOrder中\n    VoucherOrder voucherOrder = new VoucherOrder();\n    voucherOrder.setVoucherId(voucherId);\n    voucherOrder.setUserId(UserHolder.getUser().getId());\n    voucherOrder.setId(orderId);\n    // 加入到阻塞队列\n    orderTasks.add(voucherOrder);\n    // 主线程获取代理对象\n    proxy = (IVoucherOrderService) AopContext.currentProxy();\n    return Result.ok(orderId);\n}\n```\n\n<a name=\"bHssv\"></a>\n\n#### 基于阻塞队列实现秒杀优化完整代码\n\n```java\npackage com.hmdp.service.impl;\n\nimport com.hmdp.dto.Result;\nimport com.hmdp.entity.VoucherOrder;\nimport com.hmdp.mapper.VoucherOrderMapper;\nimport com.hmdp.service.ISeckillVoucherService;\nimport com.hmdp.service.IVoucherOrderService;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.hmdp.utils.RedisIdWorker;\nimport com.hmdp.utils.UserHolder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.aop.framework.AopContext;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Resource;\nimport java.util.Collections;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Service\n@Slf4j\npublic class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {\n\n    @Autowired\n    private ISeckillVoucherService seckillVoucherService;\n\n    @Autowired\n    private RedisIdWorker redisIdWorker;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Resource\n    private RedissonClient redissonClient;\n\n    private IVoucherOrderService proxy;\n\n\n    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;\n\n    static {\n        SECKILL_SCRIPT = new DefaultRedisScript();\n        SECKILL_SCRIPT.setLocation(new ClassPathResource(\"seckill.lua\"));\n        SECKILL_SCRIPT.setResultType(Long.class);\n    }\n\n    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();\n\n    @PostConstruct\n    private void init() {\n        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());\n    }\n\n    private final BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024 * 1024);\n\n    private void handleVoucherOrder(VoucherOrder voucherOrder) {\n        // 1. 获取用户\n        Long userId = voucherOrder.getUserId();\n        // 2. 创建锁对象，作为兜底方案\n        RLock redisLock = redissonClient.getLock(\"order:\" + userId);\n        // 3. 获取锁\n        boolean isLock = redisLock.tryLock();\n        // 4. 判断是否获取锁成功 \n        if (!isLock) {\n            log.error(\"不允许重复下单!\");\n            return;\n        }\n        try {\n            // 5. 使用代理对象，由于这里是另外一个线程，\n            proxy.createVoucherOrder(voucherOrder);\n        } finally {\n            redisLock.unlock();\n        }\n    }\n\n    private class VoucherOrderHandler implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    // 1. 获取队列中的订单信息\n                    VoucherOrder voucherOrder = orderTasks.take();\n                    // 2. 创建订单\n                    handleVoucherOrder(voucherOrder);\n                } catch (Exception e) {\n                    log.error(\"订单处理异常\", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public Result seckillVoucher(Long voucherId) {\n        Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,\n                Collections.emptyList(), voucherId.toString(),\n                UserHolder.getUser().getId().toString());\n        if (result.intValue() != 0) {\n            return Result.fail(result.intValue() == 1 ? \"库存不足\" : \"不能重复下单\");\n        }\n        long orderId = redisIdWorker.nextId(\"order\");\n        // 封装到voucherOrder中\n        VoucherOrder voucherOrder = new VoucherOrder();\n        voucherOrder.setVoucherId(voucherId);\n        voucherOrder.setUserId(UserHolder.getUser().getId());\n        voucherOrder.setId(orderId);\n        // 加入到阻塞队列\n        orderTasks.add(voucherOrder);\n        // 主线程获取代理对象\n        proxy = (IVoucherOrderService) AopContext.currentProxy();\n        return Result.ok(orderId);\n    }\n\n\n    @Transactional\n    public void createVoucherOrder(VoucherOrder voucherOrder) {\n        // 一人一单逻辑\n        Long userId = voucherOrder.getUserId();\n        Long voucherId = voucherOrder.getVoucherId();\n        synchronized (userId.toString().intern()) {\n            int count = query().eq(\"voucher_id\", voucherId).eq(\"user_id\", userId).count();\n            if (count > 0) {\n                log.error(\"你已经抢过优惠券了哦\");\n                return;\n            }\n            // 5. 扣减库存\n            boolean success = seckillVoucherService.update()\n                    .setSql(\"stock = stock - 1\")\n                    .eq(\"voucher_id\", voucherId)\n                    .gt(\"stock\", 0)\n                    .update();\n            if (!success) {\n                log.error(\"库存不足\");\n            }\n            // 7. 将订单数据保存到表中\n            save(voucherOrder);\n        }\n    }\n}\n```\n\n<a name=\"T066c\"></a>\n\n### 秒杀优化小结\n\n<a name=\"EQSHi\"></a>\n\n#### 秒杀业务的优化思路\n\n- 先利用Redis完成库存容量、一人一单的判断，完成抢单业务\n- 再将下单业务放入阻塞队列，利用独立线程异步下单\n  <a name=\"vaUv2\"></a>\n\n#### 基于阻塞队列的异步秒杀存在哪些问题\n\n**内存限制问题：** 我们现在使用的是JDK自带的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，大量的订单都会放进阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题<br />**数据安全问题：**\n\n- 如果服务器宕机，内存中的信息全部丢失，导致已付款却无订单\n- 从异步队列中拿出了订单却因为异常没有消费，那就永远也不会被消费了\n  <a name=\"BvMXW\"></a>\n\n## Redis消息队列\n\n<a name=\"iWvzp\"></a>\n\n### 认识消息队列\n\n什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色\n\n- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）\n- 生产者：发送消息到消息队列\n- 消费者：从消息队列获取消息并处理消息\n\n使用队列的好处在于**解耦**：举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br />那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br />对于小中型项目完全可以使用Redis中的Stream作为消息队列，对于一些对消息队列有较高要求的项目，可以建议使用现有的消息队列框架，如RabitMq，RocketMq，Kafka。\n<a name=\"vD8in\"></a>\n\n### 基于Redis-List实现消息队列\n\n基于List结构模拟消息队列<br />消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果<br />队列的入口和出口不在同一边，所以我们可以利用：`LPUSH`结合`RPOP`或者`RPUSH`结合`LPOP`来实现消息队列。<br />不过需要注意的是，当队列中没有消息时，`RPOP`和`LPOP`操作会返回`NULL`，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用`BRPOP`或者`BLPOP`来实现阻塞效果<br />![47.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_02a4c26127-47.png) <br />基于List的消息队列有哪些优缺点？<br />**优点：**\n\n- 利用Redis存储，不受限于JVM内存上限\n- 基于Redis的持久化机制，数据安全性有保障\n- 可以满足消息有序性\n\n**缺点：**\n\n- 只支持单消费者(一个消息只能被读一次)\n- 无法避免消息丢失(如果读了消息之后服务器宕机，又由于只能被读一次，所以直接寄)\n  <a name=\"UUqOz\"></a>\n\n### 基于PubSub的消息队列\n\n**PubSub**（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息\n\n- `SUBSCRIBE channel [channel]`：订阅一个或多个频道\n- `PUBLISH channel msg`：向一个频道发送消息\n- `PSUBSCRIBE pattern [pattern]`：订阅与pattern格式匹配的所有频道\n\n> 官网对于`partern`的解释：\n> Subscribes the client to the given patterns.<br />Supported glob-style patterns:\n>\n> - h?flo subscribes to hello, hallo and hxllo\n> - h*llo subscribes to hllo and heeeello\n> - h[ae]llo subscribes to hello and hallo, but not hillo\n>\n> Use \\ to escape special characters if you want to match them verbatim.\n\n基于PubSub的消息队列有哪些优缺点<br />**优点：**\n\n- 采用发布订阅模型，支持多生产，多消费\n\n**缺点：**\n\n- 不支持数据持久化\n- 无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）\n- 消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）\n  <a name=\"WKILK\"></a>\n\n### 基于Stream的单消费消息队列\n\n**Stream**是Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。<br />**发送消息的命令：XADD**<br />![48.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_06504d6127-48.png)\n\n> 例如：\n\n![49.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_0deef46827-49.png) <br />**读取消息的方式之一：XREAD**<br />![50.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_10cfb76a27-50.png)\n\n> 例如使用XREAD读取第一个消息：\n\n![51.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_13c9a04927-51.png)\n\n> 例如让XREAD阻塞方式读取最新消息：\n\n![52.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_f80362ca27-52.png) <br />在业务开发中，我们可以使用循环调用的XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：\n\n```java\nwhile (true) {\n    // 尝试读取队列中的消息，最多阻塞2秒\n    Object msg = redis.execute(\"XREAD COUNT 1 BLOCK 2000 STREAMS users $\");\n    if (msg == null) {\n        continue;\n    }\n    // 处理消息\n    handleMessage(msg);\n}\n```\n\n> 注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题\n\n**STREAM类型消息队列的XREAD命令特点：**\n\n- 消息可回溯\n- 一个消息可以被多个消费者读取\n- 可以阻塞读取\n- 有漏读消息的风险\n  <a name=\"Mrc44\"></a>\n\n### 基于Stream的消费者组消息队列\n\n**消费者组**(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点：<br />![53.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_fb5fb12827-53.png) <br />**创建消费者组的命令：**\n\n```bash\nXGROUP CREATE key groupName ID [MKSTREAM]\n```\n\n> `key`：队列名称\n> `groupName`：消费者组名称\n> `ID`：起始`ID`标示，`$`代表队列中最后一个消息，`0`则代表队列中第一个消息\n> `MKSTREAM`：队列不存在时自动创建队列\n\n其他常见命令：\n\n```bash\n# 删除指定消费组\nXGROUP DESTORY key groupName\n\n# 给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupName consumerName\n\n# 删除消费者组中指定的消费者\nXGROUP DELCONSUMER key groupName consumerName\n```\n\n**从消费者组中读取消息：**\n\n```bash\nXREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]\n```\n\n> `group`：消费组名称\n> `consumer`：消费者名称，如果消费者不存在，会自动创建一个消费者\n> `count`：本次查询的最大数量\n> `BLOCK milliseconds`：当没有消息时最长等待时间\n> `NOACK`：无需手动`ACK`，获取到消息后自动确认（不建议）\n> `STREAMS key`：指定队列名称\n> `ID`：获取消息的起始`ID`，`ID`只有两种：\n>\n> - `>`：从下一个未消费的消息开始（非`pending-list`中的）\n> - 其他：根据指定`id`从`pending-list`中获取已消费但未确认的消息，例如`0`，是从`pending-list`中的`第一个`消息开始\n\n**消费者组监听消息的基本思路（伪代码）：**\n\n```java\nwhile(true) {\n    // 尝试监听队列，使用阻塞模式，最大等待时长为2000ms\n    Object msg = redis.call(\"XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 >\")\n    if(msg == null) {\n        // 没监听到消息，重试\n        continue;\n    }\n    try{\n        // 处理消息，完成后要手动确认ACK，ACK代码在handleMessage中编写\n        handleMessage(msg);\n    } catch(Exception e) {\n        while(true) {\n            // 0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息\n            Object msg = redis.call(\"XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0\");\n            if(msg == null) {\n                // null表示没有异常消息，所有消息均已确认，结束循环\n                break;\n            }\n            try{\n                // 说明有异常消息，再次处理\n                handleMessage(msg);\n            } catch(Exception e) {\n                // 再次出现异常，记录日志，继续循环\n                log.error(\"..\");\n                continue;\n            }\n        }\n    }\n}\n```\n\n**STREAM类型消息队列的XREADGROUP命令的特点：**\n\n- 消息可回溯\n- 可以多消费者争抢消息，加快消费速度\n- 可以阻塞读取\n- 没有消息漏读风险\n- 有消息确认机制，保证消息至少被消费一次\n\n**Redis实现消息队列的三种方式对比：**<br />![54.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_fe6681d927-54.png)\n<a name=\"IPCfB\"></a>\n\n### 基于Stream的消费者组优化秒杀\n\n本小节需求：\n\n- 创建一个Stream类型的消息队列，名为stream.orders\n- 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId\n- 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\n\n**在redis中创建名为stream.orders的消息队列：**\n\n```bash\nXGROUP CREATE stream.orders g1 0 MKSTREAM\n```\n\n**修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中：**\n\n```lua\n-- 订单id\nlocal voucherId = ARGV[1]\n-- 用户id\nlocal userId = ARGV[2]\n-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的\nlocal id = ARGV[3]\n-- 优惠券key\nlocal stockKey = 'seckill:stock:' .. voucherId\n-- 订单key\nlocal orderKey = 'seckill:order:' .. voucherId\n-- 判断库存是否充足\nif (tonumber(redis.call('get', stockKey)) <= 0) then\n    return 1\nend\n-- 判断用户是否下单\nif (redis.call('sismember', orderKey, userId) == 1) then\n    return 2\nend\n-- 扣减库存\nredis.call('incrby', stockKey, -1)\n-- 将userId存入当前优惠券的set集合\nredis.call('sadd', orderKey, userId)\n-- 将下单数据保存到消息队列中\nredis.call(\"sadd\", 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', id)\nreturn 0\n```\n\n**修改秒杀逻辑：**\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    long orderId = redisIdWorker.nextId(\"order\");\n    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,\n            Collections.emptyList(), voucherId.toString(),\n            UserHolder.getUser().getId().toString(), String.valueOf(orderId));\n    if (result.intValue() != 0) {\n        return Result.fail(result.intValue() == 1 ? \"库存不足\" : \"不能重复下单\");\n    }\n    // 主线程获取代理对象\n    proxy = (IVoucherOrderService) AopContext.currentProxy();\n    return Result.ok(orderId);\n}\n```\n\n**修改**`**VoucherOrderHandler**`**：**\n\n```java\nString queueName = \"stream.orders\";\n\nprivate class VoucherOrderHandler implements Runnable {\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // 1. 获取队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders >\n                List<MapRecord<String, Object, Object>> records = stringRedisTemplate.opsForStream().read(Consumer.from(\"g1\", \"c1\"),\n                        StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),\n                        // ReadOffset.lastConsumed()底层就是 '>'\n                        StreamOffset.create(queueName, ReadOffset.lastConsumed()));\n                // 2. 判断消息是否获取成功\n                if (records == null || records.isEmpty()) {\n                    continue;\n                }\n                // 3. 消息获取成功之后，我们需要将其转为对象\n                MapRecord<String, Object, Object> record = records.get(0);\n                Map<Object, Object> values = record.getValue();\n                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true);\n                // 4. 获取成功，执行下单逻辑，将数据保存到数据库中\n                handleVoucherOrder(voucherOrder);\n                // 5. 手动ACK，SACK stream.orders g1 id\n                stringRedisTemplate.opsForStream().acknowledge(queueName, \"g1\", record.getId());\n            } catch (Exception e) {\n                log.error(\"订单处理异常\", e);\n                // 订单异常的处理方式我们封装成一个函数，避免代码太臃肿\n                handlePendingList();\n            }\n        }\n    }\n}\n\nprivate void handlePendingList() {\n    while (true) {\n        try {\n            // 1. 获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0\n            List<MapRecord<String, Object, Object>> records = stringRedisTemplate.opsForStream().read(\n                    Consumer.from(\"g1\", \"c1\"),\n                    StreamReadOptions.empty().count(1),\n                    StreamOffset.create(queueName, ReadOffset.from(\"0\")));\n            // 2. 判断pending-list中是否有未处理消息\n            if (records == null || records.isEmpty()) {\n                // 如果没有就说明没有异常消息，直接结束循环\n                break;\n            }\n            // 3. 消息获取成功之后，我们需要将其转为对象\n            MapRecord<String, Object, Object> record = records.get(0);\n            Map<Object, Object> values = record.getValue();\n            VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true);\n            // 4. 获取成功，执行下单逻辑，将数据保存到数据库中\n            handleVoucherOrder(voucherOrder);\n            // 5. 手动ACK，SACK stream.orders g1 id\n            stringRedisTemplate.opsForStream().acknowledge(queueName, \"g1\", record.getId());\n        } catch (Exception e) {\n            log.info(\"处理pending-list异常\");\n            // 如果怕异常多次出现，可以在这里休眠一会儿\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n    }\n}\n```\n\n<a name=\"R2uIz\"></a>\n\n## 达人探店\n\n在本小节，我们主要需要实现探店笔记的**点赞功能**和**点赞排行榜**功能。\n\n> 假设在此之前已经实现了发布探店笔记和查看探店笔记排行榜功能。\n\n<a name=\"gIyih\"></a>\n\n### 点赞功能\n\n**需求背景：** 我们对于一篇笔记，如果不校验用户是否点赞，用户就可以一直点赞，显然不符合预期。<br />**需求：**\n\n- 当用户未点赞时，点赞成功，点赞数 `+ 1`\n- 当用户已点赞时，取消点赞，点赞数 `- 1`\n\n**解决方案：** 我们可以利用Redis中的Set数据类型实现快速校验用户是否已经点赞。<br />**Controller：**\n\n```java\n@PutMapping(\"/like/{id}\")\npublic Result likeBlog(@PathVariable(\"id\") Long id) {\n    return blogService.likeBlog(id);\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Override\npublic Result likeBlog(Long id) {\n    // 1. 获取当前用户信息\n    Long userId = UserHolder.getUser().getId();\n    // 2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合\n    String key = BLOG_LIKED_KEY + id;\n    Boolean isLiked = stringRedisTemplate.opsForSet().isMember(key, userId.toString());\n    if (BooleanUtil.isFalse(isLiked)) {\n        // 点赞数 +1\n        boolean success = update().setSql(\"liked = liked + 1\").eq(\"id\", id).update();\n        // 将用户加入set集合\n        if (success) {\n            stringRedisTemplate.opsForSet().add(key, userId.toString());\n        }\n    // 3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除\n    } else {\n        // 点赞数 -1\n        boolean success = update().setSql(\"liked = liked - 1\").eq(\"id\", id).update();\n        if (success) {\n            // 从set集合移除\n            stringRedisTemplate.opsForSet().remove(key, userId.toString());\n        }\n    }\n    return Result.ok();\n}\n```\n\n<a name=\"o9y7Z\"></a>\n\n### 点赞排行榜\n\n**需求背景：** 在探店笔记的详情页面，应该把给该条笔记点赞的人显示出来，例如显示最早点赞的5个人，形成点赞排行榜。<br />![55.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_02175bd027-55.png) <br />**解决方案：** 我们之前是将点赞的人放到`Set`集合中的，但是`Set`并不支持排序，所以现在需要修改成`SortedSet(Zset)`，在此，我们顺便对比一下几种集合的区别：<br />![56.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_059249f627-56.png)\n\n> 这里有一个小细节，如果我们使用Zset，那么点赞功能就要做相应的修改，由于Zset中没有SISMEMBER方法，所以需要通过查询分数来判断元素是否在集合中，如果查询到分数，则说明有该元素，否则该元素不存在。\n\n**Controller：**\n\n```java\n@GetMapping(\"/likes/{id}\")\npublic Result queryBlogLikes(@PathVariable Integer id) {\n    return blogService.queryBlogLikes(id);\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Override\npublic Result queryBlogLikes(Integer id) {\n    String key = BLOG_LIKED_KEY + id;\n    // zrange key 0 4  查询zset中前5个元素\n    Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);\n    // 如果是空的(可能没人点赞)，直接返回一个空集合\n    if (top5 == null || top5.isEmpty()) {\n        return Result.ok(Collections.emptyList());\n    }\n    List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());\n    // 将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排\n    // 所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序\n    String idsStr = StrUtil.join(\",\", ids);\n    // SELECT * FROM tb_user WHERE id IN (ids[0], ids[1] ...) ORDER BY FIELD(id, ids[0], ids[1] ...)\n    List<UserDTO> userDTOS = userService.query().in(\"id\", ids)\n            .last(\"order by field(id,\" + idsStr + \")\")\n            .list().stream()\n            .map(user -> BeanUtil.copyProperties(user, UserDTO.class))\n            .collect(Collectors.toList());\n    return Result.ok(userDTOS);\n}\n```\n\n<a name=\"idoe2\"></a>\n\n## 好友关注\n\n<a name=\"Qo9SR\"></a>\n\n### 查看用户笔记\n\n当我们对某个博主感兴趣时，会点进其主页看看她/他发布过哪些笔记，以便深入了解。\n\n```java\n// 逻辑较为简单，就没写Service，不太建议这样实现\n@GetMapping(\"/of/user\")\npublic Result queryBlogByUserId(\n\t\t@RequestParam(value = \"current\", defaultValue = \"1\") Integer current,\n\t\t@RequestParam(\"id\") Long id) {\n\t// 根据用户查询\n\tPage<Blog> page = blogService.query()\n\t\t\t.eq(\"user_id\", id).page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));\n\t// 获取当前页数据\n\tList<Blog> records = page.getRecords();\n\treturn Result.ok(records);\n}\n```\n\n<a name=\"ZjY2P\"></a>\n\n### 关注与取消关注\n\n在生活中有许多场景涉及到关注与取消关注，所以该功能用处广泛，本小节将实现用户的关注与取消关注功能。<br />首先我们抽象出每一次关注行为，并记录到`follow`表中。`follow`表结构如下表所示：\n\n| Field          | Type            | Collation | Null | Key  | Default           | Extra             | Comment      |\n| -------------- | --------------- | --------- | ---- | ---- | ----------------- | ----------------- | ------------ |\n| id             | bigint          | (NULL)    | NO   | PRI  | (NULL)            | auto_increment    | 主键         |\n| user_id        | bigint unsigned | (NULL)    | NO   |      | (NULL)            |                   | 用户id       |\n| follow_user_id | bigint unsigned | (NULL)    | NO   |      | (NULL)            |                   | 关联的用户id |\n| create_time    | timestamp       | (NULL)    | NO   |      | CURRENT_TIMESTAMP | DEFAULT_GENERATED | 创建时间     |\n\n`**follow**`**表对应的实体类：**\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = false)\n@Accessors(chain = true)\n@TableName(\"tb_follow\")\npublic class Follow implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 主键\n     */\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    /**\n     * 用户id\n     */\n    private Long userId;\n\n    /**\n     * 关联的用户id\n     */\n    private Long followUserId;\n\n    /**\n     * 创建时间\n     */\n    private LocalDateTime createTime;\n}\n```\n\n**Controller：**\n\n```java\n// 关注\n@PutMapping(\"/{id}/{isFollow}\")\npublic Result follow(@PathVariable(\"id\") Long followUserId, @PathVariable(\"isFollow\") Boolean isFollow) {\n    return followService.follow(followUserId, isFollow);\n}\n// 取消关注\n@GetMapping(\"/or/not/{id}\")\npublic Result isFollow(@PathVariable(\"id\") Long followUserId) {\n      return followService.isFollow(followUserId);\n}\n```\n\n**ServiceImpl：**\n\n```java\n// 查询是否关注\n@Override\npublic Result isFollow(Long followUserId) {\n    // 1.获取登录用户\n    Long userId = UserHolder.getUser().getId();\n    // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?\n    Integer count = query().eq(\"user_id\", userId).eq(\"follow_user_id\", followUserId).count();\n    // 3.判断\n    return Result.ok(count > 0);\n}\n\n// 关注与取消关注\n@Override\npublic Result follow(Long followUserId, Boolean isFollow) {\n    // 1.获取登录用户\n    Long userId = UserHolder.getUser().getId();\n    String key = \"follows:\" + userId;\n    // 1.判断到底是关注还是取关\n    if (isFollow) {\n        // 2.关注，新增数据\n        Follow follow = new Follow();\n        follow.setUserId(userId);\n        follow.setFollowUserId(followUserId);\n        save(follow);\n    } else {\n        // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?\n        remove(new QueryWrapper<Follow>()\n                .eq(\"user_id\", userId).eq(\"follow_user_id\", followUserId));\n    }\n    return Result.ok();\n}\n```\n\n<a name=\"IdfWM\"></a>\n\n### 共同关注\n\n当我们有了关注功能后，我们去访问别人主页时，我们还希望看到共同关注的人有哪些，这个功能在很多平台也都有广泛应用。那么我们该怎么去实现这个功能呢？<br />**共同关注实现方案：**<br />在Redis中有Set这样的数据结构，我们可以通过`INTERSECT`命令快速求出两个集合的交集。所以，我们将采用这个数据结构实现共同关注功能。\n\n> 上一小节中，我们实现关注与取消关注时并没有使用Redis，所以我们需要修改一下代码，维护好Set集。\n\n**修改关注与取消关注：**\n\n```java\n@Resource\nprivate StringRedisTemplate stringRedisTemplate;\n\n@Override\npublic Result follow(Long followUserId, Boolean isFellow) {\n    // 获取当前用户id\n    Long userId = UserHolder.getUser().getId();\n    String key = \"follows:\" + userId;\n    // 判断是否关注\n    if (isFellow) {\n        // 关注，则将信息保存到数据库\n        Follow follow = new Follow();\n        follow.setUserId(userId);\n        follow.setFollowUserId(followUserId);\n        // 如果保存成功\n        boolean success = save(follow);\n        // 则将数据也写入Redis\n        if (success) {\n            stringRedisTemplate.opsForSet().add(key, followUserId.toString());\n        }\n    } else {\n        // 取关，则将数据从数据库中移除\n        LambdaQueryWrapper<Follow> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);\n        // 如果取关成功\n        boolean success = remove(queryWrapper);\n        // 则将数据也从Redis中移除\n        if (success) {\n            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());\n        }\n    }\n    return Result.ok();\n}\n```\n\n**共同关注Controller：**\n\n```java\n@GetMapping(\"/common/{id}\")\npublic Result followCommons(@PathVariable Long id) {\n    return followService.followCommons(id);\n}\n```\n\n**共同关注ServiceImpl：**\n\n```java\n@Override\npublic Result followCommons(Long id) {\n    // 获取当前用户id\n    Long userId = UserHolder.getUser().getId();\n    String key1 = \"follows:\" + id;\n    String key2 = \"follows:\" + userId;\n    // 对当前用户和博主用户的关注列表取交集\n    Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);\n    if (intersect == null || intersect.isEmpty()) {\n        // 无交集就返回个空集合\n        return Result.ok(Collections.emptyList());\n    }\n    // 将结果转为list\n    List<Long> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());\n    // 之后根据ids去查询共同关注的用户，封装成UserDto再返回\n    List<UserDTO> userDTOS = userService.listByIds(ids).stream().map(user ->\n            BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());\n    return Result.ok(userDTOS);\n}\n```\n\n<a name=\"CxknG\"></a>\n\n### Feed流\n\n<a name=\"KksSu\"></a>\n\n#### Feed流简介\n\n**对于传统的模式内容检索**：用户需要主动通过搜索引擎或者是其他方式去查找想看的内容<br />当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作**Feed流**，直译为投喂，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息。<br />**对于新型Feed流的效果**：系统分析用户到底想看什么，然后直接把内容推送给用户，从而使用户能更加节约时间，不用去主动搜素。\n<a name=\"UyCii\"></a>\n\n#### Feed流实现方案\n\nFeed流的实现有两种模式：<br />**Timeline：** 不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(朋友圈就是基于此种方式实现)\n\n- 优点：信息全面，不会有缺失，并且实现也相对简单\n- 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低\n\n**智能排序：** 利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户\n\n- 优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷\n- 缺点：如果算法不精准，可能会起到反作用\n\n**由于我们针对的是好友关注关系的推送，因此采用Timeline方式：拿到关注的用户的博客，然后按照时间排序。**<br />**Timeline模式的三种实现方案：**\n\n- 拉模式（读扩散）\n- 推模式（写扩散）\n- 推拉结合\n\n**拉模式：**\n\n- 该模式的核心含义是：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序\n- 优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除\n- 缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大\n\n![57.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_07e1300627-57.png)<br />**推模式：**\n\n- 推模式是没有写邮箱的，当张三写了一个内容，此时会主动把张三写的内容发送到它粉丝的收件箱中，假设此时李四再来读取，就不用再去临时拉取了\n- 优点：时效快，不用临时拉取\n- 缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去\n\n![58.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_0ad816de27-58.png) <br />**推拉结合：**<br />推拉模式是一个折中的方案，站在发件人这一边，如果是普通人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。但如果是大V，那么他是直接将数据写入一份到发件箱中去，在直接写一份到活跃粉丝的收件箱中，站在收件人这边来看，如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里，但如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。<br />![59.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_0e6cb81b27-59.png) <br />**Timeline的三种实现方式对比：**<br />![60.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_10d2d93827-60.png)<br />综上，我们将采用**Timeline**方式的**推模式**实现已关注推送功能。\n<a name=\"FGbCt\"></a>\n\n### 基于推模式实现推送功能\n\n<a name=\"UnYLy\"></a>\n\n#### 需求及思路分析\n\n本小节需求：\n\n- 修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱（已关注用户的博客）\n- 收件箱满足可以根据时间戳排序（使用Redis实现）\n- 用户查看已关注收件箱时，做到分页查询\n\n**有一个需要注意的地方**，我们不能采用传统的分页查询模式。例如，在第一次查询用户收件箱之后，可能某一个关注的用户突然更新一条博客，我们如果继续按照下标查询第二页，就会重复查询到第一页的最后一条记录。<br />![61.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_13de573927-61.png) <br />那么怎么解决这个问题呢？我们使用**滚动分页查询**即可。\n\n- 我们需要记录每次操作的最后一条，然后从这个位置去开始读数据\n- 举个例子：我们从t1时刻开始，拿到第一页数据，拿到了10~6，然后记录下当前最后一次读取的记录，就是6，t2时刻发布了新纪录，此时这个11在最上面，但不会影响我们之前拿到的6，此时t3时刻来读取第二页，第二页读数据的时候，从6-1=5开始读，这样就拿到了5~1的记录。我们在这个地方可以使用SortedSet来做，使用时间戳来充当表中的1~10\n\n![62.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_162a288a27-62.png)\n<a name=\"nZiQc\"></a>\n\n#### 补充发布博客代码\n\n由于之前未介绍到发送博客功能，本小节结合推送功能，对发送博客代码进行书写和完善。\n\n```java\n@Override\npublic Result saveBlog(Blog blog) {\n    // 获取登录用户\n    UserDTO user = UserHolder.getUser();\n    blog.setUserId(user.getId());\n    // 保存探店博文\n    save(blog);\n    // 条件构造器\n    LambdaQueryWrapper<Follow> queryWrapper = new LambdaQueryWrapper<>();\n    // 从follow表最中，查找当前用户的粉丝  select * from follow where follow_user_id = user_id\n    queryWrapper.eq(Follow::getFollowUserId, user.getId());\n    // 获取当前用户的粉丝\n    List<Follow> follows = followService.list(queryWrapper);\n    for (Follow follow : follows) {\n        Long userId = follow.getUserId();\n        String key = FEED_KEY + userId;\n        // 推送数据\n        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());\n    }\n    // 返回id\n    return Result.ok(blog.getId());\n}\n```\n\n<a name=\"lHCuM\"></a>\n\n#### 实现分页查询收件箱\n\n本小节将实现在个人主页的关注栏中查询并展示推送的博客信息。<br />**实现步骤：**\n\n- 编写一个通用的分页类\n- 根据参数进行查询\n- 每次查询完成之后，我们要分析出查询出的最小时间戳，这个值会作为下一次的查询条件（计算`lastId`）\n- 我们需要找到与上一次查询相同的查询个数，并作为偏移量，下次查询的时候，跳过这些查询过的数据，拿到我们需要的数据（计算`offset`）\n\n> 我们的请求参数中需要携带`lastId`和`offset`，即上一次查询时的最小时间戳和偏移量，除了第一次，后面的每一次查询的参数会由前一次查询计算出\n\n**编写通用的分页查询结果类：**\n\n```java\n@Data\npublic class ScrollResult {\n    // 为了达到通用的效果，我们使用泛型，这样也能用于查询博客意外的数据\n    private List<?> list;\n    private Long minTime;\n    private Integer offset;\n}\n```\n\n**Controller：**\n\n```java\n@GetMapping(\"/of/follow\")\npublic Result queryBlogOfFollow(@RequestParam(\"lastId\") Long max, @RequestParam(value = \"offset\",defaultValue = \"0\") Integer offset) {\n    return blogService.queryBlogOfFollow(max, offset);\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Override\npublic Result queryBlogOfFollow(Long max, Integer offset) {\n    // 1. 获取当前用户\n    Long userId = UserHolder.getUser().getId();\n    // 2. 查询该用户收件箱（之前我们存的key是固定前缀 + 粉丝id），所以根据当前用户id就可以查询是否有关注的人发了笔记\n    String key = FEED_KEY + userId;\n    Set<ZSetOperations.TypedTuple<String>> typeTuples = stringRedisTemplate.opsForZSet()\n            .reverseRangeByScoreWithScores(key, 0, max, offset, 2);\n    // 3. 非空判断\n    if (typeTuples == null || typeTuples.isEmpty()) {\n        return Result.ok(Collections.emptyList());\n    }\n    // 4. 解析数据，blogId、minTime（时间戳）、offset，这里指定创建的list大小，可以略微提高效率，因为我们知道这个list就得是这么大\n    ArrayList<Long> ids = new ArrayList<>(typeTuples.size());\n    long minTime = 0;\n    int os = 1;\n    for (ZSetOperations.TypedTuple<String> typeTuple : typeTuples) {\n        // 4.1 获取id\n        String id = typeTuple.getValue();\n        ids.add(Long.valueOf(id));\n        // 4.2 获取score（时间戳）\n        long time = typeTuple.getScore().longValue();\n        if (time == minTime) {\n            os ++;\n        }else {\n            minTime = time;\n            os = 1;\n        }\n    }\n    // 解决SQL的in不能排序问题，手动指定排序为传入的ids\n    String idsStr = StrUtil.join(\",\");\n    // 5. 根据id查询blog\n    List<Blog> blogs = query().in(\"id\", ids).last(\"ORDER BY FIELD(id, \" + idsStr + \")\").list()\n    for (Blog blog : blogs) {\n        // 5.1 查询发布该blog的用户信息\n        queryBlogUser(blog);\n        // 5.2 查询当前用户是否给该blog点过赞\n        isBlogLiked(blog);\n    }\n    // 6. 封装结果并返回\n    ScrollResult scrollResult = new ScrollResult();\n    scrollResult.setList(blogs);\n    scrollResult.setOffset(os);\n    scrollResult.setMinTime(minTime);\n    return Result.ok(scrollResult);\n}\n```\n\n<a name=\"rAd4M\"></a>\n\n## 附近商户\n\n<a name=\"NOgGD\"></a>\n\n### GEO数据结构\n\nGEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据，常见的命令有：\n\n- `GEOADD`：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）\n- `GEODIST`：计算指定的两个点之间的距离并返回\n- `GEOHASH`：将指定member的坐标转为hash字符串形式并返回\n- `GEOPOS`：返回指定member的坐标\n- `GEORADIUS`（6.2以后已废弃）：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。\n- `GEOSEARCH`（6.2.新功能）：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。\n- `GEOSEARCHSTORE`（6.2.新功能）：与`GEOSEARCH`功能一致，不过可以把结果存储到一个指定的`key`。\n  <a name=\"VkBV5\"></a>\n\n### 导入店铺数据到Redis-GEO\n\n具体场景说明，例如美团/饿了么这种外卖App，你是可以看到商家离你有多远的，那我们现在也要实现这个功能。<br />我们可以使用GEO来实现该功能，以当前坐标为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件插入后台，后台查询出对应的数据再返回。<br />**那现在我们要做的就是**：将数据库中的数据导入到Redis中去，GEO在Redis中就是一个member和一个经纬度，经纬度对应的就是tb_shop中的`x`和`y`，而member，我们用shop_id来存，因为Redis只是一个内存级数据库，如果存海量的数据，还是力不从心，所以我们只存一个id，用的时候再拿id去SQL数据库中查询shop信息。<br />但是此时还有一个问题，我们在redis中没有存储shop_type，无法根据店铺类型来对数据进行筛选，解决办法就是**将type_id作为key，存入同一个GEO集合即可**<br />![63.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_1874fdb627-63.png)<br />**代码实现：**\n\n```java\n@Test\npublic void loadShopData() {\n    List<Shop> shopList = shopService.list();\n    Map<Long, List<Shop>> map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));\n    // 处理每一个类别\n    for (Map.Entry<Long, List<Shop>> entry : map.entrySet()) {\n        Long typeId = entry.getKey();\n        List<Shop> shops = entry.getValue();\n        String key = SHOP_GEO_KEY + typeId;\n        List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(shops.size());\n        // 处理每一个类别中的所有店铺\n        for (Shop shop : shops) {\n            // 将当前type的商铺都添加到locations集合中\n            locations.add(new RedisGeoCommands.GeoLocation<>(shop.getId().toString(), new Point(shop.getX(), shop.getY())));\n        }\n        // 批量写入\n        stringRedisTemplate.opsForGeo().add(key, locations);\n    }\n}\n```\n\n<a name=\"c5k2d\"></a>\n\n### 实现查询附近商户功能\n\n在实现之前还有一个注意的地方，由于`GEOSEARCH`是Redis 6.2才提供的，因此如果SpringDataRedis版本较低，则需要修改`pom.xml`文件：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    <exclusions>\n        <exclusion>\n            <artifactId>spring-data-redis</artifactId>\n            <groupId>org.springframework.data</groupId>\n        </exclusion>\n        <exclusion>\n            <artifactId>lettuce-core</artifactId>\n            <groupId>io.lettuce</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.data</groupId>\n    <artifactId>spring-data-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n<dependency>\n    <groupId>io.lettuce</groupId>\n    <artifactId>lettuce-core</artifactId>\n    <version>6.1.6.RELEASE</version>\n</dependency>\n```\n\n**Controller：**\n\n```java\n@GetMapping(\"/of/type\")\npublic Result queryShopByType(\n        @RequestParam(\"typeId\") Integer typeId,\n        @RequestParam(value = \"current\", defaultValue = \"1\") Integer current,\n        @RequestParam(value = \"x\", required = false) Double x,\n        @RequestParam(value = \"y\", required = false) Double y\n) {\n   return shopService.queryShopByType(typeId,current,x,y);\n}\n```\n\n**ServiceImpl（细节超多）：**\n\n```java\n@Override\npublic Result queryShopByType(Integer typeId, Integer current, Double x, Double y) {\n    // 1. 判断是否需要根据距离查询\n    if (x == null || y == null) {\n        // 根据类型分页查询\n        Page<Shop> page = query()\n                .eq(\"type_id\", typeId)\n                .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));\n        // 返回数据\n        return Result.ok(page.getRecords());\n    }\n    // 2. 计算分页查询参数\n    int from = (current - 1) * SystemConstants.MAX_PAGE_SIZE;\n    int end = current * SystemConstants.MAX_PAGE_SIZE;\n    String key = SHOP_GEO_KEY + typeId;\n    // 3. 查询redis、按照距离排序、分页; 结果：shopId、distance\n    // GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST\n    GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo().search(key,\n            GeoReference.fromCoordinate(x, y),\n            new Distance(5000),\n            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));\n    if (results == null) {\n        return Result.ok(Collections.emptyList());\n    }\n    // 4. 解析出id\n    List<GeoResult<RedisGeoCommands.GeoLocation<String>>> list = results.getContent();\n    if (list.size() < from) {\n        // 起始查询位置大于数据总量，则说明没数据了，返回空集合\n        return Result.ok(Collections.emptyList());\n    }\n    ArrayList<Long> ids = new ArrayList<>(list.size());\n    HashMap<String, Distance> distanceMap = new HashMap<>(list.size());\n    list.stream().skip(from).forEach(result -> {\n        String shopIdStr = result.getContent().getName();\n        ids.add(Long.valueOf(shopIdStr));\n        Distance distance = result.getDistance();\n        distanceMap.put(shopIdStr, distance);\n    });\n    // 5. 根据id查询shop\n    String idsStr = StrUtil.join(\",\", ids);\n    List<Shop> shops = query().in(\"id\", ids).last(\"ORDER BY FIELD( id,\" + idsStr + \")\").list();\n    for (Shop shop : shops) {\n        // 设置shop的举例属性，从distanceMap中根据shopId查询\n        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());\n    }\n    // 6. 返回\n    return Result.ok(shops);\n}\n```\n\n<a name=\"kELTb\"></a>\n\n## 用户签到\n\n<a name=\"CNXyX\"></a>\n\n### 实现思路及BitMap介绍\n\n对于用户签到的功能，应用场景也可谓是广泛，如果我们使用数据库来完成会是什么样子呢？<br />如果把用户的每次签到当成一条记录，假设1000万用户，平均每人一年签到10次（不过分吧），那一年下来这张表就有1亿条数据，这是多么恐怖的数据量，并且每条记录就算10多字节，这存储空间压力也山大呀！<br />**所以，我们该怎么解决呢？**<br />这里我们借鉴`状态压缩`的思想，将每个用户一个月的签到状态压缩为一个31位的二进制串，`0`代表未签到，`1`代表已签到，而这恰好能使用Redis中的`BitMap`数据结构完成。<br />**BitMap的常见命令：**\n\n- `SETBIT`：向指定位置（offset）存入一个`0`或`1`\n- `GETBIT`：获取指定位置（offset）的bit值\n- `BITCOUNT`：统计BitMap中值为`1`的bit位的数量\n- `BITFIELD`：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值\n- `BITFIELD_RO`：获取BitMap中bit数组，并以十进制形式返回\n- `BITOP`：将多个BitMap的结果做位运算（与、或、异或）\n- `BITPOS`：查找bit数组中指定范围内第一个`0`或`1`出现的位置\n  <a name=\"rRDK1\"></a>\n\n### 实现签到功能\n\n需求：实现用户当天签到功能\n\n> 由于BitMap底层是基于String数据结构，因此对其的操作在Java中也都封装在字符串相关操作中了\n\n**Controller：**\n\n```java\n@PostMapping(\"/sign\")\npublic Result sign() {\n    return userService.sign();\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Override\npublic Result sign() {\n    // 1. 获取当前用户\n    Long userId = UserHolder.getUser().getId();\n    // 2. 获取日期\n    LocalDateTime now = LocalDateTime.now();\n    // 3. 拼接key\n    String keySuffix = now.format(DateTimeFormatter.ofPattern(\":yyyyMM\"));\n    String key = USER_SIGN_KEY + userId + keySuffix;\n    // 4. 获取今天是当月第几天(1~31)\n    int dayOfMonth = now.getDayOfMonth();\n    // 5. 写入Redis  BITSET key offset 1\n    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);\n    return Result.ok();\n}\n```\n\n<a name=\"beOYW\"></a>\n\n### 连续签到统计\n\n需求：统计出从今天开始往前的连续签到天数\n\n> 其实就是一个位运算的基本操作\n\n**Controller：**\n\n```java\n@GetMapping(\"/sign/count\")\npublic Result signCount() {\n    return userService.signCount();\n}\n```\n\n**ServiceImpl：**\n\n```java\n@Override\npublic Result signCount() {\n    // 1. 获取当前用户\n    Long userId = UserHolder.getUser().getId();\n    // 2. 获取日期\n    LocalDateTime now = LocalDateTime.now();\n    // 3. 拼接key\n    String keySuffix = now.format(DateTimeFormatter.ofPattern(\":yyyyMM\"));\n    String key = USER_SIGN_KEY + userId + keySuffix;\n    // 4. 获取今天是当月第几天(1~31)\n    int dayOfMonth = now.getDayOfMonth();\n    // 5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0\n    List<Long> result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()\n            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0));\n    if (result == null || result.isEmpty()) {\n        return Result.ok(0);\n    }\n    // 6. 循环遍历\n    int count = 0;\n    Long num = result.get(0);\n    while (true) {\n        if ((num & 1) == 0) {\n            break;\n        } else\n            count++;\n        // 数字无符号右移，抛弃最后一位\n        num >>>= 1;\n    }\n    return Result.ok(count);\n}\n```\n\n<a name=\"jpMI1\"></a>\n\n### 利用BitMap实现简单布隆过滤器\n\n之前的章节中我们介绍过缓存穿透的问题，其中有一个方案就是利用布隆过滤器快速判断查询的id在数据库中是否存在，那么，我们来看看其实现思想是什么。<br />我们对每一个id进行相同的哈希运算，得到一个值，然后将这个值在BitMap上对应的位修改为`1`来表示这个id存在，`0`则表示不存在。<br />既然是哈希，那冲突是肯定避免不了的，这也就是布隆过滤器会有误判的存在（当然，别人那是优化过的，利用多次哈希较少冲突）<br />![64.png](https://cdn.acwing.com/media/article/image/2024/06/11/126318_1b03ccb627-64.png)\n<a name=\"Toj5N\"></a>\n\n## UV统计\n\n<a name=\"tD1e0\"></a>\n\n### 概念介绍与HyperLogLog简介\n\n**UV：** 全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。<br />**PV：** 全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。\n\n> 本博客首页底部就有本网站的访问人数及浏览总量，对应的就是`UV`与`PV`。\n\nUV统计在服务端做会很麻烦，因为要判断该用户是否已经统计过了，需要将统计过的信息保存，但是如果每个访问的用户都保存到Redis中，那么数据库会非常恐怖，那么该如何处理呢？<br />**HyperLogLog(HLL)**是从Loglog算法派生的概率算法，用户确定非常大的集合基数，而不需要存储其所有值，算法相关原理可以参考下面这篇文章：[HyperLogLog 算法的原理讲解](https://juejin.cn/post/6844903785744056333#heading-0)<br />Redis中的HLL是基于string结构实现的，单个HLL的内存**永远小于16kb**，**内存占用低的令人发指**！作为代价，其测量结果是概率性的，**有小于0.81％的误差**。不过对于UV统计来说，这完全可以忽略。<br />**HyperLogLog的三个命令：**\n\n```bash\nPFADD key element [element...]\nsummary: Adds the specified elements to the specified HyperLogLog\n\nPFCOUNT key [key ...]\nReturn the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).\n\nPFMERGE destkey sourcekey [sourcekey ...]\nlnternal commands for debugging HyperLogLog values\n```\n\n<a name=\"UYvT2\"></a>\n\n### 测试百万数据的统计\n\n使用单元测试，向HyperLogLog中添加100万条数据，看看内存占用是否真的那么低，以及统计误差如何\n\n```java\n@Test\npublic void testHyperLogLog() {\n    String[] users = new String[1000];\n    int j = 0;\n    for (int i = 0; i < 1000000; i++) {\n        j = i % 1000;\n        users[j] = \"user_\" + i;\n        // 每1000条数据向HyperLogLog中插入一次\n        if (j == 999) {\n            stringRedisTemplate.opsForHyperLogLog().add(\"HLL\", users);\n        }\n    }\n    Long count = stringRedisTemplate.opsForHyperLogLog().size(\"HLL\");\n    System.out.println(\"count = \" + count);\n}\n```\n\n> 插入100W条数据，得到的count为997593，误差率为0.002407%\n> 去Redis图形化界面中查看占用情况为：14K字节（确实实现了吹的牛）\n\n","categories":["Redis"]},{"title":"Redis基础篇","url":"/2024/03/04/Redis基础篇/","content":"\n<a name=\"AAv2g\"></a>\n## 1. Redis简介\n> Redis诞生于2009年，全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n- Redis的特征：\n   - 键值（`key-value`）型，value支持多种不同数据结构，功能丰富；\n   - 单线程，每个命令具备原子性；\n   - 低延迟，速度快（基于内存、IO多路复用、良好的编码）；\n   - 支持数据持久化；\n   - 支持主从集群、分片集群；\n   - 支持多语言客户端。\n- 什么是NoSQL：\n   - NoSQL最常见的解释是\"non-relational\"， 很多人也说它是\"_**Not Only SQL**_\"；\n   - NoSQL仅仅是一个概念，泛指**非关系型的数据库；**\n   - 区别于关系数据库，它们不保证关系数据的ACID特性（原子性 (Atomicity)、 一致性；(Consistency)、隔离性(Isolation) 和 持久性(Durability)）；\n   - NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入；\n   - 常见的NoSQL数据库有：`Redis`、`MemCache`、`MongoDB`等。\n- NoSQL与SQL的差异：\n\n| 属性 | SQL | NoSQL |\n| :-: | :-: | :-: |\n| 数据结构 | 结构化 | 非结构化 |\n| 数据关联 | 关联的 | 无关联的 |\n| 查询方式 | SQL查询 | 非SQL |\n| 事务特性 | ACID | BASE |\n| 存储方式 | 磁盘 | 内存 |\n| 扩展性 | 垂直 | 水平 |\n| 使用场景 | （1）数据结构固定<br />（2）相关业务对数据安全性、一致性要求较高 | （1）数据结构不固定<br />（2）对一致性、安全性要求不高<br />（3）对性能要求 |\n\n<a name=\"fRycZ\"></a>\n## 2. Redis安装\n<a name=\"ZO5Z0\"></a>\n### 2.1 ubuntu安装 \n\n- ubunutu指令安装：\n```shell\napt install redis-server\n```\n\n- 检查安装：\n```shell\nservice redis-server start\n\n# 检查启动情况\nps -ef | grep redis # 进程检查\nnetstat -anp | grep redis # 端口检查\n```\n\n- 启动redis服务：\n```shell\nservice redis-server start\n```\n\n- 连接redis客户端：\n```shell\n# 需要在客户端上对redis进行操作\nredis-cli\n```\n<a name=\"jVgJz\"></a>\n### 2.2 linux源码安装\n> 由于redis使用C语言编写，所以想要使用源码编译安装，必须先安装编译器再执行后续步骤。\n> `apt install gcc`：为了编译源代码\n> `apt install make`：为了自动化构建项目\n\n- 解压压缩包\n```shell\ntar -zxvf redis-6.0.6.tar.gz\n```\n\n- 进入源码目录\n```shell\ncd redis-6.0.6\n```\n\n- 执行编译\n```shell\n# 需要主机上有C语言的编译环境，即gcc 等编译工具链\nmake\n```\n\n- 默认安装\n```shell\n# 默认地，相关程序会被安装到 /usr/local/bin 目录下,例如 /usr/local/bin/redis-server\nmake install\n```\n  - 或者安装到指定目录\n```shell\nexport PREFIX=/opt/redis\nmake install\n```\n\n- 运行\n```shell\ncd /usr/local/bin/\nredis-server\n# 运行时也可以指定配置文件路径\nredis-server  /path/of/redis/redis.conf\n```\n<a name=\"BEQuA\"></a>\n### 2.3 设置开机自启\n> Redis推荐开机自启\n\n- 首先，新建一个系统服务文件 ：\n```shell\nvi /etc/systemd/system/redis.service\n```\n\n- 粘贴一下内容：\n```nginx\n[Unit]\nDescription=redis-server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n- 然后重载系统服务 ：\n```shell\nsystemctl daemon-reload\n```\n\n- 之后，我们可以用下面这组命令来操作redis：\n```shell\n# 启动\nsystemctl start redis\n# 停止\nsystemctl stop redis\n# 重启\nsystemctl restart redis\n# 查看状态\nsystemctl status redis\n```\n\n- 执行下面的命令，可以让redis开机自启 \n```shell\nsystemctl enable redis\n```\n<a name=\"x4NCY\"></a>\n## 3. 修改配置文件\n找到`/etc/redis/`下的`redis.conf`文件使用`vim`编辑：\n\n1. 绑定ip配置：当服务器存在多个网卡(IP) 时，让服务器监听哪个IP\n```shell\nbind 127.0.0.1 # 只能从本机访问\nbind 192.168.43.128 # 只能从内网访问\nbind 202.10.8.130  # 可以从外网访问\nbind 0.0.0.0  # 可以从任意位置访问此服务器 (比较常用)\n```\n\n2. 设置密码：\n```shell\n# 找到requirepass这一行 使用/requirepass + n 或者 ?requirepass + n 快速查找（vim知识点）\nrequirepass 1a2b3c # 密码尽量复杂些，避免被破解\n```\n\n3. 重启`redis`服务：\n```shell\n# 不重启服务输入密码不通过\nservice redis-server restart\n```\n\n4. 连接客户端：\n```shell\nredis-cli\n# 验证密码\nauth 1a2b3c\n# 也可以将以上两步合为一步 redis-cli -a a1b2c3\nping # 服务端正常会返回pong\n```\n<a name=\"CEe0H\"></a>\n## 4. Redis命令\n<a name=\"I5L8G\"></a>\n### 4.1 通用命令\n| 指令 | 描述 |\n| :-: | :-: |\n| KEYS | 查看符合模板的所有key，不建议在生产环境设备上使用 |\n| DEL | 删除一个指定的key |\n| EXISTS | 判断key是否存在 |\n| EXPIRE | 给一个key设置有效期，有效期到期时该key会被自动删除 |\n| TTL | 查看一个KEY的剩余有效期 |\n\n> 可以通过`help [command]`查看一个命令的具体用法！\n\n<a name=\"OzXhr\"></a>\n### 4.2 各个数据类型命令\n<a name=\"IweAd\"></a>\n\n#### 4.2.1 String\n**String的常见命令：**\n- `SET`：添加或者修改已经存在的一个String类型的键值对\n- `GET`：根据key获取String类型的value\n- `MSET`：批量添加多个String类型的键值对\n- `MGET`：根据多个key获取多个String类型的value\n- `INCR`：让一个整型的key自增1\n- `INCRBY`:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\n- `INCRBYFLOAT`：让一个浮点类型的数字自增并指定步长\n- `SETNX`：添加一个String类型的键值对，前提是这个key不存在，否则不执行\n- `SETEX`：添加一个String类型的键值对，并且指定有效期\n\n**注意：**\n- 以上命令除了`INCRBYFLOAT`都是常用命令\n- `SET`和`GET`：如果key不存在则是新增，如果存在则是修改\n```shell\n127.0.0.1:6379> set name Rose  //原来不存在\nOK\n\n127.0.0.1:6379> get name \n\"Rose\"\n\n127.0.0.1:6379> set name Jack //原来存在，就是修改\nOK\n\n127.0.0.1:6379> get name\n\"Jack\"\n```\n<a name=\"TwBwp\"></a>\n#### 4.2.2 Hash\n**Hash类型的常见命令:**\n- `HSET key field value`：添加或者修改hash类型key的field的值\n- `HGET key field`：获取一个hash类型key的field的值\n- `HMSET`：批量添加多个hash类型key的field的值\n- `HMGET`：批量获取多个hash类型key的field的值\n- `HGETALL`：获取一个hash类型的key中的所有的field和value\n- `HKEYS`：获取一个hash类型的key中的所有的field\n- `HINCRBY`:让一个hash类型key的字段值自增并指定步长\n- `HSETNX`：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n  <a name=\"nXnw9\"></a>\n#### 4.2.3 List\n**List的常见命令：**\n- `LPUSH key element ... `：向列表左侧插入一个或多个元素\n- `LPOP key`：移除并返回列表左侧的第一个元素，没有则返回nil\n- `RPUSH key element ...`：向列表右侧插入一个或多个元素\n- `RPOP key`：移除并返回列表右侧的第一个元素\n- `LRANGE key star end`：返回一段角标范围内的所有元素\n- `BLPOP`和`BRPOP`：与`LPOP`和`RPOP`类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/07/126318_7e02f584dc-4.2.3list.png)\n<a name=\"WMrHG\"></a>\n#### 4.2.4 Set\n**Set类型的常见命令：**\n- `SADD key member ...`：向set中添加一个或多个元素\n- `SREM key member ...`: 移除set中的指定元素\n- `SCARD key`： 返回set中元素的个数\n- `SISMEMBER key member`：判断一个元素是否存在于set中\n- `SMEMBERS`：获取set中的所有元素\n- `SINTER key1 key2 ...`：求key1与key2的交集\n- `SDIFF key1 key2 ...`：求key1与key2的差集\n- `SUNION key1 key2 ...`：求key1和key2的并集\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/07/126318_81ff1000dc-4.2.4set.png)\n<a name=\"m4FJA\"></a>\n#### 4.2.5 SortedSet\n**SortedSet的常见命令：**\n- `ZADD key score member`：添加一个或多个元素到SortedSet ，如果已经存在则更新其score值\n- `ZREM key member`：删除SortedSet中的一个指定元素\n- `ZSCORE key member` : 获取SortedSet中的指定元素的score值\n- `ZRANK key member`：获取SortedSet 中的指定元素的排名\n- `ZCARD key`：获取SortedSet中的元素个数\n- `ZCOUNT key min max`：统计score值在给定范围内的所有元素的个数\n- `ZINCRBY key increment member`：让SortedSet中的指定元素自增，步长为指定的increment值\n- `ZRANGE key min max`：按照score排序后，获取指定排名范围内的元素\n- `ZRANGEBYSCORE key min max`：按照score排序后，获取指定score范围内的元素\n- `ZDIFF.ZINTER.ZUNION`：求差集、交集、并集\n\n**注意：**<br />所有的排名默认都是升序，如果要降序则在命令的`Z`后面添加`REV`即可，例如：\n- **升序**获取SortedSet中的指定元素的排名：`ZRANK key member`\n- **降序**获取SortedSet中的指定元素的排名：`ZREVRANK key memeber`\n  <a name=\"FadCZ\"></a>\n## 5. Redis的Java客户端\n<a name=\"BpC55\"></a>\n### 5.1 目前主流的Redis的Java客户端：\n\n- **Jedis和Lettuce：** 这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。\n- **Redisson：** 是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。\n<a name=\"eMiZZ\"></a>\n### 5.2 Jedis快速入门\n**不使用连接池：**\n\n- 引入相关依赖\n```xml\n<!--jedis-->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n\n<!--单元测试-->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.7.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n- 建立测试类\n```java\nprivate Jedis jedis;\n\n// 建立连接\n@BeforeEach\nvoid setUp() {\n    // 建立连接（ip + port）\n    jedis = new Jedis(\"127.0.0.1\", 6379);\n    // 设置密码\n    jedis.auth(\"1a2b3c\");\n    // 选择库（总共16个库）\n    jedis.select(0);\n}\n\n// 释放资源\n@AfterEach\nvoid tearDown(){\n    if (jedis != null){\n        jedis.close();\n    }\n}\n```\n\n- 在测试类中进行测试\n```java\n// 测试String\n@Test\nvoid testString(){\n    jedis.set(\"name\",\"SmallBoat\");\n    String name = jedis.get(\"name\");\n    System.out.println(\"name: \" + name);\n}\n\n// 测试Hash\n@Test\nvoid testHash(){\n    jedis.hset(\"user:1\",\"name\",\"Jack\");\n    jedis.hset(\"user:2\",\"name\",\"Rose\");\n    jedis.hset(\"user:1\",\"age\",\"21\");\n    jedis.hset(\"user:2\",\"age\",\"18\");\n    Map<String, String> map = jedis.hgetAll(\"user:1\");\n    System.out.println(map);\n}\n```\n**使用连接池：**\n> Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式。\n\n- 创建JedisConnectionFactory工具类\n```java\npublic class JedisConnectionFactory {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 配置连接池\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(8);\n        poolConfig.setMaxIdle(8);\n        poolConfig.setMinIdle(0);\n        poolConfig.setMaxWaitMillis(1000);\n        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码\n        jedisPool = new JedisPool(poolConfig, \"127.0.0.1\", 6379, 1000, \"1a2b3c\");\n    }\n\n    public static Jedis getJedis(){\n        return jedisPool.getResource();\n    }\n}\n```\n\n- 创建测试类\n```java\n@SpringBootTest\nclass RedisTestApplicationTests {\n\n    private Jedis jedis = JedisConnectionFactory.getJedis();\n\n    // 测试String\n    @Test\n    void testString(){\n        jedis.set(\"name\",\"SmallBoat\");\n        String name = jedis.get(\"name\");\n        System.out.println(\"name: \" + name);\n    }\n\n    // 测试Hash\n    @Test\n    void testHash(){\n        jedis.hset(\"user:1\",\"name\",\"Jack\");\n        jedis.hset(\"user:2\",\"name\",\"Rose\");\n        jedis.hset(\"user:3\",\"name\",\"SmallBoat\");\n        jedis.hset(\"user:1\",\"age\",\"21\");\n        jedis.hset(\"user:2\",\"age\",\"18\");\n        jedis.hset(\"user:3\",\"age\",\"18\");\n        Map<String, String> map = jedis.hgetAll(\"user:3\");\n        System.out.println(map);\n    }\n\n    // 释放资源\n    @AfterEach\n    void tearDown(){\n        if (jedis != null){\n            jedis.close();\n        }\n    }\n}\n```\n<a name=\"Tj3JO\"></a>\n### 5.3 SpringDataRedis快速入门\n<a name=\"z49za\"></a>\n#### 5.3.1 SpringDataRedis简介\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis。<br />**特性：**\n\n- 提供了对不同Redis的Java客户端的整合（包括Jedis和Lettuce）；\n- 提供了RedisTemplate统一API来操作Redis；\n- 支持Redis的发布订阅模型；\n- 支持Redis哨兵和Redis集群；\n- 支持基于Lettuce的响应式编程；\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化；\n- 支持基于Redis的JDKCollection实现。\n\n**redisTemplate的各种API：**\n\n| API | 返回值类型 | 说明 |\n| :-: | :-: | :-: |\n| redisTemplate.opsForValue() | ValueOperations | 操作String类型数据 |\n| redisTemplate.opsForHash() | HashOperations | 操作Hash类型数据 |\n| redisTemplate.opsForList() | ListOperations | 操作List类型数据 |\n| redisTemplate.opsForSet() | SetOperations | 操作Set类型数据 |\n| redisTemplate.opsForzSet() | ZSetOperations | 操作SortedSet类型数据 |\n\n<a name=\"KgQPI\"></a>\n#### 5.3.2 示例\n\n- 引入相关依赖\n```xml\n<!--redis依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--common-pool-->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n<!--Jackson依赖-->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n<!--lombok-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n- 在yaml文件中配置redis\n```yaml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n    password: 1a2b3c\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        min-idle: 0\n        max-wait: 100ms\n```\n\n- 测试\n```java\n// 因为有了SpringBoot自动装配的加持，在使用的时候直接注入即可\n@Autowired\nprivate RedisTemplate redisTemplate;\n\n@Test\nvoid stringTest(){\n    redisTemplate.opsForValue().set(\"username\", \"SmallBoat\");\n    String username = (String) redisTemplate.opsForValue().get(\"username\");\n    System.out.println(username);\n}\n```\n<a name=\"qh8Dg\"></a>\n#### 5.3.3 序列化\nRedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果类似于：`\\xAC\\xED\\x00\\x05t\\x00\\x06\\xE5\\xBC\\xA0\\xE4\\xB8\\x89`<br />我们可以看到，如果使用默认的序列化工具，不仅可读性差，而且还浪费内存。于是我们需要自定义RedisTemplate的序列化方式。<br />**自定义序列化：**\n\n- 编写Redis配置类\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建RedisTemplate对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n        // 创建JSON序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\n                new GenericJackson2JsonRedisSerializer();\n        // 设置Key的序列化\n        template.setKeySerializer(RedisSerializer.string());\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置Value的序列化\n        template.setValueSerializer(jsonRedisSerializer);\n        template.setHashValueSerializer(jsonRedisSerializer);\n        // 返回\n        return template;\n    }\n}\n```\n\n- 得到的存储结果\n```json\n{\n  \"@class\": \"com.cxc.pojo.User\",\n  \"name\": \"SmallBoat\",\n  \"age\": 18\n}\n```\n> 由于我们使用了Json序列化代替jdk序列化，当我们使用自定义序列化后，整体可读性得到提升，且能将Java对象自动的序列化为JSON字符串，并且查询时还能自动把JSON反序列化为Java对象。但是，在存数据时会记录序列化时对应的Class名称（为了查询时实现自动反序列化），这会带来额外的内存开销。因此，再介绍一种方案：StringRedisTemplate\n\n<a name=\"kGAlK\"></a>\n#### 5.3.4 StringRedisTemplate\n为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，这样就只能存储String类型的key和value。所以，当需要存储Java对象时，需要手动完成对象的序列化和反序列化。因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis。<br />由于这种用法比较普遍，于是乎SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。<br />**StringRedisTemplate源码：**\n```java\npublic class StringRedisTemplate extends RedisTemplate<String, String> {\n    public StringRedisTemplate() {\n        this.setKeySerializer(RedisSerializer.string());\n        this.setValueSerializer(RedisSerializer.string());\n        this.setHashKeySerializer(RedisSerializer.string());\n        this.setHashValueSerializer(RedisSerializer.string());\n    }\n\n    public StringRedisTemplate(RedisConnectionFactory connectionFactory) {\n        this();\n        this.setConnectionFactory(connectionFactory);\n        this.afterPropertiesSet();\n    }\n\n    protected RedisConnection preProcessConnection(RedisConnection connection, boolean existingConnection) {\n        return new DefaultStringRedisConnection(connection);\n    }\n}\n```\n有了StringRedisTemplate，我们就不需要再进行自定义序列化了，而是直接进行使用。\n\n- 测试\n```java\n// 使用StringRedisTemplate测试String\n@Test\nvoid stringTest() throws JsonProcessingException {\n    // 创建对象\n    User user = new User(\"SmallBoat\", 18);\n    // 手动序列化\n    String userjson = mapper.writeValueAsString(user);\n    // 写入数据\n    stringRedisTemplate.opsForValue().set(\"userjson\", userjson);\n    // 获取数据\n    String getUserjson = stringRedisTemplate.opsForValue().get(\"userjson\");\n    // 手动反序列化\n    User getUser = mapper.readValue(getUserjson, User.class);\n    System.out.println(getUser);\n}\n```\n\n- 存储结果\n```json\n{\n  \"name\": \"SmallBoat\",\n  \"age\": 18\n}\n```\n\n","categories":["Redis"]},{"title":"King of Bots项目总结","url":"/2024/02/27/King of Bots项目总结/","content":"\n<a name=\"xvTck\"></a>\n## 1. 项目规划\n- 使用其后端分离方式完成本项目。其中，前端使用`Vue3`完成，后端使用`SpringBoot2`完成。\n\n![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_235f9eadd9-1.项目规划.png)\n\n- 技术栈：\n\n| **技术** | **说明** |\n| :-: | :-: |\n| SpringBoot | 容器+MVC框架 |\n| mysql | 关系型数据库 |\n| JWT | 登录支持 |\n| SpringSecurity | 验证和授权框架 |\n| Redis | 缓存数据库 |\n| Lombok | 简化对象封装工具 |\n| MyBatisPlus | ORM框架 |\n| MicroService（SpringCloud） | 微服务 |\n\n- 项目（游戏）设计逻辑：\n\n![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_1d7f8b70d9-1.2.项目逻辑设计.png)\n<a name=\"P2aiK\"></a>\n## 2. 环境配置与项目创建\n<a name=\"ue2bM\"></a>\n### 2.1 项目设计\n\n- 名称：`King Of Bots`\n- 项目包含的模块\n- PK模块：匹配界面（微服务）、实况直播界面（`WebSocket`协议）\n   - 对局列表模块：对局列表界面、对局录像界面\n   - 排行榜模块：`Bot`排行榜界面\n   - 用户中心模块：注册界面、登录界面、我的`Bot`界面、每个`Bot`的详情界面\n- 前后端分离模式\n   - `SpringBoot`实现后端\n   - `Vue3`实现`Web`端和`AcApp`端\n   <a name=\"VPYFM\"></a>\n### 2.2 配置git环境\n\n1. 安装`Git Bash`：[https://gitforwindows.org/](https://gitforwindows.org/)\n2. 进入家目录生成秘钥：执行命令`ssh-keygen`\n3. 将`id_rsa.pub`的内容复制到`github`上\n<a name=\"UX9s1\"></a>\n### 2.3 创建项目前后端\n\n- 后端：使用`Spring Initilizr`创建后端，使用`2.3.7REALESE`版本，添加`SpringBoot Web Starter`插件。\n- 前端：使用`Vue cli`脚手架创建项目，添加`Vue Router`和`VueX`插件，添加`BootStrap`与`jquery`依赖。（`Vue ui`创建前端有点奇怪的`bug`，选择位置时不选择默认盘符下的位置就报错，先在该盘符创建再移动到目标盘符去）\n<a name=\"VBmjE\"></a>\n## 3. 创建前端基础页面\n<a name=\"chK2N\"></a>\n### 3.1 创建导航栏及页面\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_2aa880d4d9-3.1创建导航栏.png)<br />通过创建各个页面的`view`，主要包括`error, pk, ranklist, record, user-bot`页面。然后在导航栏中通过`router`进行跳转。<br />通过如下方式实时计算当前页面位于哪个部分，以便于高亮导航栏中的对应部分：\n```javascript\nconst route = useRoute();\nlet route_name = computed(() => route.name)\nreturn {\n  route_name\n}\n```\n<a name=\"cfwHz\"></a>\n### 3.2 创建游戏地图\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_301badf5d9-3.2创建游戏地图.png)<br />首先创建游戏地图基类`AcGameObject`，然后通过继承该类实现`GameMap`游戏地图渲染类。\n\n- 在`AcGameObject`中，通过`requestAnimationFrame(step)`递归实现每`60`帧（因显示器而异）的实时渲染游戏画面。\n- 在`GameMap`中，先将游戏背景（绿布）渲染出来，然后创建四周墙壁，再随机生成内部墙体障碍物，每生成一种方案，通过`Flood Fill`算法检验左下角与右上角的连通性，如果不连通则重新生成。\n\n**注意：** 在后期会将生成地图的逻辑放到后端（前端只负责渲染，暂时放在前端便于当前调试），避免两名用户中有人修改前端代码造成不公平的情况。与此同时，生成的地图为$13 \\times 14$的布局，并确保其是中心对称的。\n> 设计成$13 \\times 14$主要是为了避免两条蛇头能同时到达一个点的情况（平局），避免造成对优势方不利的情况。\n> 解释：若设计为$13 \\times 13$，则刚开始两条蛇的蛇头坐标为`(1, 13), (13, 1)`，双方每走一步，横纵坐标之和的变化都是相同的（偶、奇、偶、奇……），设计成$13 \\times 14$则刚开始两蛇头的坐标为`(1, 14), (13, 1)`，则双方每走一步横纵坐标之和不可能相等，意味着双方的蛇头不可能在同一时间进入同一个格子。\n\n<a name=\"BUfE6\"></a>\n### 3.3 创建蛇类\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_35da8150d9-3.3创建蛇类.png)在创建蛇类前，先要创建蛇的身体类（即`Cell`类）：\n```javascript\nexport class Cell {\n  constructor(r, c) {\n    // 格子坐标\n    this.r = r; \n    this.c = c;\n    \n    this.x = c + 0.5; // 圆心横坐标\n    this.y = r + 0.5; // 圆心纵坐标\n  }\n}\n```\n在定义蛇类时，需要定义其状态、当前移动方向、眼睛的偏移方向。蛇的移动方式为每移动一步，蛇头向前一步，蛇尾砍掉，身体保持不同（前10步，蛇尾不用移动，每次移动只蛇头向前移动即可，长度加1，之后每3步增长一格）。\n> 蛇的身体为一个个圆形`Cell`组成，因此，每两个`Cell`间用长方形进行填充，这样就只有头和尾的`Cell`有圆弧，看起来会比较正常。\n\n在移动时，通过蛇类中的函数设置当前步的前进方向，然后在地图类中进行监听用户操作（后续接入代码操作后，也将调用此函数设置蛇蛇的移动方向）：\n```javascript\nset_direction(d) {\n  this.direction = d;\n}\n```\n然后判断蛇的存活状态（在地图类中进行判断，而不是在蛇类中判断）：\n```javascript\ncheck_valid(cell) {  // 检测目标位置是否合法：没有撞到两条蛇的身体和障碍物\n  for (const wall of this.walls) {\n      if (wall.r === cell.r && wall.c === cell.c)\n          return false;\n  }\n  for (const snake of this.snakes) {\n      let k = snake.cells.length;\n      if (!snake.check_tail_increasing()) {  // 当蛇尾会前进的时候，蛇尾不用判断\n          k -- ;\n      }\n      for (let i = 0; i < k; i ++ ) {\n          if (snake.cells[i].r === cell.r && snake.cells[i].c === cell.c)\n              return false;\n      }\n  }\n  return true;\n}\n```\n<a name=\"KM6d4\"></a>\n## 4. 配置MySql与实现注册登录模块\n在`pom.xml`文件中添加如下依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.24</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <version>8.0.33</version>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.2</version>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-generator</artifactId>\n    <version>3.5.3</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n    <version>3.1.5</version>\n</dependency>\n```\n<a name=\"IdcIv\"></a>\n### 4.1 数据库配置\n数据库使用`MySql8.0`版本，并创建`user`表。`YAML`相关配置如下：\n```yaml\n# 配置数据库连接\nspring:\n  datasource:\n    username: root\n    password: xxxxxxx\n    url: jdbc:mysql://localhost:3306/kob?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n<a name=\"qaDya\"></a>\n### 4.2 登录校验模块\n<a name=\"KX9uz\"></a>\n#### 4.2.1 基本登录功能\n登录模块利用`SpringSecurity`自带的功能即可完成。通过配置`SecurityConfig`配置类、再实现`UserDetailsService, UserDetails`两个接口即可。在`UserDetailsServiceImpl`中先校验用户是否存在，再返回一个**包含用户信息**的`UserDetailsImpl`对象用于校验用户合法性（包括密码校验、用户是否失效、用户是否被锁等等）。\n<a name=\"StVor\"></a>\n#### 4.2.2 引入[JWT](https://www.yuque.com/cxc_lhl/iupfzc/krkag1qcw9gl91u4#xFIlJ)认证\n为了使用`jwt`认证，先在`pom.xml`文件中引入一下依赖：\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>0.11.2</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>0.11.2</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.11.2</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n1. 实现`JwtUtil`类，用于生成和解析`jwt`。\n2. 实现`JwtAuthenticationTokenFilter`类，用于验证用户传递过来的`jwt`，验证成功后，当前用户的信息将会被注入上下文中。\n3. 修改`SecurityConfig`放行`token`及`register`请求。\n```java\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.csrf()\n        .disable()\n        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n        .authorizeRequests()\n        .antMatchers(\"/user/account/token/\", \"/user/account/register/\").permitAll()\n        .antMatchers(HttpMethod.OPTIONS).permitAll()\n        .anyRequest().authenticated();\n    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n}\n```\n\n- 再分别创建三个接口`/user/account/token/, /user/account/info/, /user/account/register/`用于获取`token`、获取用户信息、用户注册。\n> 在调试过程中，发现一个需要注意的细节，在浏览器中复制生成的`token`时，需要将其点开再复制，因为当位置不够时，中间很长一部分会议省略号形式展示，复制后根本无法发出请求。\n\n<a name=\"JrIwT\"></a>\n### 4.3 前端注册页面实现\n注册页面与登录页面极其类似，直接复制过来修改一下即可。<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_3991b228d9-4.3前端注册页面实现.png)\n<a name=\"DuFMp\"></a>\n### 4.4 将jwt信息存进localStorage\n每当用户登录成功时，我们就将其获取到的`jwt`存进`localStorage`中。\n```javascript\nlocalStorage.setItem(\"jwt\", resp.token)\n```\n然后在每次路由跳转到登录页时，闲取出`localStorage`中的`jwt`信息，然后发送获取用户信息的请求以校验当前的`jwt`是否过期。\n```javascript\nconst jwt = localStorage.getItem(\"jwt\")\nif (jwt) {\n  store.commit(\"updateToken\", jwt)\n  store.dispatch(\"getInfo\", {\n    success() {\n      router.push({name: \"home\"})\n      store.commit(\"updatePullingInfo\", false)\n    },\n    error() {\n      store.commit(\"updatePullingInfo\", false)\n    }\n  })\n} else {\n  store.commit(\"updatePullingInfo\", false)\n}\n```\n如果成功，则路由直接跳转到首页，否则显示登录页让用户重新登录。\n> 其中，`updatePullingInfo`是`user.js`中的用于修改全局变量`pulling_info`的函数，`pulling_info`用于控制当前是否处于获取用户信息状态（避免此时登录页会闪一下的问题），当用户信息拉取完毕时，成功就跳转首页，失败就正常显示登录页。\n\n```javascript\nupdatePullingInfo(state, pulling_info) {\n    state.pulling_info = pulling_info\n}\n```\n<a name=\"lVLd6\"></a>\n## 5. 个人中心（我的Bot）\n<a name=\"p2qBF\"></a>\n### 5.1 Bot的CRUD（后端）\n`Bot`的`CRUD`是一些比较重复性的工作，此处以`add`举例。\n```java\n@Override\npublic Map<String, String> add(Map<String, String> botData) {\n    UsernamePasswordAuthenticationToken authenticationToken =\n            (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();\n    UserDetailsImpl loginUser = (UserDetailsImpl) authenticationToken.getPrincipal();\n    User user = loginUser.getUser();\n\n    String title = botData.get(\"title\");\n    String description = botData.get(\"description\");\n    String content = botData.get(\"content\");\n\n    Map<String, String> map = new HashMap<>();\n\n    if (null == title || title.length() == 0) {\n        map.put(\"error_massage\", \"Bot标题不能为空！\");\n        return map;\n    }\n    if (title.length() > 50) {\n        map.put(\"error_message\", \"Bot标题长度不能超过50！\");\n        return map;\n    }\n\n    // 描述可以为空\n    if (null == description || description.length() == 0) {\n        description = \"这个用户很懒，什么也没写~\";\n    }\n    if (description.length() > 200) {\n        map.put(\"error_message\", \"Bot描述长度不能超过200！\");\n        return map;\n    }\n\n    if (null == content || content.length() == 0) {\n        map.put(\"error_message\", \"Bot代码不能为空！\");\n        return map;\n    }\n    if (content.length() > 10000) {\n        map.put(\"error_message\", \"Bot代码长度不能超过10000！\");\n        return map;\n    }\n\n    // 校验一下该 bot的标题和代码，是否已创建过\n    QueryWrapper<Bot> botQueryWrapper = new QueryWrapper<>();\n    botQueryWrapper.eq(\"user_id\", user.getId());\n    botQueryWrapper.and(wrapper -> wrapper.eq(\"content\", content).or().eq(\"title\", title));\n    Long count = botMapper.selectCount(botQueryWrapper);\n    if (count > 0) {\n        map.put(\"error_message\", \"该Bot已经被你创建过啦，创建一个新的吧！\");\n        return map;\n    }\n\n    Date now = new Date();\n    System.out.println(now);\n    Bot bot = new Bot(null, user.getId(), title, description, content, DEFAULT_RATING, now, now, null);\n    System.out.println(bot);\n\n    int state = botMapper.insert(bot);\n    if (state > 0) {\n        map.put(\"error_message\", \"success\");\n        return map;\n    }\n\n    map.put(\"error_message\", \"创建失败！\");\n    return map;\n}\n```\n`CRUD`部分基本都类似，主要是一些限制条件要限制好，不然前端代码如果被修改，数据安全性得不到保证。\n> 正如 yxc 所说，前端防君子，后端防小人！\n> 这里创建Bot类时有个需要注意的地方，时区一定要通过`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"Asia/Shanghai\")`规定好，不然会出现前后端时间相差8小时的情况（具体可参考[使用@JsonFormat注解前后端时间相差8小时](https://blog.csdn.net/m0_65894434/article/details/134997740)）。\n\n<a name=\"bpIYU\"></a>\n### 5.2 Bot的CRUD（前端）\n前端实现`CRUD`比较容易，使用`BootStrap`中的样式即可。唯一麻烦点的是引入`ace`代码编辑器。\n\n- **我的Bot页面：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_3e2a0c6bd9-5.2.1我的bot页面.png)\n\n- **创建Bot的**`Modal`**框：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_43f08b5cd9-5.2.2创建bot的modal框.png)\n\n- **修改Bot的**`Modal`**框：**\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_4684fd31d9-5.2.3修改bot的modal框.png)\n> 注意：在引入`ace`代码编辑器时，在调试时可能会因为浏览器的问题而导致代码高亮、自动提示等出现不符合预期的问题，切换浏览器尝试一下。\n\n<a name=\"D2Q1e\"></a>\n## 6. 微服务：实现匹配系统\n<a name=\"p1O0M\"></a>\n### 6.1 后端（backend）集成WebSocket\n\n1. 在`pom.xml`文件中添加依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n    <version>2.7.2</version>\n</dependency>\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>2.0.11</version>\n</dependency>\n```\n\n2. 添加`WebSocketConfig`配置类：\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\n@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n\n        return new ServerEndpointExporter();\n    }\n}\n```\n\n3. 添加`WebSocketServer`类（核心功能）：\n```java\npackage com.kob.backend.comsumer;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.kob.backend.comsumer.utils.Game;\nimport com.kob.backend.comsumer.utils.JwtAuthentication;\nimport com.kob.backend.mapper.UserMapper;\nimport com.kob.backend.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@ServerEndpoint(\"/websocket/{token}\")  // 不要以'/'结尾\npublic class WebSocketServer {\n\n    private Session session;\n    private User user;\n    // 记录全局的连接信息\n    private static final ConcurrentHashMap<Integer, WebSocketServer> users = new ConcurrentHashMap<>();\n\n    private static final CopyOnWriteArraySet<User> matchpool = new CopyOnWriteArraySet<>();\n\n    private static UserMapper userMapper;\n\n    @Autowired\n    public void setUserMapper(UserMapper userMapper) {\n        WebSocketServer.userMapper = userMapper;\n    }\n\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"token\") String token) throws IOException {\n        // 建立连接\n        this.session = session;\n        Integer userId = JwtAuthentication.getUserId(token);\n        this.user = userMapper.selectById(userId);\n\n        if (null != this.user) {\n            users.put(userId, this);\n            System.out.println(\"connected!\");\n        } else {\n            this.session.close();\n        }\n\n        System.out.println(users);\n\n    }\n\n    @OnClose\n    public void onClose() {\n        // 关闭链接\n        System.out.println(\"disconnected!\");\n        if (null != this.user) {\n            users.remove(this.user.getId());\n            matchpool.remove(this.user);\n        }\n    }\n    \n    private void startMatching() {\n        System.out.println(\"start_matching!\");\n        matchpool.add(this.user);\n        // 暂时实现简单匹配逻辑\n        while (matchpool.size() >= 2) {\n            Iterator<User> it = matchpool.iterator();\n            User a = it.next(), b = it.next();\n            matchpool.remove(a);\n            matchpool.remove(b);\n\n            Game game = new Game(13, 14, 20);\n            game.createMap();\n\n            JSONObject respA = new JSONObject();\n            respA.put(\"event\", \"start-matching\");\n            respA.put(\"opponent_username\", b.getUsername());\n            respA.put(\"opponent_photo\", b.getPhoto());\n            respA.put(\"gameMap\", game.getG());\n            users.get(a.getId()).sendMessage(respA.toJSONString());\n\n            JSONObject respB = new JSONObject();\n            respB.put(\"event\", \"start-matching\");\n            respB.put(\"opponent_username\", a.getUsername());\n            respB.put(\"opponent_photo\", a.getPhoto());\n            respB.put(\"gameMap\", game.getG());\n            users.get(b.getId()).sendMessage(respB.toJSONString());\n        }\n    }\n\n    private void stopMatching() {\n        System.out.println(\"stop_matching!\");\n        matchpool.remove(this.user);\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        // 从 Client 接收消息\n        System.out.println(\"receive message!\");\n        JSONObject data = JSON.parseObject(message);\n        String event = data.getString(\"event\");\n        \n        if (\"start-matching\".equals(event)) {\n            startMatching();\n        } else if (\"stop-matching\".equals(event)) {\n            stopMatching();\n        }\n    }\n\n    public void sendMessage(String message) {\n        // 从 server 发送消息\n        synchronized (this.session) {\n            try {\n                this.session.getBasicRemote().sendText(message);\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n}\n\n```\n\n4. 修改`SecurityConfig`放行`\"/websocket/**\"`请求：\n```java\n@Override\npublic void configure(WebSecurity web) throws Exception {\n    web.ignoring().antMatchers(\"/websocket/**\");\n}\n```\n\n5. 将前端生成地图的逻辑放到后端：\n```java\npackage com.kob.backend.comsumer.utils;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Game {\n    /**\n     * 游戏地图行数\n     */\n    private final Integer rows;\n    /**\n     * 游戏地图列数\n     */\n    private final Integer cols;\n    /**\n     * 地图内部墙体障碍物数量\n     */\n    private final Integer innerWallsCount;\n    /**\n     * 游戏地图（0 表示草地，1 表示墙体障碍物）\n     */\n    private final int[][] g;\n\n    private final static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\n    public Game(Integer rows, Integer cols, Integer innerWallsCount) {\n        this.rows = rows;\n        this.cols = cols;\n        this.innerWallsCount = innerWallsCount;\n        this.g = new int[rows][cols];\n    }\n\n    public int[][] getG() {\n        return g;\n    }\n\n    // Flood Fill 校验地图连通性\n    public boolean checkConnectivity(int sx, int sy, int tx, int ty) {\n        if (sx == tx && sy == ty) return true;\n        // 表示已经走过\n        g[sx][sy] = 1;\n        for (int d = 0; d < 4; d ++) {\n            int a = sx + dx[d], b = sy + dy[d];\n            if (a >= 0 && a < this.rows && b >= 0 && b < this.cols && g[a][b] == 0) {\n                if (checkConnectivity(a, b, tx, ty)) {\n                    // 恢复现场\n                    g[sx][sy] = 0;\n                    return true;\n                }\n            }\n        }\n        // 即使校验失败也要恢复现场\n        g[sx][sy] = 0;\n        return false;\n\n    }\n\n    // 画地图\n    private boolean draw() {\n        // 初始化地图\n        for (int i = 0; i < g.length; i ++) {\n            Arrays.fill(g[i], 0);\n        }\n        // 生成四周墙体障碍物\n        for (int r = 0; r < this.rows; r ++) {\n            g[r][0] = g[r][this.cols - 1] = 1;\n        }\n        for (int c = 0; c < this.cols; c ++) {\n            g[0][c] = g[this.rows - 1][c] = 1;\n        }\n        // 生成地图内部随机墙体障碍物\n        Random random = new Random();\n        for (int i = 0; i < this.innerWallsCount >> 1; i ++) {\n            for (int j = 0; j < 1000; j ++) {\n                int r = random.nextInt(this.rows);\n                int c = random.nextInt(this.cols);\n                if (g[r][c] == 1 || g[this.rows - 1 - r][this.cols - 1 - c] == 1) {\n                    continue;\n                }\n                if (r == this.rows - 2 && c == 1 || r == 1 && c == this.cols - 2) {\n                    continue;\n                }\n                g[r][c] = g[this.rows - 1 - r][this.cols - 1 - c] = 1;\n                break;\n            }\n        }\n        // 校验连通性\n        return checkConnectivity(this.rows - 2, 1, 1, this.cols - 2);\n    }\n\n    public void createMap() {\n        // 循环 1000 次，直到成功生成合法地图\n        for (int i = 0; i < 1000; i ++) {\n            if (draw()) {\n                break;\n            }\n        }\n    }\n}\n```\n<a name=\"KNr6s\"></a>\n### 6.2 前端实现匹配界面\n\n1. 前端实现`pk`类，在其中维护当前一次的`pk`需要的变量，其中利用`status`变量动态切换匹配和游戏界面（`status: \"matching\", // matching 表示匹配界面，playing 表示对战界面`）。\n```javascript\nexport default {\n    state: {\n        status: \"matching\",  // matching 表示匹配界面，playing 表示对战界面\n        socket: null,\n        opponent_username: \"\",\n        opponent_photo: \"\",\n        gameMap: null,\n    },\n    getters: {\n    },\n    mutations: {\n        updateSocket(state, socket) {\n            state.socket = socket;\n        },\n        updateOpponent(state, opponent) {\n            state.opponent_username = opponent.username;\n            state.opponent_photo = opponent.photo;\n        },\n        updateStatus(state, status) {\n            state.status = status;\n        },\n        updateGameMap(state, gameMap) {\n            state.gameMap = gameMap;\n        }\n    },\n    actions: {\n    },\n    modules: {\n    }\n}\n\n```\n\n2. 除了之前实现的游戏界面，还需要实现一个匹配界面。匹配界面相对简单，和游戏地图界面类似，两个头像，一个按钮。\n\n> 玩家1：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_528bdb66d9-6.2.2玩家1.png)\n\n> 玩家2：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_57338a40d9-6.2.2玩家2.png)\n\n> 匹配成功：\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_4dac59a0d9-6.2.2匹配成功.png)\n\n3. 实现`PkIndexView`页面。之前该页面只有游戏地图，现在开始时需要先匹配，匹配成功后，需要将匹配界面关掉，切换为游戏地图页面。\n```vue\n<template>\n  <PlayGround v-if=\"$store.state.pk.status === 'playing'\" />\n  <MatchGround v-if=\"$store.state.pk.status === 'matching'\" />\n</template>\n\n<script>\nimport PlayGround from '../../components/PlayGround.vue'\nimport MatchGround from '../../components/MatchGround.vue'\nimport { onMounted, onUnmounted } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  components: {\n    PlayGround,\n    MatchGround,\n  },\n  setup() {\n    const store = useStore();\n    const socketUrl = `ws://127.0.0.1:8090/websocket/${store.state.user.token}/`;\n\n    let socket = null;\n    onMounted(() => {\n      store.commit(\"updateOpponent\", {\n        username: \"我的对手\",\n        photo: \"https://cdn.acwing.com/media/article/image/2022/08/09/1_1db2488f17-anonymous.png\",\n      })\n      socket = new WebSocket(socketUrl);\n\n      socket.onopen = () => {\n        console.log(\"connected!\");\n        store.commit(\"updateSocket\", socket);\n      }\n\n      socket.onmessage = msg => {\n        const data = JSON.parse(msg.data);\n        if (data.event === \"start-matching\") {  // 匹配成功\n          store.commit(\"updateOpponent\", {\n            username: data.opponent_username,\n            photo: data.opponent_photo,\n          });\n          setTimeout(() => {\n            store.commit(\"updateStatus\", \"playing\");\n          }, 2000);\n          store.commit(\"updateGameMap\", data.gameMap);\n        }\n      }\n\n      socket.onclose = () => {\n        console.log(\"disconnected!\");\n      }\n    });\n\n    onUnmounted(() => {\n      socket.close();\n      store.commit(\"updateStatus\", \"matching\");\n    })\n  }\n}\n</script>\n\n<style scoped>\n</style>\n```\n> 需要注意的是，与`http`协议类似，`socketUrl`的写法将`http`换为`ws`即可。\n\n匹配成功后，双方的地图均是从后端获取，因此实现了两名玩家的地图一致性。<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5ad67da0d9-6.2.3匹配成功后1.png)![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5d39caf8d9-6.2.3匹配成功后2.png)\n<a name=\"m4d1x\"></a>\n### 6.3 实现匹配系统的微服务（matchingsystem）\n新建一个`backendCloud` `maven`项目，引入`springcloud`依赖，在该项目下面新增两个模块（`backend, matchingsystem`），将先前的`backend`复制过来，引入并配置`restTemplate`。<br />**匹配系统思路：** 每次有匹配请求，`backend`发送添加用户请求到`matchingsystem`，`matchingsystem`将该用户添加到待匹配列表中。`matchingsystem`会在项目启动时开启`matchingPool`线程，并每秒尝试进行匹配列表中的玩家，同时每秒会增加玩家等待时间，时间越大，那么匹配该玩家时，可接受的天梯分差也将越大。\n\n- 在`webSocketServer`中实现`startMatching`函数调用匹配系统进行匹配：\n```java\nprivate void startMatching() {\n    System.out.println(\"start_matching!\");\n    MultiValueMap<String, String> playerData = new LinkedMultiValueMap<>();\n    playerData.add(\"userId\", this.user.getId().toString());\n    playerData.add(\"rating\", this.user.getRating().toString());\n\n    // ADD_PLAYER_URL = \"http://127.0.0.1:8089/player/add/\"\n    restTemplate.postForObject(ADD_PLAYER_URL, playerData, String.class);\n}\n```\n\n- 匹配系统`MatchingPool`类核心代码：\n```java\n@Override\npublic void run() {\n    while (true) {\n        try {\n            Thread.sleep(1000);\n            lock.lock();\n            try {\n                increaseWaitedTime();\n                matchPlayers();\n            } finally {\n                lock.unlock();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n- 在`matchingsystem`项目启动时开启`MatchingPool`线程：\n```java\n@SpringBootApplication\npublic class MatchingSystemApplication {\n    public static void main(String[] args) {\n        MatchingServiceImpl.matchingPool.start();\n        SpringApplication.run(MatchingSystemApplication.class, args);\n    }\n}\n```\n\n- 一旦匹配成功一对玩家，就会调用`MatchingPool`的`sendResult`方法通知`backend`以创建当前游戏：\n```java\n// 返回匹配成功结果\nprivate void sendResult(Player a, Player b) {\n    System.out.println(\"matched: \" + a + \" \" + b);\n    MultiValueMap<String, String> gameData = new LinkedMultiValueMap<>();\n    gameData.add(\"aId\", a.getUserId().toString());\n    gameData.add(\"bId\", b.getUserId().toString());\n    // START_GAME_URL = \"http://127.0.0.1:8090/pk/startGame/\"\n    restTemplate.postForObject(START_GAME_URL, gameData, String.class);\n}\n```\n> `startGame`函数会在下一部分介绍。\n\n<a name=\"L5bbR\"></a>\n### 6.4 实现后端游戏逻辑\n在`WebSocketServer`中调用实现函数`startGame`以便匹配系统完成匹配时进行调用以开始游戏：\n```java\npublic static void startGame(Integer aId, Integer bId) {\n    User a = userMapper.selectById(aId);\n    User b = userMapper.selectById(bId);\n\n    Game game = new Game(13, 14, 20, aId, bId);\n    game.createMap();\n    game.start();\n    if (null != users.get(aId)) {\n        users.get(aId).game = game;\n    }\n    if (null != users.get(bId)) {\n        users.get(bId).game = game;\n    }\n\n    JSONObject respGame = new JSONObject();\n    respGame.put(\"a_id\", game.getPlayerA().getId());\n    respGame.put(\"a_sx\", game.getPlayerA().getSx());\n    respGame.put(\"a_sy\", game.getPlayerA().getSy());\n    respGame.put(\"b_id\", game.getPlayerB().getId());\n    respGame.put(\"b_sx\", game.getPlayerB().getSx());\n    respGame.put(\"b_sy\", game.getPlayerB().getSy());\n    respGame.put(\"map\", game.getG());\n\n    JSONObject respA = new JSONObject();\n    respA.put(\"event\", \"start-matching\");\n    respA.put(\"opponent_username\", b.getUsername());\n    respA.put(\"opponent_photo\", b.getPhoto());\n    respA.put(\"game\", respGame);\n    // 给玩家A客户端返回结果\n    if (null != users.get(aId)) {\n        users.get(aId).sendMessage(respA.toJSONString());\n    }\n\n    JSONObject respB = new JSONObject();\n    respB.put(\"event\", \"start-matching\");\n    respB.put(\"opponent_username\", a.getUsername());\n    respB.put(\"opponent_photo\", a.getPhoto());\n    respB.put(\"game\", respGame);\n    // 给玩家B客户端返回结果\n    if (null != users.get(bId)) {\n        users.get(bId).sendMessage(respB.toJSONString());\n    }\n}\n```\n主要的游戏逻辑在`Game`类中，每次等待用户输入，然后校验操作时候合法，如果合法，则将两名玩家的操作广播给双方的客户端。如果有玩家操作不合法或者有玩家五秒内未进行输入，则游戏结束，向两名玩家广播游戏结果。<br />`Game`中的核心代码如下：\n```java\n@Override\npublic void run() {\n    for (int i = 0; i < 1000; i ++) {\n        if (nextStep()) {\n            judge();\n            if (\"playing\".equals(status)) {\n                sendMove();\n            } else {\n                sendResult();\n                break;\n            }\n        } else {\n            status = \"finished\";\n            lock.lock();\n            try {\n                if (null == nextStepA && null == nextStepB) {\n                    winner = \"all\";\n                } else if (null == nextStepB) {\n                    winner = \"A\";\n                } else {\n                    winner = \"B\";\n                }\n            } finally {\n                lock.unlock();\n            }\n            sendResult();\n            break;\n        }\n    }\n}\n```\n<a name=\"QHwmW\"></a>\n## 7. 微服务：Bot代码的执行（botrunningsystem）\n\n- 添加依赖：\n```xml\n<dependency>\n    <groupId>org.jooq</groupId>\n    <artifactId>joor-java-8</artifactId>\n    <version>0.9.14</version>\n</dependency>\n```\n\n- 配置`restTemplate`与`security`：\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"/bot/add/\").hasIpAddress(\"127.0.0.1\")\n                .antMatchers(HttpMethod.OPTIONS).permitAll()\n                .anyRequest().authenticated();\n    }\n}\n```\n每次后端（`backend`）会调用`bot/add/`接口往`bots`队列中添加`Bot`：\n```java\npublic void addBot(Integer userId, String botCode, String input) {\n    lock.lock();\n    try {\n        bots.add(new Bot(userId, botCode, input));\n        // 当 bot 添加结束，需要唤起其他线程进行消费\n        condition.signalAll();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n`botPool`的核心代码（这里相当于手动实现了一个消息队列）：\n```java\nprivate void consume(Bot bot) {\n    Consumer consumer = new Consumer();\n    consumer.startTimeout(2000, bot);\n}\n\n@Override\npublic void run() {\n    while (true) {\n        lock.lock();\n        if (bots.isEmpty()) {\n            try {\n                // 当队列中没有等待消费的Bot时，让线程等待，当有新添加的Bot时，会被condition.signalAll();唤醒\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break;\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            Bot bot = bots.poll();\n            lock.unlock();\n            // consume 可能会执行几秒钟，需要先解锁\n            consume(bot);\n        }\n    }\n}\n```\n而在`Consumer`中，需要控制每个`Bot`的执行时间：\n```java\npublic void startTimeout(long timeout, Bot bot) {\n    this.bot = bot;\n    this.start();\n    try {\n        this.join(timeout);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } finally {\n        // 最多等待 timeout 秒，然后中断\n        this.interrupt();\n    }\n}\n```\n`Consumer`中的核心代码：\n```java\n@Override\npublic void run() {\n    UUID uuid = UUID.randomUUID();\n    String uid = uuid.toString().substring(0, 8);\n    // 需要保障每次的类名不一样，否则只编译一次\n    Supplier<Integer> botInterface = Reflect.compile(\n            \"com.kob.botrunningsystem.utils.Bot\" + uid,\n            addUid(bot.getBotCode(), uid)\n    ).create().get();\n    // 将输入写入文件以便后续扩展（后期可以在docker中运行，就需要从文件中读取输入）\n    File file = new File(\"input.txt\");\n    try (PrintWriter fout = new PrintWriter(file)) {\n        fout.println(bot.getInput());\n        fout.flush();\n    } catch (FileNotFoundException e) {\n        throw new RuntimeException(e);\n    }\n    // 执行Bot代码，获取结果\n    Integer direction = botInterface.get();\n    // 将Bot执行结果返回\n    MultiValueMap<String, String> data = new LinkedMultiValueMap<>();\n    data.add(\"userId\", bot.getUserId().toString());\n    data.add(\"direction\", direction.toString());\n\n    restTemplate.postForObject(RECEIVE_BOT_MOVE_URL, data, String.class);\n}\n```\n<a name=\"CKczF\"></a>\n## 8. 创建对战列表与排行榜页面\n这两部分主要的任务就是写好分页查询和分页展示。<br />分页查询直接利用`MybatisPlus`自带的分页工具即可。<br />分页配置：\n```java\n@Configuration\npublic class MybatisConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n}\n```\n其中，在对战列表中的`查看录像`功能，实现原理为：将数据库中记录的地图信息、用户双方的操作信息取出，在游戏地图中重新模拟一遍即可。<br />**对局列表：**<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_5ef9b2e6d9-8.对局列表.png)<br />**排行榜：**<br />![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_61f70baed9-8.排行榜.png)\n<a name=\"Wj4NC\"></a>\n## 9. 实现QQ三方登录\n> **基本思路：** 通过访问后端的`@GetMapping(\"/applyCode/\")`接口获取`apply_code`，同时后端生成了`state`存入`redis`中。然后前端再调用后端的`@GetMapping(\"/receiveCode/\")`接口。在该接口中，会拿着`state`与`redis`中的进行校验，然后获取`access_token`，拿到`access_token`之后获取用户的`openid`，然后判断该`openid`是否已经存在，如果存在直接生成`jwt`并返回前端，如果不存在，则说明是第一次申请`QQ`登录，需要获取`user_info`，再存入数据库并生成`jwt`返回。\n\n**官方授权流程图（**[**官方教程**](https://wiki.connect.qq.com/%e4%bd%bf%e7%94%a8authorization_code%e8%8e%b7%e5%8f%96access_token)**）：**<br />![](https://cdn.acwing.com/media/article/image/2024/03/03/126318_6f230017d9-9.官方授权流程图.png)\n<a name=\"lBIVC\"></a>\n### 9.1 前往腾讯开放平台完成资料审核\n\n- 先前往腾讯开放平台进行开发者人脸识别校验（[腾讯开放平台](https://app.open.qq.com/p/developer/team_manage/info)）\n> 需要先QQ登录，然后点击右上角的账户管理，根据提示微信扫码完成人脸识别校验。\n\n- QQ互联进行开发者资料审核（[开发者资料审核](https://connect.qq.com/devuser.html#/create/1/)）\n> 注：手持照片得用后置摄像头拍摄，前置摄像头有镜像功能，手指不能遮挡证件信息，一定要拍清楚，否则 会被驳回！\n\n<a name=\"dgV8H\"></a>\n### 9.2 在腾讯开放平台创建应用\n\n- 创建应用\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_65986370d9-9.2创建应用.png)\n\n- 填写应用资料\n> 网站回调地址填写前端页面地址，再由前端页面请求后端进行账户注册或`jwt`生成。在这里需要处理一下前端页面的地址，因为这一栏腾讯要求不能以`'/'`结尾。所以前端页面也不能以`'/'`结尾。\n\n```javascript\n{\n  path: \"/user/account/qq/web/receiveCode\",\n  name: \"user_account_qq_receive_code\",\n  component: ()=>import('@/views/user/account/UserAccountQQReceiveCodeView'),\n  meta:{\n    requestAuth : false\n  }\n},\n```\n所以我的地址（后端的`redirect_uri`与此保持一致）：\n```xml\nhttps://smallboat.games/user/account/qq/web/receiveCode\n```\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_6a4f7e5bd9-9.2填写应用资料.png)\n> - 提供方和网站地址备案号可在：`[https://icp.chinaz.com/](https://icp.chinaz.com/)`查询。\n> - 提交审核后一定要先将`QQ`登录按钮部署到正式环境，否则会以`未摆放QQ登录按钮`审批不通过。\n\n- 审核通过\n\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_67678959d9-9.2审核通过.png)\n<a name=\"KFUq7\"></a>\n### 9.3 代码实现\n<a name=\"FXRnt\"></a>\n#### 9.3.1 前端\n\n- 在登录页合适位置添加`QQ`登录按钮：\n```html\n<div @click=\"qq_login\" style=\"cursor: pointer; text-align: center; margin-top: 10px;\">\n  <img height=\"30\" \n    src=\"https://wiki.connect.qq.com/wp-content/uploads/2013/10/03_qq_symbol-1-250x300.png\"\n    alt=\"QQ官方图标\"/>\n  <br>\n  <div style=\"color: #09e309\">\n    QQ一键登录\n  </div>\n</div>\n```\n```javascript\nconst qq_login = () => {\n  $.ajax({\n    url: \"https://smallboat.games/api/user/account/qq/web/applyCode/\",\n    type: \"GET\",\n    success: resp => {\n      if (resp.result === \"success\") {\n        window.location.replace(resp.apply_code_url);\n      }\n    }\n  })\n}\n```\n\n- 添加路由（~~其实上面已经写过~~）\n```javascript\n{\n  path: \"/user/account/qq/web/receiveCode\",\n  name: \"user_account_qq_receive_code\",\n  component: ()=>import('@/views/user/account/UserAccountQQReceiveCodeView'),\n  meta:{\n    requestAuth : false\n  }\n},\n```\n\n- 处理`QQ`登录的页面\n```vue\n<template>\n  <div></div>\n</template>\n\n<script>\nimport router from \"@/router/index\";\nimport {useStore} from \"vuex\";\nimport {useRoute} from \"vue-router\";\nimport $ from 'jquery'\nexport default {\n  name: \"UserAccountQQReceiveCodeView\",\n  setup() {\n    const myRoute = useRoute();\n    const store = useStore();\n    $.ajax({\n      url: \"https://smallboat.games/api/user/account/qq/web/receiveCode/\",\n      type: \"GET\",\n      data: {\n        code: myRoute.query.code,\n        state: myRoute.query.state,\n      },\n      success: resp => {\n        if (resp.result === \"success\") {\n          localStorage.setItem(\"jwt\", resp.jwt);\n          store.commit(\"updateToken\", resp.jwt);\n          router.push({name: \"home\"});\n          store.commit(\"updatePullingInfo\", false);\n        } else {\n          router.push({name: \"user_account_login\"});\n        }\n      }\n    })\n  }\n}\n</script>\n\n<style scoped>\n\n</style>\n```\n<a name=\"OxeZj\"></a>\n#### 9.3.2 后端\n**后端主要需要实现两个接口：**\n> 记得在`SecurityConfig`中放行这两个接口，因为是在用户未获取`jwt`时进行访问。\n\n- `@GetMapping(\"/applyCode/\")`\n```java\n@Override\npublic JSONObject applyCode() {\n    JSONObject resp = new JSONObject();\n    String encodeUrl = \"\";\n    try {\n        encodeUrl = URLEncoder.encode(REDIRECT_URI, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        resp.put(\"result\", \"failed\");\n        return resp;\n    }\n\n    // 随机字符串，防止 csrf 攻击\n    StringBuilder state = new StringBuilder();\n    for (int i = 0; i < 10; i ++) {\n        state.append((char)(random.nextInt(10) + '0'));\n    }\n    // 存到redis里，有效期设置为10分钟\n    resp.put(\"result\", \"success\");\n    redisTemplate.opsForValue().set(state.toString(), \"true\");\n    redisTemplate.expire(state.toString(), Duration.ofMinutes(10));\n\n    String applyCodeUrl = \"https://graph.qq.com/oauth2.0/authorize\"\n            + \"?response_type=\"+\"code\"\n            + \"&client_id=\" + APP_ID\n            + \"&redirect_uri=\" + encodeUrl\n            + \"&state=\" + state;\n    resp.put(\"apply_code_url\", applyCodeUrl);\n\n    return resp;\n}\n```\n\n- `@GetMapping(\"/receiveCode/\")`\n```java\n@Override\npublic JSONObject receiveCode(String code, String state) {\n    JSONObject resp = new JSONObject();\n    resp.put(\"result\", \"failed\");\n    if (null == code || null == state) return resp;\n    if (Boolean.FALSE.equals(redisTemplate.hasKey(state))) return resp;\n    redisTemplate.delete(state);\n    // 获取access_token\n    List<NameValuePair> nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"grant_type\", \"authorization_code\"));\n    nameValuePairs.add(new BasicNameValuePair(\"client_id\", APP_ID));\n    nameValuePairs.add(new BasicNameValuePair(\"client_secret\", APP_SECRET));\n    nameValuePairs.add(new BasicNameValuePair(\"code\", code));\n    nameValuePairs.add(new BasicNameValuePair(\"redirect_uri\", REDIRECT_URI));\n    nameValuePairs.add(new BasicNameValuePair(\"fmt\", \"json\"));\n\n    String getString = HttpClientUtil.get(APPLY_ACCESS_TOKEN_URL, nameValuePairs);\n    if (null == getString) return resp;\n    JSONObject getResp = JSONObject.parseObject(getString);\n    String accessToken = getResp.getString(\"access_token\");\n\n    // 获取openid\n    nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"access_token\", accessToken));\n    nameValuePairs.add(new BasicNameValuePair(\"fmt\", \"json\"));\n\n    getString = HttpClientUtil.get(APPLY_USER_OPENID_URL, nameValuePairs);\n    if(null == getString) return resp;\n    getResp = JSONObject.parseObject(getString);\n    String openid = getResp.getString(\"openid\");\n\n    if (accessToken == null || openid == null) return resp;\n\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.eq(\"openid_qq\", openid);\n    List<User> users = userMapper.selectList(queryWrapper);\n\n    // 用户已经授权，自动登录\n    if (null != users && !users.isEmpty()) {\n        User user = users.get(0);\n        // 生成jwt\n        String jwt = JwtUtil.createJWT(user.getId().toString());\n\n        resp.put(\"result\", \"success\");\n        resp.put(\"jwt\", jwt);\n        return resp;\n    }\n\n    // 新用户授权，获取用户信息，并创建新用户\n    nameValuePairs = new LinkedList<>();\n    nameValuePairs.add(new BasicNameValuePair(\"access_token\", accessToken));\n    nameValuePairs.add(new BasicNameValuePair(\"openid\", openid));\n    nameValuePairs.add(new BasicNameValuePair(\"oauth_consumer_key\", APP_ID));\n    getString = HttpClientUtil.get(APPLY_USER_INFO_URL, nameValuePairs);\n    if (null == getString) return resp;\n\n    getResp = JSONObject.parseObject(getString);\n    String username = getResp.getString(\"nickname\");\n    // 50*50的头像\n    String photo = getResp.getString(\"figureurl_1\");\n\n    if (null == username || null == photo) return resp;\n\n    // 每次循环，用户名重复的概率为上一次的1/10\n    for (int i = 0; i < 100; i ++) {\n        QueryWrapper<User> usernameQueryWrapper = new QueryWrapper<>();\n        usernameQueryWrapper.eq(\"username\", username);\n        if (userMapper.selectCount(usernameQueryWrapper) == 0) break;\n        username += (char)(random.nextInt(10) + '0');\n        if (i == 99) return resp;\n    }\n    User user = new User(null, username, null, photo, 1500, null, openid, null);\n    userMapper.insert(user);\n    // 生成 jwt\n    String jwt = JwtUtil.createJWT(user.getId().toString());\n    resp.put(\"result\", \"success\");\n    resp.put(\"jwt\", jwt);\n    return resp;\n}\n```\n<a name=\"jQ4rd\"></a>\n\n## 10. 项目上线\n上线流程参考：<br />[项目上线基本流程-CSDN博客](http://smallboatc.github.io/2024/02/01/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/)<br />上线成果：<br />[King of Bots](https://smallboat.games/)<br />项目`github`地址：<br />[https://github.com/smallboatc/kob/](https://github.com/smallboatc/kob/)\n","categories":["SpringBoot"]},{"title":"项目上线基本流程","url":"/2024/02/01/项目上线基本流程/","content":"\n<a name=\"Q907D\"></a>\n## 1. 租ECS云服务器\n服务器推荐顺序：\n\n- 阿里云\n- 腾讯云\n- 华为云\n\n一般选择`1核2G`即可，选择按使用量计费。<br />通过命令`ssh root@xx.xxx.xxx.xxx #（公网ip）`，然后输入购买服务器时设置的密码即可连接到服务器。之前如果没生成过公钥的，需要先在本地使用命令`ssh-keygen`一路回车生成公钥再登录。<br />如果是重置过服务器，那么之前就会有记录，重新登录时会报错，此时需要在文件中将该服务器的配置删掉再登录。\n```shell\nvim .ssh/known_hosts # 进入后删除该服务器的配置\n```\n<a name=\"pUBb0\"></a>\n## 2. 配置服务器\n`CentOs`创建用户（默认的`root`权限过高，需要使用拥有`sudo`权限的用户进行操作）\n```shell\nuseradd acs # acs 为自己想取的用户名\npasswd acs\n# 设置密码\nchmod -v u+w /etc/sudoers # 给 sudoers 文件可写权限\nvim /etc/sudoers # 修改该文件，给用户 acs 添加权限\n# 进入后先输入 /Allow root 找到 root    ALL=(ALL)    ALL 所在位置\n# i 进入编辑模式，在 root    ALL=(ALL)    ALL 下一行写入 acs    ALL=(ALL)    ALL\n# 按ESC 然后输入 :wq 保存并退出 \nchmod -v u-w /etc/sudoers # 收回 sudoers 文件可写权限\nsu acs # 使用新账户登录系统\n```\n![image.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_aaaccb4ad8-2.配置服务器.png)<br />然后`exit`退出，在本地配置免密登录：\n```shell\nvim .ssh/config # 没有该文件会自动创建\n```\n在文件中添加如下语句\n```shell\nHost springboot_server # 后面这个是给服务器取的名字\n  \tHostName xx.xxx.xxx.xxx # 后面这个是公网ip\n    User acs # 后面这个是刚刚添加的用户名\n```\n保存并退出<br />在终端中输入`ssh-copy-id springboot_server`然后输入密码完成免密登录配置，之后就可以使用使用`ssh springboot_server`直接登录，而不需要输入密码。<br />然后我们先不登录，先将一些祖传配置文件传过去。<br />使用`scp xxx springboot_server:`将需要的文件传到服务器（没有就不传），注意一定要有冒号`:`\n```shell\nscp .bashrc .vimrc .tmux.conf server_name:  # server_name需要换成自己配置的别名\n```\n然后登录服务器<br />先装一个`tmux`（所有工作尽量在`tmux`中完成，避免发生意外丢失工作进度）\n```shell\nsudo yum update # 先更新数据源，网络不好可能会报错，尽量在网络环境良好时操作\nsudo yum install tmux\n```\n<a name=\"jzQu6\"></a>\n## 3. 安装docker\n然后在`tmux`中安装`docker`（[docker安装步骤（官网）](https://docs.docker.com/engine/install/centos/)）<br />安装完成后输入`docker`会有一些提示，说明安装成功！<br />然后启动`docker`：`sudo systemctl start docker`<br />安装成功之后，将用户在`docker`中赋予`sudo`权限：`sudo usermod -aG docker $USER`，以便该用户可以使用 `docker` 而无需使用 `sudo`。之后需要退出重新登录才会生效，否则执行`docker`相关命令会提示没有权限。\n\n之后就可以使用`scp`命令把自己的镜像传到服务器了\n\n然后使用命令`docker load -i django_lesson_1_0.tar`将镜像文件解压到`docker`中。<br />运行镜像：\n```shell\n# 中间是需要使用的端口号映射配置，例如 -p 20000:22 会将在外界访问服务器20000端口时自动映射到容器的22端口\ndocker run -p 20000:22 -p 443:443 -p 80:80 -p 3000:3000 -p 3001:3001 -p 3002:3002 -itd --name kob_server django_lesson:1.0\n```\n然后就可以进到`docker`中了：`docker attach kob_server`（镜像是`ubuntu`）\n\n之后给创建用户并赋予`sudo`权限，再按`ctrl + p, strl + q`挂载容器（退出但不销毁）。\n\n之后同样的操作将祖传的配置文件传到容器中\n<a name=\"tAnh0\"></a>\n## 4. 容器中安装各种服务\n然后在容器中安装`mysql`\n```shell\nsudo apt-get install mysql-server\nsudo apt-get update\nsudo apt-get install mysql-server\t\n```\n\n然后启动`mysql`:`sudo service mysql start`<br />然后进入`mysql mysql -uroot -pxxxxx`\n\n在`mysql`中执行`sql`语句：`ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'yourpasswd';`以修改密码。\n\n创建数据库并创建表：\n```sql\ncreate database kob;\nuse kob;\nsource /home/acs/create_table.sql; # 提前准备好的创建数据库表的sql文件\nexit;\n```\n安装java\n```shell\nsudo apt-get install openjdk-8-jdk\n```\n<a name=\"UbU8u\"></a>\n## 5. 打包项目到容器中\n然后就是将项目打包传到容器中运行了\n\n后端项目先`clean`再`package`即可。<br />前端项目修改请求地址运行`npm run build`\n\n将后端项目的jar包分别发送到容器中运行\n```shell\njava -jar xxx.jar # 运行\n```\n需要停止的话\n```shell\nps -ef | grep xxx.jar # 查询程序的进程号\nkill -s 9 xxxx # 后面是查询到的进程号\n```\n<a name=\"UwYLg\"></a>\n## 6. 配置许可证以及nginx等\n配置`key, pem, nginx.conf`<br />在这之前先将配置文件复制到root目录下（为了使配置nginx.conf时文件格式好看点）<br />`sudo cp .bashrc .vimrc .tmux.conf /root`<br />具体的域名、许可证、证书申请及`nginx`配置可参考其他文章。<br />最后启动`nginx`\n```shell\nsudo /etc/init.d/nginx start # 如果运行结果是fail的话需要查看错误日志对应修改\n```\n\n结束。<br />**题外话：** 需要在本地连接容器中的数据库，可以参考[Navicat 连接远程服务器里 docker 中的 mysql](http://t.csdnimg.cn/mp9E2)\n\n","categories":["Linux"]},{"title":"ubuntu解决终端中文乱码问题","url":"/2024/01/28/ubuntu解决终端中文乱码问题/","content":"\n1. 查看当前系统语言\n```shell\n$ echo $LANG\n```\n\n2. 查看系统安装的语言包\n```shell\n$ locale -a \nC\nC.UTF-8\nPOSIX\n\n$ sudo dpkg -l | grep language-pack-zh-hans\n```\n\n3. 如果没有中文语言包，需要安装\n```shell\n$ sudo apt-get install language-pack-zh-hans\n```\n\n4. 安装成功后，确认是否安装成功\n```shell\n$ locale -a \nC\nC.UTF-8\nPOSIX\nzh_CN.utf8\nzh_SG.utf8\n\n$ sudo dpkg -l | grep language-pack-zh-hans\nii  language-pack-zh-hans           1:20.04+20210802                    all          translation updates for language Simplified Chinese\nii  language-pack-zh-hans-base      1:20.04+20210802                    all          translations for language Simplified Chinese\n```\n\n5. 设置系统语言环境\n```shell\n# export 的方式只对当前终端生效\n$ export LANG=\"zh_CN.UTF-8\"\n\n#  /etc/profile 文件中添加export LANG=\"zh_CN.UTF-8\" 对所有用户生效\n$ sudo vim /etc/profile\n```\n","categories":["Linux"]},{"title":"动态规划LIS模型","url":"/2024/01/19/动态规划LIS模型/","content":"\n<a name=\"UlPOe\"></a>\n## 1. LIS 模型\n> LIS问题：给定一个长度为`N`的数列 `a`，求数值严格单调递增的子序列的长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i]$表示由数列$a$的前$i$个数字组成（不一定包含所有数字）且以$a[i]$结尾的最长上升子序列的长度。\n- 状态计算：遍历小于$i$的每一个$j$，若有$a[j] < a[i]$，则$f[i] = max(f[i], f[j] + 1)$，否则$f[i] = 1$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] a = new int[N], f = new int[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            f[i] = 1;\n            for (int j = 1; j <= n; j ++) {\n                if (a[j] < a[i]) f[i] = Math.max(f[i], f[j] + 1);\n            }\n        }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[i]);\n        System.out.println(res);\n    }\n}\n```\n**优化：**<br />在状态计算那一步，我们每次去遍历所有小于$i$的$j$，这样显然时间复杂度是$O(n^2)$。对于数据量大的题目，是会$TLE$的。我们可以使用贪心的方式来优化，具体如下：<br />我们用一个数组$q$来维护当前遍历到的元素之前的序列，每次遍历到一个元素$a[i]$，就在$q$中寻找小于$a[i]$的最大的元素$q[r]$，并将$q[r+1]$赋值为$a[i]$，同时更新一下最长上升子序列的长度。<br />有三个注意点：\n\n- 将$q[r+1]$赋值为$a[i]$：有可能$a[i]$就是维护的序列中最大的元素，因此会是添加到序列后面。也有可能是将$q[r+1]$修改为$a[i]$。\n- 如果是将$q[r+1]$修改为$a[i]$，这个操作是不影响后面的遍历的，因为如果后面某个元素$a[j]$能放到原来的$q[r+1]$后面，也必然能放到新的$q[r+1](a[i])$后面（因为当前的$q[r+1]$必然是大于$a[i]$的）。\n- 在该序列中寻找小于$a[i]$的最大的元素$q[r]$：这个操作我们可以通过二分来实现。\n\n**优化代码实现：**\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 100010;\n    static int[] a = new int[N], q = new int[N];\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s = br.readLine().split(\" \");\n        for (int i = 0; i < n; i ++) a[i] = Integer.parseInt(s[i]);\n        \n        int len = 0;\n        q[0] = -(int)2e9;\n        for (int i = 0; i < n; i ++) {\n            int l = 0, r = len;\n            while(l < r) {\n                int mid = l + r + 1 >> 1;\n                if (q[mid] < a[i]) l = mid;\n                else r = mid - 1;\n            }\n            // 更新最长上升子序列长度（不一定能更新）\n            len = Math.max(len, r + 1);\n            // 将新点插入\n            q[r + 1] = a[i];\n        }\n        System.out.print(len);\n    }\n}\n```\n**LIS模型相关题目：**\n\n- [AcWing 1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)：题目需要求从一个点开始，每一次的下一个位置不许严格低于前一个位置，问最远能走多远。逆向思维，求一遍LIS问题即可。\n- [AcWing 482. 合唱队形](https://www.acwing.com/problem/content/484/)：题目要求至少要多少名同学出列才能形成合唱队形，我们可以求合唱队形最长能多长（即正反分别求一次LIS问题），然后用总人数减去最长合唱队行人数。\n- [AcWing 1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)：LIS问题求的是数量，而这道题求的是每个元素的和，所以求LIS问题时将`+1`改为`+a[i]`即可。\n- [AcWing 187. 导弹防御系统](https://www.acwing.com/problem/content/189/)：这道题虽然也是LIS模型，但是已经跟DP无关了，解题方法为DFS+贪心版LIS。\n<a name=\"nYruO\"></a>\n## 2. LCS模型\n> LCS问题：给定两个长度分别为n 和 m 的字符串 a 和 b，求既是 a 的子序列又是 b 的子序列的字符串长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i][j]$表示由数列$a$的前$i$个数字与数列$b$的前$j$个数字组成的公共子序列的长度最大值。\n- 状态计算：\n   - 当包含$a[i]$且不包含$b[j]$时，$f[i][j] = max(f[i][j], f[i][j - 1])$；\n   - 当包含$b[j]$且不包含$a[i]$时，$f[i][j] = max(f[i][j], f[i - 1][j])$；\n   - 当既不包含$a[i]$也不包含$b[j]$时，$f[i][j] = max(f[i][j], f[i - 1][j - 1])$，但是这种情况可以被以上任意一种包含；\n   - 当包含$a[i]$且包含$b[j]$时（要求$a[i] = b[j]$），$f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        char[] a = (\" \" + sc.next()).toCharArray(), b = (\" \" + sc.next()).toCharArray();\n        for (int i = 1; i <= n; i ++)\n            for (int j = 1; j <= m; j ++) {\n                f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]);\n                if (a[i] == b[j]) f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n<a name=\"FNFgY\"></a>\n## 3. LCIS模型\n> LCIS问题：给定两个长度分别为n 和 m 的字符串 a 和 b，求既是 a 的子序列又是 b 的子序列且数值严格单调递增的字符串长度最长是多少。\n\n**算法思想：**\n\n- 状态表示：$f[i][j]$表示由数列$a$的前$i$个数字与数列$b$的前$j$个数字组成且以$b[j]$结尾的最长上升公共子序列的长度的最大值。\n- 状态计算：\n   - 当不包含$a[i]$时，$f[i][j] = f[i - 1][j]$；\n   - 当包含$a[i]$时（要求$a[i] = b[j]$），此时$f[i][j]$起码为1，$f[i][j] = max(f[i][j], 1)$，然后遍历$b[j]$之前的元素，若$b[k]<b[j]$，则$f[i][j] = max(f[i][j], f[i][k] + 1)$。\n\n**代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 3010;\n    static int[] a = new int[N], b = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) b[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= n; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (a[i] == b[j]) {\n                    f[i][j] = Math.max(f[i][j], 1);\n                    for (int k = 1; k < j; k ++) \n                        if (b[k] < b[j]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);\n                }\n            }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[n][i]);\n        System.out.println(res);\n    }\n}\n```\n**优化：**<br />上述的方法时间复杂度达到了$O(n^3)$，数据量稍大一些就$TLE$。我们可以对代码做等价变形优化成$O(n^2)$。<br />可以发现，当$a[i] = b[j]$时，`if (b[k] < b[j]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);`这一句等价于`if (b[k] < a[i]) f[i][j] = Math.max(f[i][j], f[i][k] + 1);`，我们就能发现，这一部分求解其实是与$b[j]$无关的。我们可以直接用一个变量代替这一部分，每次循环$j$时维护起来即可。<br />**优化代码实现：**\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 3010;\n    static int[] a = new int[N], b = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) b[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            int maxv = 1;\n            for (int j = 1; j <= n; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (a[i] == b[j]) f[i][j] = Math.max(f[i][j], maxv);\n                // 这里的b[j]就等价于优化前的b[k]，a[i]就等价于优化前的b[j]\n                if (a[i] > b[j]) maxv = Math.max(maxv, f[i][j] + 1);\n            }\n        }\n        int res = 0;\n        for (int i = 1; i <= n; i ++) res = Math.max(res, f[n][i]);\n        System.out.println(res);\n    }\n}\n```\n\n","categories":["算法"]},{"title":"二分算法详解","url":"/2024/01/16/二分算法详解/","content":"\n<a name=\"qR9aQ\"></a>\n## 1. 二分定义\n**二分查找（百度百科）**：二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求[线性表](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink)必须采用[顺序存储结构](https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1347176?fromModule=lemma_inlink)，而且表中元素按关键字有序排列。<br />上述的定义只是狭义上的二分查找定义，在上述定义中提到了一个概念：**有序**，但实际上，我们只需要让线性表满足**二段性**即可使用二分。\n<a name=\"cfGPL\"></a>\n## 2. 二段性\n那么，什么是二段性呢？<br />所谓二段性，就是在线性表中有一个元素，使得该元素的左侧满足性质1，右侧满足性质2。<br />举个🌰，有一个数组`nums = [4, 5, 6, 7, 0, 1, 2]`，该数数组原本是严格递增的，但是被按照某个点旋转了一次。现在我们需要找出该数组的原始起点（当然，直接遍历一遍是一种有效但并不优美的做法）。在这例子中，起点当然是`0`了，并且我们通过观察可以发现，`0`**的左侧满足所有的元素都大于等于**`nums[0] = 4`（性质1），而`0`**及其右侧元素都小于**`nums[0] = 4`（性质2）。那么此时，元素`0`就是让这个线性表具有二段性的元素**之一**（为什么说之一呢，因为例如`7`也能使该线性表具有二段性）。<br />为什么具有二段性就能使用二分呢？<br />还是拿上述例子进行说明，我们既然清楚了我们需要查找的元素具有二段性，那么，我们是否可以利用这个性质缩小查询范围以不断逼近并最终查询到这个元素呢？\n<a name=\"f3r3P\"></a>\n## 3. 利用二段性实现二分\n答案是肯定的。每一次，我们取整个线性表的中间元素（下标记为`mid`），判断`nums[mid]`满足**性质1**还是**性质2**。\n\n- 如果满足性质1，则说明`nums[mid]`在目标元素的左侧，此时我们将区间左端点（`l`）移动到`mid + 1`（因为此时我们可以明确的知道`nums[mid]`并不是我们需要的元素）。\n- 如果满足性质2，则说明`nums[mid]`就是目标元素或是在目标元素右侧，此时我们将区间右端点移动到`mid`。\n\n于是，二分查找的代码就有了：\n```java\nint l = 0, r = n - 1;\nint x = nums[0];\nwhile (l < r) {\n    int mid = l + r >> 1;\n    if (nums[mid] >= x) l = mid + 1;\n    else r = mid;\n}\n```\n> `l + r >> 1`等价于`(l + r) / 2`\n\n到此处，我们几乎能用一句话总结二分，即**利用二段性不断逼近直到查找到目标元素**。\n<a name=\"GDwgm\"></a>\n## 4. 二分常见模板\n这类题目一般能够使用二分（因为他们通常情况下具有二段性）：\n\n- 查找最小的最大值\n- 查找最大的最小值\n\n**模板1：**\n```java\nint l = 0, r = n - 1;\nwhile (l < r) {\n    int mid = l + r >> 1;\n    // check() 判断 mid 是否满足性质1或性质2\n    if (check(mid)) r = mid;\n    else l = mid + 1;\n}\n```\n**模板2：**\n```java\nint l = 0, r = n - 1;\nwhile (l < r) {\n    int mid = l + r + 1 >> 1;\n    if (check(mid)) l = mid;\n    else r = mid - 1;\n}\n```\n**为什么会有两种模板呢？**<br />主要是出于两个目的：\n\n1. 时时刻刻保证目标元素在所维护区间的内部\n2. 处理边界问题（直接背过就行，当出现`r = mid - 1`时，`mid`就定义为`int mid = l + r + 1 >> 1;`，前人总结出的经验）。\n\n在次给出几道`leetcode`例题练练手（通过看优质题解是很好的进步方式）：\n\n- 例题1：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)\n- 例题2：[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)\n- 例题3：[搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)\n<a name=\"ThfuS\"></a>\n## 5. 扩展：二分答案\n对于二分的题目，很多时候还会以**二分答案**的形式出题。<br />什么是二分答案？<br />**我们以一道例题为例：**[**跳石头**](https://www.luogu.com.cn/problem/P2678)\n<a name=\"TROgb\"></a>\n### 5.1 题目描述\n一年一度的“跳石头”比赛又要开始了！<br />这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。<br />为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。\n<a name=\"vk8Ln\"></a>\n### 输入格式\n第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。<br />接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。\n<a name=\"Fvhnt\"></a>\n### 输出格式\n一个整数，即最短跳跃距离的最大值。\n<a name=\"q3dYD\"></a>\n### 样例输入 #1\n```\n25 5 2 \n2\n11\n14\n17 \n21\n```\n<a name=\"X2jeI\"></a>\n### 样例输出 #1\n```\n4\n```\n<a name=\"lnEVN\"></a>\n### 输入输出样例 1 说明\n将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。\n<a name=\"dfZxe\"></a>\n### 数据规模与约定\n对于 $20\\%$的数据，$0 \\le M \\le N \\le 10$。<br />对于 $50\\%$ 的数据，$0 \\le M \\le N \\le 100$。<br />对于 $100\\%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \n \\le 10^9$。\n<a name=\"OBkEH\"></a>\n### 5.2 题解\n本题中，我们的目的是要寻找`最短跳跃距离的最大值`，这个答案肯定在$1\\thicksim L$之间，最暴力的方法就是从$L$枚举到$1$，找到的第一个合法答案就是最优解。那么什么样的答案能被称为合法呢？题目要求最多只能挪走$M$块石头，所以如果在挪走$M$块石头之前能够满足每两块石头间的距离大于等于我们枚举的答案，那么这个答案就是合法的。而挪走石头的顺序就是要先解决距离最小的石头，因此从小到大开始挪石头即可，每次挪完石头记录挪走的石头数量，然后更新一下下一块石头与挪走的石头的上一块石头之间的距离。若挪完石头发现挪走石头的数量大于$M$，那么我们枚举的这个答案就不是满足题目要求的`最短跳跃距离的最大值`，就继续往前找。\n\n我们可以发现，在上面的分析过程中，我们是先从答案入手，再去判断答案是否满足题目的限制条件。而这一暴力过程其实是可以使用二分优化的。这种从答案出发，使用二分优化的方式就被称为**二分答案**。\n\n> 重点分析`check`函数，二分的精髓。\n\n\n```java\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n\tstatic final int N = 50010;\n\tstatic int L, n, m;\n    // dist记录当前点与前一个点的距离\n\tstatic int[] a = new int[N], dist = new int[N];\n\tpublic static boolean check(int mid) {\n\t\tint cnt = 0;\n\t\tint[] backup = Arrays.copyOf(dist, dist.length);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tif (dist[i] < mid) {\n\t\t\t\tcnt ++;\n\t\t\t\tdist[i + 1] += dist[i];\n\t\t\t}\n        // 每一轮挪完石头需要将dist数组还原，因为每轮挪石头都是独立的\n\t\tdist = Arrays.copyOf(backup, backup.length);\n\t\treturn cnt <= m;\n\t}\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s = br.readLine().split(\" \");\n\t\tL = Integer.parseInt(s[0]);\n\t\tn = Integer.parseInt(s[1]);\n\t\tm = Integer.parseInt(s[2]);\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\ta[i] = Integer.parseInt(br.readLine().split(\" \")[0]);\n\t\t\tdist[i] = a[i] - a[i - 1];\n\t\t}\n\t\tdist[n + 1] = L - a[n];\n\t\tn ++;\n\t\tint l = 1, r = L;\n\t\twhile (l < r) {\n\t\t\tint mid = l + r + 1 >> 1;\n\t\t\tif (check(mid)) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tSystem.out.print(l);\n\t}\n}\n```\n","categories":["算法"]},{"title":"使用@JsonFormat注解前后端时间相差8小时的问题","url":"/2023/12/17/使用@JsonFormat注解前后端时间相差8小时的问题/","content":"\n<a name=\"BW8kv\"></a>\n在写项目时发现在实体类中使用了`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`注解，然后该时间存入数据库也正常，从数据库中取出也是正常，但是传给前端就出现问题，两边的时间相差了 `8`小时。\n\n- 配置文件：\n```yaml\nurl: jdbc:mysql://localhost:3306/xxx?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8\n```\n> 注意：`gmtCreate`只是数据库中习惯命名，并非使用的是`GMT`时间。\n\n<a name=\"lsS8y\"></a>\n## 1. 原始写法\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\nprivate Date gmtModified;\n```\n\n- 程序获取到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_adf2f129d9-1.1.png)\n- 数据库中存入的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_afd1785ed9-1.2.png)\n- 前端接收到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b2bf2366d9-1.3.png)\n\n**问题剖析：**\n\n1. **程序-数据库：** 程序中获取的是当前的系统时间，取决于服务器的时间，所以获取的时间是正确的，然后传给数据库的时候，由于两边的时区没有差别，所以在序列化的时候，时间转化是没有一点问题的。\n2. **数据库-程序：** 从数据库取出时间的时候进行反序列化，此时两边的时区一致，时间转换没有问题，所以程序拿到的时间也是正确的。\n3. **程序-前端：** 当程序需要将对象传输给前端时，并不明确前端的时区，所以将默认对方为`GMT`时间，所以在序列化时，由于时区的变化，得到的`Json`字符串自然也发生了变化（`-8`小时）。\n<a name=\"VtAtN\"></a>\n## 2. 修正写法\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\nprivate Date gmtCreate;\n```\n\n- 程序获取到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b3fb63dfd9-2.1.png)\n- 数据库中存入的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_b7045e3bd9-2.2.png)\n- 前端接收到的时间：![image.png](https://cdn.acwing.com/media/article/image/2024/03/03/126318_baa13aecd9-2.3.png)\n\n通过在`@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`注解中加入`timezone = \"GMT+8\"`，就明确了在转为`GMT`时间时将时间`+8`再序列化。<br />当然，也可以直接指定时区：\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"Asia/Shanghai\")\nprivate Date gmtCreate;\n```\n","categories":["后端开发排坑"]},{"title":"SQL开发手册（自用版）","url":"/2023/09/14/SQL开发手册（自用版）/","content":"\n<a name=\"kaTKj\"></a>\n# 一、SELECT查询技巧\n1、对查询进行优化，应尽量避免全表扫描(非必要不使用`SELECT * FROM table1`)，首先应考虑在 WHERE 及 ORDER BY 涉及的列上建立索引(建立索引需满足建立索引规约)。<br />2、应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，创建表时 NULL 是默认值，但大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。<br />3、应尽量避免在 WHERE 子句中使用 != 或 <> 操作符。MySQL 只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的 LIKE(索引文件具有B-Tree的最左前缀匹配特性)。<br />4、应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION 合并查询。\n\n- 反例：\n```sql\nSELECT id FROM t WHERE num = 10 OR num = 20;\n```\n\n- 正例：\n```sql\nSELECT id FROM t WHERE num = 10\nUNION ALL\nSELECT id FROM t WHERE num = 20;\n```\n5、IN 和 NOT IN 也要慎用，否则会导致全表扫描。对于连续的数值，能用 BETWEEN 就不要用 IN。\n\n- 反例：\n```sql\nSELECT id FROM t WHERE num IN (1, 2, 3);\n```\n\n- 正例：\n```sql\nSELECT id FROM t WHERE num BETWEEN 1 AND 3;\n```\n6、如果在 WHERE 子句中使用参数(指数据库暂时无法确定其值的局部变量，并不是mybatis中的参数)，也会导致全表扫描而不是走索引。<br />7、应尽量避免在 WHERE 子句中对字段进行表达式操作，应尽量避免在 WHERE 子句中对字段进行函数操作。\n\n- 说明：WHERE 子句中对列的任何操作结果都是在 SQL 运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。如果这些结果在查询编译时就能得到，那么就可以被 SQL 优化器优化，从而可能使用索引，进而避免表搜索。\n- 反例：\n```sql\nSELECT * FROM order_master WHERE SUBSTRING(order_master_sn, 1, 4) = '2023';\nSELECT * FROM order_master WHERE payment / 2 < 500;\nSELECT * FROM f_user WHERE CONVERT(CHAR(10), birthday, 112) = '19991217'\n```\n\n- 正例：\n```sql\nSELECT * FROM order_master WHERE order_master_sn LIKE '2023%'\nSELECT * FROM order_master WHERE payment < 500 * 2\nSELECT * FROM f_user WHERE birthday = '1999-12-17'\n```\n8、很多时候用 EXISTS 代替 IN 是一个好的选择：`SELECT num from a WHERE num IN(SELECT num FROM b)`。用下面的语句替换：`SELECT num FROM a WHERE EXISTS(SELECT 1 FROM b WHERE num = a.num)`。<br />9、当在 SQL 语句中连接多个表时，尽量为表起别名，同时把别名前缀于每个 Column 上（即`order_master.order_master_id`在多表查询时给`order_master`起别名`om`，然后替换为`om.order_master_id`）。该操作可减少解析的时间并减少那些由 Column 歧义引起的语法错误。<br />10、尽量使用 “>=”，不要使用 “>”。\n\n- 说明：使用`>=`逻辑更加清晰、避免遗漏数据、能够轻松的修改边界值、可以有效避免误操作。\n\n11、选择最有效率的表名顺序（只在基于规则的优化器中有效）。\n\n- 说明：Oracle 的解析器按照从右到左的顺序处理 FROM 子句中的表名，FROM 子句中写在最后的表（基础表 driving table）将被最先处理，在 FROM 子句中包含多个表的情况下，必须选择记录条数最少的表作为基础表。\n\n12、可以通过将不需要的记录在 GROUP BY 之前过滤掉来提高 GROUP BY 语句的效率。\n\n- 反例：\n```sql\nSELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING JOB = 'PRESIDENT' OR JOB = 'MANAGER'\n```\n\n- 正例：\n```sql\nSELECT JOB, AVG(SAL) FROM EMPWHERE JOB = 'PRESIDENT' OR JOB = 'MANAGER' GROUP BY JOB\n```\n13、SQL 语句用大写，因为较多主流数据库总是先把小写的字母转换成大写的再执行。<br />14、使用`ISNULL()` 来判断是否为NULL值。 \n\n- 说明：NULL与任何值的直接比较都为NULL。\n   - `NULL <> NULL`的返回结果是NULL，而不是false。\n   - `NULL = NULL`的返回结果是NULL，而不是true。\n   - `NULL <> 1`的返回结果是NULL，而不是true。 \n- 反例：在SQL语句中，如果在NULL前换行，影响可读性。 `SELECT * FROM table WHERE column1 IS NULL AND column3 IS NOT NULL;`而`ISNULL(column)` 是一个整体，简洁易懂。从性能数据上分析，`ISNULL(column)` 执行效率更快一些。\n\n15、代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。<br />16、sql.xml配置参数使用：`#{}`，`#param#` ，不要使用 `${}` （此种方式容易出现SQL注入）。<br />17、不允许直接拿HashMap与Hashtable作为查询结果集的输出。\n\n- 反例：某同学为避免写一个`<resultMap>xxx</resultMap>`，直接使用Hashtable来接收数据库返回结果，结果出现日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。\n\n18、当只要一行数据时使用 LIMIT 1 。\n\n- 说明：当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。在这种情况下，加上 LIMIT 1 可以增加性能。这样一来，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。\n\n19、使用子查询优化大分页查询\n\n- 说明：这种优化方式只使用与`id`是正序的情况。\n- 反例：\n```sql\nSELECT score, name FROM student ORDER BY score DESC LIMIT 1000000, 10;\n```\n\n- 正例：\n```sql\nSELECT score, name FROM student\nWHERE id >= (SELECT id FROM student LIMIT 1000000, 1)\nORDER BY score\nLIMIT 10;\n```\n<a name=\"ax9ds\"></a>\n\n# 二、索引\n1、业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n\n- 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n2、超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n\n- 说明：即使双表join也要注意表索引、SQL性能。\n\n3、索引的使用规范：\n\n- 索引的创建要与应用结合考虑，且一个表尽量不要超过 6 个索引；\n- 尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过 index index_name 来强制指定索引；\n- 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；\n- 要注意索引的维护，周期性重建索引，重新编译存储过程；\n- 在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。例如对该字段的前20个字符建立索引（`ALTER table user ADD INDEX idx_desc(desc(20));`）；\n- 如果需要使用索引，不要使用uuid作为主键，不能保证其自增性，会导致数据库对B+树的操作更复杂。\n\n4、应尽可能的避免更新 Clustered 索引数据列， 因为 Clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 Clustered 索引数据列，那么需要考虑是否应将该索引建为 Clustered 索引。\n\n- 说明：聚集索引（Clustered Index）是一种SQL数据库中的索引类型，它对表中的数据行进行物理排序。每个表只能有一个聚集索引，因为它决定了数据行在磁盘上的物理存储顺序。这也意味着表中的数据行按照聚集索引的键列的值进行排序，并且物理存储位置与索引的结构紧密关联。\n<a name=\"mlW4c\"></a>\n# 三、数据库表的设计\n1、只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br />2、尽可能的使用 varchar, nvarchar 代替 char, nchar。\n\n- 说明：首先，变长字段存储空间小，可以节省存储空间；其次，对于查询来说，在一个相对较小的字段内搜索效率会更高。\n\n3、表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。\n\n- 说明：任何字段如果为非负数，必须是unsigned。\n- 正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。\n\n4、varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引率。<br />5、在数据库中不能使用物理删除操作，要使用逻辑删除。\n\n- 说明：逻辑删除在数据删除后可以追溯到行为操作。不过会使得一些情况下的唯一主键变得不唯一，需要根据情况来酌情解决。\n<a name=\"w5T7q\"></a>\n","categories":["数据库"]},{"title":"算法基础笔记","url":"/2023/06/15/算法基础笔记/","content":"> Author：辞寒\n> 所谓基础，指的是`base`，而非`easy`。—— yxc\n\n<a name=\"fhScF\"></a>\n\n## 第一章：基础算法\n\n<a name=\"KanrX\"></a>\n\n### 1. 1 快速排序$\\mathcal{O}(n \\log n)$：[快速排序](https://www.acwing.com/problem/content/787/)\n\n<a name=\"nVSic\"></a>\n\n#### 算法思想：分治\n\n1. 确定分界点 `x = q[l + r >> 1]`\n2. 调整区间：让第一个区间里的数小于等于`x`， 让第二个区间的数大于等于`x`\n3. 递归处理左右两边\n   <a name=\"ZXrlK\"></a>\n\n#### 代码实现：\n\n```java\npublic static void quick_sort(int[] q, int l, int r) {\n\tif(l >= r) return; // 如果左端点大于等于右端点，则直接返回，也为递归退出条件\n\tint i = l - 1, j = r + 1, x = q[l + r >> 1];\n\twhile(i < j) {\n\t\tdo i ++; while(q[i] < x);\n\t\tdo j --; while(q[j] > x);\n\t\tif(i < j) {\n\t\t\tint tmp = q[i];\n\t\t\tq[i] = q[j];\n\t\t\tq[j] = tmp;\n\t\t}\n\t}\n\tquick_sort(q, l, j);\n\tquick_sort(q, j + 1, r);\n}\n```\n\n<a name=\"Z30ax\"></a>\n\n### 1.2 归并排序$\\mathcal{O}(n \\log n)$\n\n<a name=\"PMNCs\"></a>\n\n#### 1.2.1 归并排序：[归并排序](https://www.acwing.com/problem/content/789/)\n\n<a name=\"oXI7a\"></a>\n\n##### 算法思想：分治\n\n1. 确定分界点 `mid = r + l >> 1`\n2. 递归处理左右两边\n3. 归并，将两个区间合二为一（从递归后的最顶层开始合并，每次回溯后达到排序的效果）($\\mathcal{O}(n)$)\n   <a name=\"DHETn\"></a>\n\n##### 代码实现：\n\n```java\npublic static void merge_sort(int[] q, int l, int r) {\n    if (l >= r) return;\n    int mid = l + r >> 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r); \n\n    int k = 0, i = l, j = mid + 1;\n    while (i <= mid && j <= r)\n        // tmp为辅助数组，用于临时存储归并数据，也是归并排序空间复杂度主要来源\n        if (q[i] <= q[j]) tmp[k ++] = q[i ++];\n        else tmp[k ++] = q[j ++];\n\n    while (i <= mid) tmp[k ++] = q[i ++];\n    while (j <= r) tmp[k ++] = q[j ++];\n\n    for (i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];\n}\n```\n\n<a name=\"rfvUw\"></a>\n\n#### 1.2.2 归并求逆序对：[逆序对的数量](https://www.acwing.com/activity/content/problem/content/822/)\n\n<a name=\"gu6yy\"></a>\n\n##### 代码实现：\n\n```java\npublic static long merge_sort(int l, int r) {\n    if(l >= r) return 0;\n    int mid = l + r >> 1;\n    int k = 0, i = l, j = mid + 1;\n    long res = merge_sort(l, mid) + merge_sort(mid + 1, r);\n    while(i <= mid && j <= r) \n        if(q[i] <= q[j]) tmp[k ++] = q[i ++];\n        else {\n            tmp[k ++] = q[j ++];\n            res += mid - i + 1;\n        }\n    while(i <= mid) tmp[k ++] = q[i ++];\n    while(j <= r) tmp[k ++] = q[j ++];\n    for(i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];\n    return res;\n}\n```\n\n<a name=\"LmlLz\"></a>\n\n### 1.3 整数二分$\\mathcal{O}(\\log n)$：[数的范围](https://www.acwing.com/problem/content/791/)\n\n<a name=\"nDrJV\"></a>\n\n#### 算法思想：\n\n1. 时时刻刻保证答案在所维护的区间内部。\n2. `check()`函数为满足条件部分，例如：`1、2、3、3、4、5`中，求`3`的起始位置，则所求位置在所有`3`范围的最左侧，于是需要保证每次`mid`需要在最左边一个`3`或其右侧，故`check()`函数为`if (q[mid] >= 3)`；若求`3`的最后位置，同理`check()`函数为`if (q[mid] <= 3)`。每次判断后需要调整区间端点，例如在求`3`的左端点时，如果满足`q[mid] >= 3`,则说明所求位置在`mid`左侧或就是`mid`，则将区间右端点更新为`mid`，即`r = mid`。\n3. 每次二分之前需将`l、r`初始化，**注意：** 更新时，若`r`被更新为`mid - 1`，则`mid`应初始化为`mid = l + r + 1 >> 1`，避免更新边界后范围不变，出现死循环。\n\n- 能使用二分的条件：必须要有**二段性**，即一定存在一个分界点，使得分界点一边(包括分界点)满足题目要求，另一边不满足。（参考[二分算法详解](http://smallboatc.github.io/2024/01/16/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/)）\n- 二分的题目有两种，一种是直接裸的二分题目，另一种则是枚举可能的答案，然后`check`这个答案是否**可行**。（二分答案）\n  <a name=\"bCFAX\"></a>\n\n#### 代码实现：\n\n```java\n// 检查x是否满足某种性质，不一定是一个函数，也可能是例如 if (a[mid] >= 3) 的简单形式\npublic static boolean check(int x) {/* ... */} \n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\npublic static int bsearch_1(int l, int r) {\n    while (l < r) {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid; // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\npublic static int bsearch_2(int l, int r) {\n    while (l < r) {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n```\n\n<a name=\"xwt7l\"></a>\n\n### 1.4 浮点数二分$\\mathcal{O}(\\log n)$：[数的三次方根](https://www.acwing.com/problem/content/792/)\n\n<a name=\"QDY11\"></a>\n\n#### 算法思想：\n\n算法原理与整数二分相似，在区间划分的时候没有整数二分的各种边界情况，一般用左右端点的差值是否小于某个值$\\epsilon$来判定是否需要继续循环。\n<a name=\"b5cNf\"></a>\n\n#### 代码实现：\n\n```java\n// 检查x是否满足某种性质\npublic static boolean check(double x) {/* ... */} \n\npublic static double bsearch_3(double l, double r) {\n    // eps 表示精度 epsilon，取决于题目对精度的要求，一般比题目保留小数位数大2\n    final static double eps = 1e-8;\n    while (r - l > eps) {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n```\n\n<a name=\"ZD5Bq\"></a>\n\n### 1.5 一维前缀和：[前缀和](https://www.acwing.com/problem/content/797/)\n\n<a name=\"aJwbp\"></a>\n\n#### 算法思想：\n\n- 在输入时，顺便记录前`i`项的和，`i`从`1 ~ n`，记为：`s[i]`，当需要求第`i`个数到第`j` 个数的和时，直接使用`s[j] - s[i - 1]`，时间复杂度为`O(1)`，比重新遍历更快。\n- 但是，如果数据会发生改变，则前缀和数组也会发生改变，而这种方式求解前缀和是$\\mathcal{O}(n)$的。则此时需要使用树状数组或者线段树进行求解（详见第二章`2.9`）。\n  <a name=\"Sa1Cj\"></a>\n\n#### 代码实现：\n\n```java\ns[i] = a[1] + a[2] + ... a[i]\n\n// 输入数组时顺带求出前缀和\nfor (int i = 1; i <= n; i ++) {\n    a[i] = sc.nextInt();\n    // sum[0] 默认为 0\n    sum[i] = sum[i - 1] + a[i];\n}\n\n// 只需要前缀和\nfor (int i = 1; i <= n; i ++) s[i] = s[i - 1] + sc.nextInt();\n\na[l] + ... + a[r] = s[r] - s[l - 1]\n```\n\n<a name=\"w7f5T\"></a>\n\n### 1.6 二维前缀和：[二维前缀和](https://www.acwing.com/problem/content/798/)\n\n<a name=\"ss2Vn\"></a>\n\n#### 算法思想：\n\n二维前缀和思想类似于一维前缀和，用`s[i][j]`表示以`(i,j)`为右下角，`(0,0)`为左上角的子矩阵中所有数之和。可用于求解以`(x1, y1)`为左上角，`(x2, y2)`为右下角的子矩阵的和为（可利用容斥原理推导）。\n<a name=\"viQAr\"></a>\n\n#### 代码实现：\n\n```java\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n\t// 求前缀和矩阵\n        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];\n// 求解以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和\nint res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n```\n\n<a name=\"ovvCL\"></a>\n\n### 1.7 一维差分：[差分](https://www.acwing.com/problem/content/799/)\n\n<a name=\"klHY9\"></a>\n\n#### 算法思想：\n\n- 实际上，差分与前缀和互为逆运算，例如，如果数组`s`为数组`a`的前缀和数组，那么`a`则称为`s`的差分数组，即`a[i] = s[i] - s[i - 1]`。\n- 差分数组的作用在于，如果需要对一个数组中的`l ~ r`区间的`k`个数字均加上`c`，则时间复杂度与`k`相关，而对其差分数组进行操作，则只需在其差分数组的第`l`项加`c`，再对第`r + 1`项减去`c`，时间复杂度降为$\\mathcal{O}(1)$。\n  <a name=\"hSUFq\"></a>\n\n#### 代码实现：\n\n```java\n// 插入操作，用于对差分数组的修改，a 数组初始化为 0\npublic static void insert(int l, int r, int c) {\n    a[l] += c;\n    a[r + 1] -= c;\n}\n\n// 读入需要操作的原数组\nfor (int i = 1; i <= n; i ++) s[i] = sc.nextInt(); \n\n/*\n利用插入操作，直接求解s数组的差分数组a。\n原理是在a[i]位置插入s[i]后，a[i + 1]会先减去s[i]，\n等到i = i + 1时，a[i + 1]的位置会加上s[i + 1]，则最终a[i + 1]位置上的数\n正好为s[i + 1] - s[i]，由定义可知，a正好构成s的差分数组\n*/\nfor (int i = 1; i <= n; i ++) insert(i, i, s[i]); \n\n// 当然，也可以直接根据定义求差分数组：a[i] = s[i] - s[i - 1];\n\n// 该操作可能会有很多组，直接对s数组操作时间复杂度较高，则对其差分数组操作，最后统一求一次前缀和即可得到新的s数组\nint l = sc.nextInt(), r = sc.nextInt(), c = sc.nextInt();\ninsert(l, r, c);\n\n// 求一遍前缀和\nfor (int i = i; i <= n; i ++) b[i] += b[i - 1]; \n```\n\n<a name=\"uHO1j\"></a>\n\n### 1.8 二维差分：[差分矩阵](https://www.acwing.com/problem/content/800/)\n\n<a name=\"oOJrb\"></a>\n\n#### 算法思想：\n\n- 类似于一维差分，二维差分与二维前缀和互为逆运算，例如，数组`s`是数组`b`的前缀和数组，那么`b`就称为`s`差分数组。\n- 二维差分数组的作用在于，如果需要对二维矩阵中以`(x1, y1)`为左上角，`(x2, y2)`为右下角的区域内每个数加上`c`，那么可以对差分矩阵中`b[x1][y1]`加上`c`，对`b[x2 + 1][y1]`与`b[x1][y2 + 1]`减去`c`，再对`b[x2 + 1][y2 + 1]`减去`c`。因为对`b[x1][y1]`，将会导致求前缀和后，`s[x1][y1]`到右下角这部分区域每个数都加上`c`，因此，根据容斥原理，需对其他部分进行如上处理。\n- 同时，与一维差分类似，二维差分也不用去想如何构造差分数组，也可以利用插入操作完成。\n  <a name=\"NmWSH\"></a>\n\n#### 代码实现：\n\n```java\n// 插入操作，用于对差分数组b进行修改，同时可以用来构造差分数组b\npublic static void insert(int x1, int y1, int x2, int y2, int c) {\n    b[x1][y1] += c; // 加c后右下角都将+c\n    b[x2 + 1][y1] -= c; // 需要对b[x2 + 1][y1]右下角减去一个c使其保持不变\n    b[x1][y2 + 1] -= c; // 需要对b[x1][y2 + 1]右下角减去一个c使其保持不变\n    b[x2 + 1][y2 + 1] += c; // b[x2 + 1][y2 + 1]右下角被减了两次，需要加一次补回来\n}\n\n// 读入需要操作的二维数组\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        s[i][j] = sc.nextInt();\n\n// 求差分数组 b\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        insert(i, j, i, j, s[i][j]);\n\n// 对原数组 O(n) 的操作等价于对差分数组 O(1) 的操作\nint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt(), c = sc.nextInt();\ninsert(x1, y1, x2, y2, c);\n\n// 对 b 数组求一遍前缀和\nfor (int i = 1; i <= n; i ++)\n    for (int j = 1; j <= m; j ++)\n        b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];\n```\n\n<a name=\"d3Hnq\"></a>\n\n### 1.9 双指针： [最长连续不重复子序列](https://www.acwing.com/problem/content/801/)\n\n<a name=\"K7CEY\"></a>\n\n#### 算法思想：\n\n- 双指针算法是优化枚举最常用的算法，其核心思想在于通过找到单调性，将$\\mathcal{O}(n^2)$的暴力枚举转变成$\\mathcal{O}(n)$的双指针算法。\n- 该算法有两类，第一类为类似于归并排序中，在两个区间上归并的操作。第二类则在一个区间上动态维护一个小区间。\n  <a name=\"QzOAd\"></a>\n\n#### 代码实现：\n\n```java\n// 第一类同归并排序中两个指针同时扫描两个数组\n\n// 第二类\nfor (int i = 0, j = 0; i < n; i ++) {\n    while (j < i && check(i, j)) j ++; // j < i 也可以根据具体逻辑适当调整，check()为检验是否满足某一性质\n    // 具体问题的逻辑\n}\n```\n\n<a name=\"pIInD\"></a>\n\n#### 最长连续不重复子序列题解（第二类）：\n\n**题目描述：**<br />给定一个长度为`n`的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br />**输入格式：**<br />第一行包含整数`n`。<br />第二行包含`n`个整数，表示整数序列。<br />**输出格式：**<br />共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br />**数据范围：**<br />$1 \\leq n\\leq 10^5$<br />**输入样例：**\n\n```\n5\n1 2 2 3 5\n```\n\n**输出样例：**\n\n```\n3\n```\n\n**双指针算法**$\\mathcal{O}(n)$**：**<br />定义两个指针`i, j`，数组`a`，`i`从第一个元素开始往后走，每经过一个元素，用`s`数组记录当前数字出现的次数，当走到某个元素`a[i]`时，若`s[a[i]] > 1`，则说明该数字前面出现过一次，此时让`j`指针向后走，`j`指针每经过一个元素，就让该元素出现次数就减一，当不满足`s[a[i]] > 1`时，说明`j`刚好经过与`a[i]`重复的那个数值，则此时`j`不再向后走，记录`j ~ i`之间元素个数，然后`i`继续向后走，重复此过程，直到走完整个数组。\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\n    static final int N = 100010;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int[] s = new int[N]; // 用于记录每位数出现的次数\n\n        for (int i = 0; i < n; i ++)\n            a[i] = sc.nextInt();\n\n        int res = 0;\n        for (int i = 0, j = 0; i < n; i ++) {\n            s[a[i]] ++; // 每次 i 往后走，相应的数字出现的次数就自增\n            while (j < i && s[a[i]] > 1) {\n                s[a[j]] --; // 让 j 经过的数字出现的次数减一\n                j ++; // j 往后走\n            }\n            // 这一步就算没有遇到重复元素也会计算最长不连续数目\n            res = Math.max(res, i - j + 1); \n        }\n        System.out.println(res);\n    }\n}\n```\n\n> 这道题还有滑动窗口解法，滑动窗口更好理解，许多双指针理解起来较为抽象的题目均可使用滑动窗口解决，详见第二章`2.5`滑动窗口模板。\n\n<a name=\"b3uG4\"></a>\n\n### 1.10 位运算：[二进制中1的个数](https://www.acwing.com/problem/content/803/)\n\n<a name=\"gIDbD\"></a>\n\n#### 算法思想：\n\n该部分不存在什么思想，更多的是语法，会用即可。<br />**用法一：** 求`n`的二进制表示中第`k`位（从右往左看，最右边为第`0`位）数字。**原理：** n >> k & 1。<br />**用法二：**`lowbit`操作，返回`x`的最后一位`1`，例如`x = (1010)₂`，则`lowbit(x) = 10`；若`x = (101000)₂`，则`lowbit(x) = 1000`，具体见代码实现。**原理：** 因为`x & -x = x & (~x + 1)`，而`x & (~x + 1)`能返回`x`的最后一位`1`，所以一般用`x & -x`求解`x`的最后一位`1`。（`lowbit`操作是树状数组的基础。）\n<a name=\"yGatg\"></a>\n\n#### 代码实现：\n\n```java\n// 用法一：求 n 的二进制表示中第 k 位数字\nint res = n >> k & 1;\n\n// 用法二：返回 x 的最后一位 1\npublic static int lowbit(int x) {\n    return x & -x;\n}\n\n// 求解一个二进制数中含有多少个1的问题时，可以每次减去最后一位1（用lowbit实现），减了多少次就代表有多少个1（状态压缩常用）\n// 或者使用 Integer 的静态方法 bitCount\nint cnt = Integer.bitCount(x);\n```\n\n<a name=\"e5nZx\"></a>\n\n### 1.11 离散化：[离散化](https://www.acwing.com/problem/content/804/)\n\n<a name=\"RuxyK\"></a>\n\n#### 算法思想：\n\n离散化的思想是将数值范围很大，但是数据量不大的一系列数映射到从`0`开始的有序递增的区间，从而降低算法的时间和空间复杂度。离散化不改变数据间的相对大小，压缩数据间无用的距离。例如，`1, 3, 200, 48, 67349, 6546646`这一系列数的范围为`1 ~ 6546646`，中间有许多无用的距离，我们将其压缩到`0 ~ 5`这几个位置（有时映射到从`1`开始更加方便），此时就产生了映射关系`0 -> 1, 1 -> 3, 2 -> 48, 3 -> 200, 4 -> 67349, 5 -> 6546646`。这与直接开一个数组将他们存进去再排序是有本质区别的，例如我们想对`200`这个值加上`50`，如果直接开数组，想要找到`200`这个值，需要遍历一遍，而如果是通过离散化映射，我们可以直接利用映射关系找到在什么位置，然后直接进行操作，该步骤时间复杂度直接降低到$\\mathcal{O}(1)$。在映射之前，我们需要对数据进行排序，便于后面用整数二分找到每个数对应的映射值（下标）。同时需要对数据进行去重，因为即使有两个`200`，我们每次对`200`操作时，也是在同一个位置上进行操作的，因此重复的那个`200`不但没有存在的意义，反而影响在二分时寻找其映射值（下标）。\n<a name=\"UmYOB\"></a>\n\n#### 代码实现：\n\n```java\n// 将所有值排序，然后去重\nArrays.sort(alls); \n\n// 二分找到每个数离散化后的值（核心）\npublic static int find(int x) {\n    int l = 0, r = alls.size() - 1;\n    while (l < r) {\n        int mid = l + r >> 1;\n        if (alls[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    // 将离散化后的值映射到 1 ~ n，便于可能需要求前缀和的情况。\n    return r + 1;\n}\n```\n\n<a name=\"XdJSs\"></a>\n\n### 1.12 区间合并：[区间合并](https://www.acwing.com/problem/content/805/)\n\n<a name=\"on9RB\"></a>\n\n#### 算法思想：\n\n区间合并是将数轴上所有有交集的区间进行合并，得到没有交集的区间。例如将区间`[0, 2], [3, 7], [4, 5], [7, 10], [13, 15]`合并后的区间为`[0, 2], [3, 10], [13, 15]`。其思想类似于贪心，先将所有区间按照左端点进行排序，每次维护一个区间，**如果**枚举的区间与当前区间无交集，则将维护的区间放入答案中去，再将维护的区间更新为枚举的区间，**否则**将维护的区间的右端点更新为维护区间与枚举区间右端点的最大值。\n<a name=\"xxgs3\"></a>\n\n#### 代码实现：\n\n```java\nclass PII implements Comparable<PII> {\n    int x, y;\n    public PII(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    public int compareTo(PII p) {\n        return x - p.x;\n    }\n}\n\n// 将所有区间合并\npublic static ArrayList<PII> merge(ArrayList<PII> segs) {\n    ArrayList<PII> res = new ArrayList();\n    Collections.sort(segs);\n    int l = -2000000000, r = -2000000000;\n    for (var seg : segs)\n        if (seg.x > r) {\n            if (l != -2000000000)\n                res.add(new PII(l, r));\n            l = seg.x;\n            r = seg.y;\n        }\n        else r = Math.max(r, seg.y);\n\n    if (l != -2000000000) res.add(new PII(l, r));\n    return res;\n}\n```\n\n<a name=\"fJFhl\"></a>\n\n#### 新总结的模板（2024-03-12）：\n\n```java\n// 求合并后的区间个数\nimport java.util.*;\n\npublic class Main {\n    static class Segement implements Comparable<Segement> {\n        int x, y;\n        public Segement(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public int compareTo(Segement s) {\n            if (x != s.x) return x - s.x;\n            return s.y - y;\n        }\n    }\n    static final int N = 100010;\n    static Segement[] segments = new Segement[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 0; i < n; i ++) \n            segments[i] = new Segement(sc.nextInt(), sc.nextInt());\n        Arrays.sort(segments, 0, n);\n        int lastEnd = segments[0].y, res = 1;\n        for (int i = 1; i < n; i ++) {\n            int x = segments[i].x, y = segments[i].y;\n            if (y <= lastEnd) continue;\n            if (x > lastEnd) res ++;\n            lastEnd = y;\n        }\n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"r4jwx\"></a>\n\n## 第二章：数据结构\n\n> `2.1 ~ 2.3节`在算法题中一般不会被直接用到，但是却是后面的邻接表（图论）和单调栈及单调队列的基础。\n\n<a name=\"hfS0i\"></a>\n\n### 2.1 单链表：[单链表](https://www.acwing.com/problem/content/828/)\n\n<a name=\"KWRjs\"></a>\n\n#### 算法思想：\n\n- 该部分主要通过数组模拟单链表，进行插入结点、删除结点等操作。之所以需要用数组进行模拟，是因为在`C ++`或`java`中，`new`操作是非常慢的，在数据范围比较大的情况和容易`TLE`，并且，在很多时候，容器可以做的数组都可以做，而数组可以做的，容器不一定可以做。那么利用数组模拟就显得十分有优势。通过数组模拟单链表，需要定义`head, e[], ne[], idx`，其中`head`表示头结点，`e[]`表示每个点的值，`ne[]`表示每个点所指向的下一个点的下标，`idx`表示当前已经用到了哪个点（此时`idx`还没被用）。\n- 该部分是后面邻接表（图论）部分的基础，十分重要。\n  <a name=\"X5uDH\"></a>\n\n#### 代码实现：\n\n```java\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nstatic int head;\nstatic int[] e = new int[N];\nstatic int[] ne = new int[N];\nstatic int idx;\n\n// 初始化\npublic static void init() {\n    head = -1;\n    idx = 0;\n}\n\n// 在表头插入一个数x\npublic static void addHead(int x) {\n    e[idx] = x;\n    ne[idx] = head;\n    // 此时 idx 未被使用过，现在使用 idx\n    head = idx;\n    // idx 移动到下一个位置备用\n    idx ++;\n}\n\n// 在下标为k的结点后面插入一个数x\npublic static void add(int k, int x) {\n    e[idx] = x;\n    ne[idx] = ne[k];\n    ne[k] = idx;\n    idx ++;\n}\n\n// 删除下标为k的结点后面的一个结点\npublic static void remove(int k) {\n    if (k == 0 && head != -1) head = ne[head]; // 特判是否为头结点，删除头结点时需要判断头结点是否存在\n\telse ne[k] = ne[ne[k]];\n}\n\n// 单链表的遍历\nfor (int i = head; i != -1; i = ne[i]) System.out.printf(\"%d \", e[i]);\n```\n\n<a name=\"LD5fE\"></a>\n\n### 2.2 双链表：[双链表](https://www.acwing.com/problem/content/829/)\n\n<a name=\"z7DAc\"></a>\n\n#### 算法思想：\n\n与单链表相似，用数组模拟双链表。需定义数组`e, l, r`和变量`idx`，其中`e`表示每个结点的值，`l`表示结点的上一个结点下标，`r`表示结点的下一个结点下标，`idx`表示当前用到了哪个点（此时`idx`还未被使用）。\n<a name=\"YAAEH\"></a>\n\n#### 代码实现：\n\n```java\nint e[N], l[N], r[N], idx;\n\n// 初始化链表\npublic static void init() {\n    // 0是左端点，1是右端点\n    r[0] = 1;\n    l[1] = 0;\n    idx = 2;\n}\n\n// 在节点k的右边插入一个数x\npublic static void insert(int k, int x) {\n    e[idx] = x;\n    l[idx] = k;\n    r[idx] = r[k];\n    l[r[k]] = idx;\n    r[k] = idx ++ ;\n}\n\n// 删除节点k\npublic static void remove(int k) {\n    // 先后顺序无所谓\n    l[r[k]] = l[k];\n    r[l[k]] = r[k];\n}\n\n// 遍历双链表\nfor (int i = r[0]; i != 1; i = r[i]) System.out.printf(\"%d \", e[i]);\n```\n\n<a name=\"HQyEP\"></a>\n\n### 2.3 栈和队列：[模拟栈](https://www.acwing.com/activity/content/problem/content/865/)[模拟队列](https://www.acwing.com/activity/content/problem/content/866/)\n\n<a name=\"tfBfT\"></a>\n\n#### 算法思想：\n\n用数组模拟栈和队列，操作相对简单，具体见代码实现。\n<a name=\"ynhRH\"></a>\n\n#### 代码实现：\n\n```java\n// 数组模拟栈\nstatic int[] stk = new int[N];\nstatic int tt = 0; // 栈顶指针\nstk[ ++ t] = x; // 在栈顶插入x\ntt --; // 栈顶元素出栈\n\n// 数组模拟队列\nstatic int[] queue = new int[N];\nstatic int hh = 0, tt = -1;\nqueue[ ++ tt] = x; // 在队尾插入元素x\nhh ++; // 弹出队头元素\n```\n\n<a name=\"q0EF5\"></a>\n\n### 2.4 单调栈：[单调栈](https://www.acwing.com/activity/content/problem/content/867/)\n\n<a name=\"YPTUg\"></a>\n\n#### 算法思想：\n\n单调栈用于维护一个递增或递减的序列，可以快速求出每个数左/右边离它最近的比它**大/小**的数。\n<a name=\"dBq3R\"></a>\n\n#### 代码实现：\n\n```java\nstatic final int N = 100010;\nint[] stk = new int[N];\n\nint n = sc.nextInt();\nint tt = 0;\nfor (int i = 0; i < n; i ++) {\n    int x = sc.nextInt();\n    while(tt > 0 && check(stk[tt])) tt --; // check为具体题目的判断\n    if (tt > 0) System.out.printf(\"%d \", stk[tt]);\n    else System.out.printf(\"%d \", -1);\n    stk[++ tt] = x; // 插入新元素\n}\n```\n\n<a name=\"Zm2Jf\"></a>\n\n### 2.5 单调队列：[滑动窗口](https://www.acwing.com/activity/content/problem/content/868/)\n\n<a name=\"alsl0\"></a>\n\n#### 算法思想：\n\n- 单调队列与单调栈比较类似，用一个队列动态维护一组有序序列。每次先判断队头是否需要出栈，然后从队尾开始向前检查队尾元素与当前枚举元素的关系，如果满足`check(a[i])`，则让队尾元素弹出，直到队尾元素不满足条件。最后再将当前枚举元素加入队列。值得注意的是，队列`q[]`存储的是数组中元素的下标。\n- 该算法常用的场景为求解滑动窗口中的最大值或最小值、单调队列优化 **`dp`**。\n- [Leetcode一题秒懂单调队列！](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/)（利用Deque实现单调队列）\n  <a name=\"dVo8o\"></a>\n\n#### 代码实现：\n\n```java\nint[] a = new int[N]; // 存储所有元素\nint[] q = new int[N]; // 用于动态维护队列，存储的是元素下标\n\n// n表示所有元素个数， k表示单调队列的大小\nint n = sc.nextInt(), k = sc.nextInt();\n\n// 这里的tt初始值是有说法的，如果队列开始没有元素，则tt = -1，否则tt = 0;\nint hh = 0, tt = -1;\nfor (int i = 0; i < n; i ++) {\n    if (hh <= tt && i - k + 1 > q[hh]) hh ++; // 判断队头元素是否需要出队\n    while (hh <= tt && a[i] <= a[q[tt]]) tt --; // 判断队尾元素是否需要弹出，a[i] <= a[q[tt]]可根据题目具体条件更换\n    q[++ tt] = i; // 将枚举的元素插入队尾\n}\n```\n\n> `tt = 0` 和 `tt = -1`的情况可参考[烽火传递](https://www.acwing.com/activity/content/problem/content/9808/)与[E. Rudolf and k Bridges](https://www.acwing.com/solution/content/235596/)这两题。\n\n<a name=\"vMWEj\"></a>\n\n#### 子串类问题(滑动窗口算法框架)：\n\n> 注意：单调队列并不一定对所有的滑动窗口题目好用，只是上面这道题使用单调队列能完美解决。当涉及到字串类问题时，优先选择滑动窗口框架。\n\n> 看不懂模板可以先做做[Leetcode 438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)，再看这个模板框架。\n\n```java\n/* 滑动窗口算法框架 */\npublic static void slidingWindow(String s, String p) {\n    char[] cs = s.toCharArray(), cp = p.toCharArray();\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    int L = p.length();\n    for (int i = 0; i < L; i ++) {\n        need.put(cp[i], need.getOrDefault(cp[i], 0) + 1);\n    }\n    // 有的题目只有一个字符串，甚至都不需要 need 和 valid\n    int n = s.length(), m = need.size();\n    int left = 0, right = 0;\n    int valid = 0;\n    while (right < n) {\n        // c 是将移入窗口的字符\n        char c = cs[right];\n        // 右指针后移\n        right ++;\n        // 进行窗口内数据的一系列更新（主要是将元素抓进窗口）\n        ...\n        /**\n        示例：\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c).equals(need.get(c))) {\n                // 如果窗口中的字符c已经够了，则需求数量的字母多了一个\n                valid ++;\n            }\n        }\n        */\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // if (right - left == L) res.add(left); 根据具体题目修改\n            // d 是将移出窗口的字符\n            char d = cs[left];\n            // 左指针后移\n            left ++;\n            // 进行窗口内数据的一系列更新（主要是将元素驱出窗口）\n            ...\n            /**\n            示例：\n            if (need.containsKey(d)) {\n                if (window.get(d).equals(need.get(d))) {\n                    valid --;\n                }\n                window.put(d, window.get(d) - 1);\n            }\n            */\n        }\n    }\n}\n```\n\n<a name=\"J0QJw\"></a>\n\n### 2.6 KMP算法：[KMP字符串](https://www.acwing.com/activity/content/problem/content/869/)\n\n<a name=\"OpmSj\"></a>\n\n#### 算法思想：\n\n`kmp`算法是比较经典的字符串匹配算法，`kmp`是其三个发明人名字缩写。`kmp`算法是将模式串`P`与主串`S`进行匹配，其核心思想是将已经匹配过的字符利用起来，例如主串`S`为`abaabac`，模式串`P`为`abac`，当匹配到第四个字符发现不匹配时，主串中前三个字符已经匹配成功，我们可以将这个信息利用起来，那么下次匹配可以将`P`串的第一个字符直接与`S`串的第四个字符开始匹配，跳过了中间的一段，从而降低算法时间复杂度。而`P`串最少可以往前移动多少且可能匹配成功只取决于`P`串本身以`P[i]`结束的字串的前缀和后缀相等的最大值`(next[i])`，这便是`KMP`算法中比较抽象的`next`数组的含义。\n\n> 掌握`kmp`算法的同时建议掌握**字符串哈希**，很多抽象的`kmp`题目能够使用字符串哈希通过。\n\n<a name=\"XOuo1\"></a>\n\n#### 代码实现：\n\n```java\n// s[]为主串，p[]为模式串，n为模式串的长度， m为主串的长度\n// 求next数组\nfor (int i = 2, j = 0; i <= n; i ++) { // ne[1] = 0\n    // 当不能匹配时，j跳转到ne[j]处\n    while (j != 0 && p[i] != p[j + 1]) j = ne[j]; \n    // 若能够匹配，则让j向后走一位\n    if (p[i] == p[j + 1]) j ++; \n    ne[i] = j;\n}\n\n// 匹配过程\nfor (int i = 1, j = 0; i <= m; i ++) {\n    while (j != 0 && s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j ++;\n    // 当j走到p串末尾时，则说明一个匹配完成，即在s串中找到一个子串与p串完全相同\n    if (j == n) { \n        // 匹配成功。之所以匹配成功还需要 j = ne[j]是因为一个主串里可能包含多个模式串(为下一段匹配做准备)\n        j = ne[j]; \n        // 每道题的具体逻辑，这里是输出匹配成功的开始下标\n        bw.write(i - n + \" \"); \n    }\n}\nbw.flush();\n\n// tip：最小循环节长度：i - ne[i]\n```\n\n<a name=\"hMsgG\"></a>\n\n### 2.7 Trie树/字典树：[字符串统计](https://www.acwing.com/problem/content/837/)\n\n<a name=\"mIUZw\"></a>\n\n#### 算法思想：\n\n`Tree`树是一种用于存储字符串的高效的数据结构，以一棵树的形式存储字符串中的每个字符，如果该字符已经存在，则不重新创建，否则创建该字符，并在树中每个字符串结尾的地方做标记，表示树中含有以该字符结尾的字符串。<br />![Trie树.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_5949ec9ed8-Trie树.png)\n<a name=\"v9hti\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[][] son = new int[N][26]; // 表示每个字符的所有儿子结点\nstatic int idx; // 表示当前son中用到了哪个下标\nstatic int[] cnt = new int[N]; // 表示以cnt[p]这个字符结尾的字符串个数\n\n// 插入字符串到Trie树中\npublic static void insert(char[] str) {\n    // 从根节点开始找\n    int p = 0;\n    // 遍历要插入字符串的每个字符\n    for (int i = 0; i < str.length; i ++) {\n        // 将该字符转换为0 ~ 25的数字\n        int u = str[i] - 'a';\n        // 如果p结点不存在u这个儿子，则创建一个，son[p][u] == 0表示指向空节点，开始时也是根节点，没有子节点也指向空节点\n        if(son[p][u] == 0) son[p][u] = ++ idx; \n        // 然后更新p的位置，p往后走一个（对于存在的往后走一个，对于不存在这个字母的，上一步创建了，也往后走一个位置）\n        p = son[p][u];\n    }\n    // 添加成功后将以p位置结尾的这个字符串数量 +1\n    cnt[p] ++;\n}\n\n// 查询字符串是否在Trie树中\npublic static int query(char[] str) {\n    int p = 0;\n    for (int i = 0; i < str.length; i ++) {\n        int u = str[i] - 'a';\n        // 如果发现某个字符在当前查询的路线中不存在，则说明该字符串不在树中，直接返回0个\n        if (son[p][u] == 0) return 0;\n        // 更新p的位置\n        p = son[p][u];\n    }\n    // 返回以p位置处的字符结尾的字符串个数\n    return cnt[p];\n}\n```\n\n<a name=\"CChR3\"></a>\n\n### 2.8 并查集：[连通块中点的数量](https://www.acwing.com/problem/content/839/)\n\n<a name=\"yxFnq\"></a>\n\n#### 算法思想：\n\n- 并查集的作用是在$\\mathcal{O}(1)$的时间内将两个集合合并。其原理为：让一个集合的根节点直接指向另一个集合的根节点，成为另一个集合的一个子集。可以通过寻找一个节点的祖宗节点判断该元素属于哪个集合，其时间复杂度与树的高度相关，所以，需要对其进行优化。\n- **优化思想** ：将每个节点直接指向其祖宗节点，该操作是在寻找祖宗节点的回溯过程中完成的。\n- 查找两个点是否在同一个集合当中时，可以通过其祖宗节点是否是同一个节点进行判断。\n- **规定：** 祖宗节点的父节点等于自己（递归的退出条件）\n  <a name=\"ut2oA\"></a>\n\n#### 代码实现：\n\n```java\n// find函数，并查集的核心\npublic static int find(int x) {\n    if(p[x] != x) p[x] = find(p[x]);\n\treturn p[x];\n}\n\n// 初始化父亲数组，即每个节点开始都是一个集合\nfor (int i = 1; i <= n; i ++) p[i] = i; \n\n// 将a, b两个点合并进一个集合，此处很容易出错(将b的祖宗节点变为a的祖宗节点的父亲)\np[find(a)] = find(b); \n\n// 判断两个点是否在同一个集合\nif (find(a) == find(b))\n```\n\n<a name=\"uYOuo\"></a>\n\n### 2.9 树状数组：[动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)\n\n<a name=\"Hhncl\"></a>\n\n#### 算法思想：\n\n树状数组是一种能在$\\mathcal{O}(\\log n)$时间复杂度内修改某个数，并动态求出前缀和的数据结构。<br />能够在$\\mathcal{O}(\\log n)$内求出前缀和的原因：动态维护了一个数组（树状数组）。<br />为什么树状数组修改某个数需要$\\mathcal{O}(\\log n)$：我们是在维护的树状数组上进行修改的，因此需要修改该数并维护该树状数组。\n\n> 注意，树状数组的下标必须从`1`开始，否则会死循环，因为$lowbit(x) \\equiv 0$。\n\n**树状数组的三个核心方法：**\n\n- `lowbit`：用于定位其关联的数组元素下标；\n- `add`：对元素增加一个值（修改操作需要转为增加操作来完成）；\n- `query`：查询以某个下标结尾的前缀和。\n\n![2.9 树状数组.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_885f94f6d8-2.9-树状数组.png)\n<a name=\"cmLwp\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 100010;\n    static int[] a = new int[N], tr = new int[N];\n    static int n, m;\n    public static int lowbit(int x) {\n        return x & -x;\n    }\n    public static void add(int x, int v) {\n        for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;\n    }\n    public static int query(int x) {\n        int res = 0;\n        for (int i = x; i > 0; i -= lowbit(i)) res += tr[i];\n        return res;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) a[i] = sc.nextInt();\n        for (int i = 1; i <= n; i ++) add(i, a[i]);\n        while (m -- > 0) {\n            int k = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();\n            if (k == 0) System.out.println(query(y) - query(x - 1));\n            else add(x, y);\n        }\n    }\n}\n```\n\n<a name=\"wo62f\"></a>\n\n### 2.10 线段树：[数列区间最大值](https://www.acwing.com/problem/content/1272/)，[动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)\n\n<a name=\"yeT0z\"></a>\n\n#### 算法思想：\n\n线段树是一种能在$\\mathcal{O}(\\log n)$内求出一段区间内的某个属性（`最大值`、`最小值`、`sum`等）的数据结构。\n\n> 一般来说，树状数组能干的，线段树都能干，因为线段树更加灵活。但是，由于线段树的常数太大，所以会比树状数组慢比较多。\n\n**线段树的四个核心方法：**\n\n- `pushup`：用子节点的信息更新当前节点信息（有时不用显式的写出）；\n- `build`：在一段区间上初始化线段树；\n- `modify`：修改某个数的属性，同时维护线段树；\n- `query`：查询属性。\n\n![2.10线段树.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_e60477acd8-2.10线段树.png)\n<a name=\"TXA2l\"></a>\n\n#### 代码实现：\n\n- [数列区间最大值](https://www.acwing.com/problem/content/1272/)：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static class Segment {\n        int l, r, max;\n        public Segment(int l, int r, int max) {\n            this.l = l;\n            this.r = r;\n            this.max = max;\n        }\n    }\n    static final int N = 100010;\n    static int[] w = new int[N];\n    static Segment[] tr = new Segment[4 * N];\n    \n    public static void build(int u, int l, int r) {\n        if (l == r) tr[u] = new Segment(l, r, w[r]);\n        else {\n            tr[u] = new Segment(l, r, 0);\n            int mid = l + r >> 1;\n            build(u << 1, l, mid);\n            build(u << 1 | 1, mid + 1, r);\n            // 其实就是 pushup，只是没有单独写一个pushup函数\n            tr[u].max = Math.max(tr[u << 1].max, tr[u << 1 | 1].max);\n        }\n    }\n    \n    public static int query(int u, int l, int r) {\n        if (tr[u].l >= l && tr[u].r <= r) return tr[u].max;\n        int mid = tr[u].l + tr[u].r >> 1;\n        int max = Integer.MIN_VALUE;\n        if (l <= mid) max = query(u << 1, l, r);\n        if (r > mid) max = Math.max(max, query(u << 1 | 1, l, r));\n        return max;\n    }\n    \n    public static void main (String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]), m = Integer.parseInt(s1[1]);\n        String[] s2 = br.readLine().split(\" \");\n        for (int i = 1; i <= n; i ++) w[i] = Integer.parseInt(s2[i - 1]);\n        build(1, 1, n);\n        while (m -- > 0) {\n            String[] s = br.readLine().split(\" \");\n            int x = Integer.parseInt(s[0]), y = Integer.parseInt(s[1]);\n            bw.write(query(1, x, y) + \"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n\n- [动态求连续区间和](https://www.acwing.com/activity/content/problem/content/1719/)：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static class Segment {\n        int l, r, sum;\n        public Segment(int l, int r, int sum) {\n            this.l = l;\n            this.r = r;\n            this.sum = sum;\n        }\n    }\n    static final int N = 100010;\n    static Segment[] tr = new Segment[4 * N];\n    static int[] w = new int[N];\n\n    // 显示的将pushup写出\n    public static void pushup(int u) {\n        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;\n    }\n    \n    public static void build(int u, int l, int r) {\n        if (l == r) tr[u] = new Segment(l, r, w[r]);\n        else {\n            tr[u] = new Segment(l, r, 0);\n            int mid = l + r >> 1;\n            build(u << 1, l, mid);\n            build(u << 1 | 1, mid + 1, r);\n            pushup(u);\n        }\n    }\n    \n    public static int query(int u, int l, int r) {\n        if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;\n        int mid = tr[u].l + tr[u].r >> 1;\n        int res = 0;\n        if (l <= mid) res = query(u << 1, l, r);\n        if (r >= mid + 1) res += query(u << 1 | 1, l, r);\n        return res;\n    }\n    \n    public static void modify(int u, int x, int v) {\n        if (tr[u].l == tr[u].r) tr[u].sum += v;\n        else {\n            int mid = tr[u].l + tr[u].r >> 1;\n            if (x <= mid) modify(u << 1, x, v);\n            else modify(u << 1 | 1, x, v);\n            pushup(u);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) w[i] = sc.nextInt();\n        build(1, 1, n);\n        while (m -- > 0) {\n            int k = sc.nextInt(), x = sc.nextInt(), y = sc.nextInt();\n            if (k == 0) System.out.println(query(1, x, y));\n            else modify(1, x, y);\n        }\n    }\n}\n```\n\n<a name=\"tETKk\"></a>\n\n### 2.11 字符串哈希：[字符串哈希](https://www.acwing.com/problem/content/843/)\n\n<a name=\"kOQld\"></a>\n\n#### 算法思想：\n\n这里的字符串哈希是一种特殊的哈希方式，即字符串前缀哈希，其思想是将字符串转换为一个`P`进制的数，`P`的经验取值为`131`或`13331`。<br />例如，将`SmallBoat`转换为`P`进制的数（该字符串的哈希值）为：$H[n] = H[9] = H[n - 1] \\times P + str[n] = H[8] \\times P + str[9]$\n\n> 计算时会自动将字母转换为对应的`ASCII`编码值\n\n那么，给定任意的$l, r \\in [0, n - 1]$，$l \\sim r$这段字符的哈希值为：$H[l \\sim r] = H[r] - H[l - 1] \\times P^{r - l + 1}$\n<a name=\"MsqUB\"></a>\n\n#### 代码实现：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 100010, P = 131;\n    static long[] h = new long[N], p = new long[N];\n    static int n, m;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] s1 = br.readLine().split(\" \");\n        n = Integer.parseInt(s1[0]); m = Integer.parseInt(s1[1]);\n        char[] str = (\" \" + br.readLine()).toCharArray();\n        \n        p[0] = 1;\n        for (int i = 1; i <= n; i ++) {\n            p[i] = p[i - 1] * P;\n            h[i] = h[i - 1] * P + str[i];\n        }\n        \n        while (m -- > 0) {\n            String[] s2 = br.readLine().split(\" \");\n            int l1 = Integer.parseInt(s2[0]), r1 = Integer.parseInt(s2[1]);\n            int l2 = Integer.parseInt(s2[2]), r2 = Integer.parseInt(s2[3]);\n            if (getHash(l1, r1) == getHash(l2, r2)) bw.write(\"Yes\\n\");\n            else bw.write(\"No\\n\");\n        }\n        bw.flush();\n    }\n    public static long getHash(int l, int r) {\n        // 注意公式正确性，并非 (h[r] - h[l]) * p[r - l + 1]\n        return h[r] - h[l - 1] * p[r - l + 1];\n    }\n}\n```\n\n<a name=\"eNGWs\"></a>\n\n## 第三章：搜索与图论\n\n<a name=\"ZEgA6\"></a>\n\n### 3.1 树与图的存储：\n\n- 树是一种特殊的图，所以只需要会图的存储方式即可。在图中，无向图又是特殊的有向图，例如，对于一无向边`a -- b`，只需要存储两条有向边即可，即`a -> b、b -> a`，故只需要会有向图的存储即可。\n- 图的存储常用的有两种，分别为**邻接矩阵**和**邻接表**存储法。一般用邻接矩阵存储稠密图，即使用二维数组`g[][]`存储，`g[a][b]`表示一条由`a`指向`b`权值为`g[a][b]`的边。使用邻接表存储稀疏图，`h[]`存储每一条单链表的头结点，`e[]`存储每个顶点的值，`ne[]`存储每个顶点的邻点的下标，有时还会用`w[]`存储边的权重。\n  <a name=\"Sdawu\"></a>\n\n### 3.2 树与图的遍历：\n\n<a name=\"w0r6P\"></a>\n\n#### 3.2.1 DFS：\n\n<a name=\"G5wPU\"></a>\n\n##### 注意：\n\n- 在`dfs`过程中，必要时需要**恢复现场**，同时对于有的问题需要进行**剪枝**，如`n`皇后问题。\n  <a name=\"bB05L\"></a>\n\n##### 代码实现：\n\n```java\npublic static void dfs(int u) {\n    if (check()) return; // dfs退出条件\n\tst[u] = true;\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n```\n\n<a name=\"fXcks\"></a>\n\n##### DFS技巧：\n\n- 优化搜索顺序：应当优先搜索分支较少的节点，或者以使得整体搜索次数更少的顺序搜索；\n- 排除等效冗余：例如先选一再选二和先选二再选一是同一种，在搜索的时候要避免重复搜索；\n- 可行性剪枝：搜索过程中发现该分支再往下已经不是想要的结果，直接`return`；\n- 最优化剪枝：例如查找某最小值时，当前分支已经大于当前的最优解时，直接`return`；\n- 记忆化搜索（`DP`）：加缓存，每次要搜寻某个方案时，先看缓存中是否已存在，存在直接返回，不存在再搜索。\n  <a name=\"sU7te\"></a>\n\n#### 3.2.2 BFS：\n\n<a name=\"iiD9j\"></a>\n\n##### 注意：\n\n- 在`BFS`过程中没有递归，初学时要分清`BFS`和`DFS`的区别，`BFS`是维护一个队列。\n  <a name=\"atRG2\"></a>\n\n##### 代码实现（基于双端队列）：\n\n```java\nstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\npublic static void bfs() {\n    Deque<int[]> q = new ArrayDeque<>();\n    q.addLast(new int[]{0, 0});\n    st[0][0] = true;\n    \n    while (!q.isEmpty()) {\n        int[] t = q.pollFirst();\n        int x = t[0], y = t[1];\n        for (int i = 0; i < 4; i ++) {\n            int a = x + dx[i], b = y + dy[i];\n            if (a < 0 || a >= n || b < 0 || b >= m || st[a][b])\n                continue;\n            // 具体题目可能的逻辑\n            ...\n            st[a][b] = true;\n            q.addLast(new int[] {a, b});\n        }\n    }\n}\n```\n\n<a name=\"NGkui\"></a>\n\n### 3.3 拓扑排序：[有向图的拓扑排序](https://www.acwing.com/problem/content/850/)\n\n<a name=\"wtS5v\"></a>\n\n#### 算法思想：\n\n拓扑排序（`Topological Sorting`）是一个有向无环图（`DAG, Directed Acyclic Graph`）的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n- 每个顶点出现且只出现一次；\n- 若存在一条从顶点`A` 到顶点 `B` 的路径，那么在序列中顶点`A` 必须出现在顶点 `B`的前面。\n\n拓扑排序利用队列，先将所有入度为`0`的点放进队列中（用`d`数组记录每个点的入度），然后从队头元素开始遍历，并让队头元素出队，对每个点的所有邻边遍历一遍，每次遍历让其入度减一，当某个点入度为`0`时，将其放进队列中。当队列为空时，排序结束。\n<a name=\"Mo14J\"></a>\n\n#### 代码实现：\n\n> 数组模拟队列可以不用单独存储答案，出队操作时逻辑出队，因此可以直接输出。\n\n```java\npublic static boolean topSort() {\n    int hh = 0, tt = -1; // 数组模拟队列\n    for (int i = 1; i <= n; i ++) // 先将所有入度为0的点放进队列中\n        if (d[i] == 0) q[++ tt] = i;\n    // 当队列不空时，遍历队列中点的所有邻点\n    while (hh <= tt) {\n        int t = q[hh ++]; // 取出队头元素\n        for (int i = h[t]; i != -1; i = ne[i]) { // 遍历其所有邻点\n            int j = e[i];\n            d[j] --; // 每次遍历后将其入度减一\n            if (d[j] == 0) q[++ tt] = j; // 当其入度为零时，将其放进队列\n        }\n    }\n    return tt == n - 1; // 返回是否成功进行拓扑排序，当tt == n - 1时，表示已经遍历完所有点\n}\n```\n\n<a name=\"MzTMR\"></a>\n\n#### 代码实现（基于双端队列）：\n\n> 基于双端队列的实现则需要单独存一下序列，以便输出。下面代码中不用`st`也可以，因为`d[j]`每次都会被 `-1`，所以不可能有元素能重复入队，只是习惯这样。\n\n```java\nstatic List<Integer> res = new ArrayList<>();\n// 建图省略\npublic static boolean top_sort() {\n    Deque<Integer> q = new ArrayDeque<>();\n    for (int i = 1; i <= n; i ++) {\n        if (d[i] == 0) {\n            q.addLast(i);\n            st[i] = true;\n        }\n    }\n    while (!q.isEmpty()) {\n        int t = q.pollFirst();\n        res.add(t);\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (st[j]) continue;\n            d[j] --;\n            if (d[j] == 0) {\n                st[j] = true;\n                q.addLast(j);\n            }\n        }\n    }\n    return res.size() == n;\n}\n```\n\n<a name=\"a3j71\"></a>\n\n### 3.4 朴素Dijkstra算法$\\mathcal{O}(n^2 + m)$：[Dijkstra求最短路Ⅰ](https://www.acwing.com/activity/content/problem/content/918/)\n\n<a name=\"tmQFB\"></a>\n\n#### 算法思想：\n\n- 迪杰斯特拉算法只能用于求解**非负权**图的**单源路径问题**。\n- 迪杰斯特拉算法基于贪心，将第一个点到第一个点的距离赋值为`0`，其他赋值为无穷大`INF`，然后进行`n - 1`次迭代，每次从还未确定与起点最短距离的点中选出与起点距离最小的点，然后用这个点更新其他点到起点的距离，并将这个点的状态改为已确定最短距离（即`st[t] = true`）。\n- 使用**邻接矩阵**存储。\n\n> 一般都不用朴素版Dijkstra，~~有堆优化版，谁还用朴素版啊~~~\n\n> 有关图论的几个算法必须熟记时间复杂度，便于选择。\n\n<a name=\"ci5op\"></a>\n\n#### 代码实现：\n\n```java\npublic static int dijkstra() {\n    // INF = 0x3f3f3f3f表示无穷大\n    Arrays.fill(dist, INF);\n    // 初始化起点到起点的距离为0\n    dist[1] = 0; \n    // 进行n - 1次迭代，每次确定一个最小距离点\n    for (int i = 0; i < n - 1; i ++) {\n        // t只作为一个临时变量，用于筛选当前还未确定的距离最小的点\n        int t = -1;\n        for (int j = 1; j <= n; j ++) {\n            // 寻找当前还未确定最小距离的点中的最小值（t == -1 表示最开始的状态，刚开始循环。）\n            if (!st[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        }\n        // 如果当前确定这个点是n号点(求的就是1~n的距离)，则直接退出循环（剪枝）\n        if (t == n) break;\n        // 将t（此次确定的最小距离点）放入集合中\n        st[t] = true;\n        // 用此次确定的最小距离点更新其他点到起点的距离\n        for (int j = 1; j <= n; j ++)\n            dist[j] = Math.min(dist[j], dist[t] + g[t][j]);\n    }\n    if (dist[n] == INF) return -1;\n    return dist[n];\n}\n```\n\n<a name=\"rqwwa\"></a>\n\n### 3.5 堆优化版Dijkstra算法$\\mathcal{O}(m \\log n)$：[Dijkstra求最短路Ⅱ](https://www.acwing.com/activity/content/problem/content/919/)\n\n<a name=\"j7RsN\"></a>\n\n#### 算法思想：\n\n- 算法思想同朴素版，朴素版中，每次寻找当前距离最小的点时，该操作是$\\mathcal{O}(n)$级别，但是如果用堆进行维护，则该步骤时间复杂度降低为$\\mathcal{O}(1)$，降低了瓶颈处复杂度，不过当用堆维护后，在后面需要用该点更新其他点到起点的距离时，需要对堆进行操作，所以最终时间复杂度为$\\mathcal{O}(m \\log n)$。\n- 使用**邻接表**存储。\n  <a name=\"Lwsjq\"></a>\n\n#### 代码实现：\n\n```java\nstatic class PII implements Comparable<PII> {\n    // x表示该点到起点的距离，y表示节点编号\n    int x, y;\n    public int compareTo(PII p) {\n        return this.x - p.x;\n    }\n}\n\nstatic int n, m, idx;\nstatic final int N = 150010;\nstatic final int INF = 0x3f3f3f3f;\nstatic int[] h = new int[N], e = new int[N], ne = new int[N], dist = new int[N], w = new int[N]; // w表示权值\nstatic boolean[] st = new boolean[N];\nstatic PriorityQueue<PII> heap = new PriorityQueue<>();\n// 或者也可以 PriorityQueue<int[]> heap = new PriorityQueue<>((o1,o2)->o1[1]-o2[1]); <int[]>这块是一个泛型的参数声明，在集合中只能存取指定类型的元素，这里限定堆中每个元素都是一个一维数组，后面传入了一个重写compare()方法的Lambda表达式，表示每个数组元素按下标为1处的元素distance进行升序排序，堆顶元素就是还未确定最终距离的点到源点距离最近的点。\n// 大根堆写法：PriorityQueue<Integer> q = new PriorityQueue<>((o1, o2)->o2.compareTo(o1));\n\npublic static void add(int a, int b, int c) {\n    e[idx] = b;\n    w[idx] = c;\n    ne[idx] = h[a];\n    h[a] = idx ++;\n}\n\npublic static int dijkstra() {\n    // 初始化距离为无穷大\n    Arrays.fill(dist, INF); \n    // 将起点到起点的距离定义为0\n    dist[1] = 0; \n    // 将起点放进堆中(小根堆)\n    heap.add(new PII(0, 1));\n    // st[1] = true; 这里不需要提前将1的状态改为确定，因为要先用其更新其他点的距离之后再确定\n    while(!heap.isEmpty()) {\n        // 取出堆顶元素\n        PII t = heap.remove(); \n        // vertex为顶点编号,diatance为当前点到起点的距离\n        int vertex = t.y, distance = t.x; \n        // 如果当前点已经确定过最小距离，则跳过该点（因为有的点可能不止进堆一次）\n        if (st[vertex]) continue;\n        // 将该点标记为已经确定最小距离\n        st[vertex] = true;\n        // 用该点更新其他点到起点距离\n        for (int i = h[vertex]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] > distance + w[i]) {\n                dist[j] = distance + w[i];\n                // 更新后再次进堆，原来堆中的该点将会在 if (st[vertex]) continue; 这里被跳过\n                heap.add(new PII(dist[j], j));\n            }\n        }\n    }\n    if (dist[n] == INF) return -1; // 如果n号点到起点的距离不存在，返回-1即可（注意，dijkstra不存在负权值，无需考虑距离为-1的情况，bellmanFord和spfa需要考虑）\n    return dist[n];\n}\n```\n\n<a name=\"os1kn\"></a>\n\n### 3.6 Bellman-Ford算法$\\mathcal{O}(nm)$：[有边数限制的最短路](https://www.acwing.com/problem/content/855/)\n\n<a name=\"Ei2FI\"></a>\n\n#### 算法思想：\n\n- `Bellman-Ford`算法以边为单位，进行`n`次迭代，每次迭代更新一遍每个点到起点的距离。`Bellman-Ford`算法对边的存储没什么要求，直接用一个类存储即可。\n- 当题目规定求只能经过`k`条边的最短路径时，只能用`Bellman-Ford`算法，此时算法复杂度为$\\mathcal{O}(mk)$。\n- 值得一提的是每次更新时应该用上一次迭代后的`dist`数组进行更新。如果用当前的`dist`，则在更新过几条边后，`dist`数组已经改变，此时再用当前的`dist`去更新会导致本来不能更新的点也被更新掉了。例如下图中，如果要求`k = 1`时，第一次迭代，会扫面一遍所有的边，当更新完编号为`2`这个点的距离后，`dist`数组已经发生变化，当扫描到`2->3`这条边时，`dist[3]`就会被更新为`2`，而题目要求只经过`1`条边，因此答案应该为`3`，显然不对。而我们每扫描一条边，利用上一次迭代的结果，就不会因为当前一次迭代过程中`dist`数组的改变而出现错误，这就是代码实现中`backup`数组的作用。\n\n![backup数组的意义.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_0e7bae3dd8-backup数组的意义.PNG)\n<a name=\"XcUeL\"></a>\n\n#### 代码实现：\n\n```java\n// 定义边类，a表示起点，b表示终点，w表示权值\nstatic class Edge {\n    public int a, b, w;\n    public Edge(int a, int b, int w) {\n        this.a = a;\n        this.b = b;\n        this.w = w;\n    }\n}\n\npublic static int bellmanFord() {\n    // 初始化距离为无穷大\n    Arrays.fill(dist, INF); \n    // 起点距离为 0\n    dist[1] = 0;\n    // 进行k次迭代（k为题目要求的只能经过k条边）\n    for (int i = 0; i < k; i ++) { \n        // 拷贝上一次迭代后的dist数组\n        int[] backup = Arrays.copyOf(dist, dist.length); \n        // 扫描每一条边\n        for (int j = 0; j < m; j ++) { \n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            dist[b] = Math.min(dist[b], backup[a] + w); // 更新距离\n        }\n    }\n    if (dist[n] > INF / 2) flag = true; // 这种写法是为了避免下图中起点根本到达不了n这个点，而n-1这个点将dist[n]的无穷大更新为INF - 1，如下图所示\n    return dist[n];\n}\n```\n\n![无穷大被更新.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_1c31d19ad8-无穷大被更新.PNG)\n<a name=\"aMltP\"></a>\n\n### 3.7 SPFA算法$\\mathcal{O}(m) \\sim \\mathcal{O}(nm)$：[SPFA求最短路](https://www.acwing.com/problem/content/853/)\n\n<a name=\"UZGr2\"></a>\n\n#### 算法思想：\n\n- `SPFA`算法是对`Bellman-Ford`算法的**宽搜优化**，但是失去了`k`的限制（有些题目就是要在`k`次内），`Bellman-Ford`每次都用当前点去更新其他点到起点的距离，如果当前点的距离没有变小的话，那么这个操作就是在浪费时间，所以`SPFA`算法在此处进行了优化，利用一个队列，每当遍历到的点距离变小时，将其放入队列中，之后会用它去更新其他点的距离。\n- 并且，`SPFA`算法一般情况下很快，很多`Dijkstra`的题都可以用`SPFA`过掉，除非出题人故意编造数据，将`SPFA`算法时间复杂度卡成$\\mathcal{O}(nm)$。`SPFA`算法时间复杂度一般为$\\mathcal{O}(m)$，最坏$\\mathcal{O}(nm)$。\n- `Bellman-Ford`使用**类**存储每条边，`SPFA`使用**邻接表**存储图。\n- 一句话总结`SPFA`，用更新过距离的点再去更新其他点的距离。\n  <a name=\"P57kl\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean spfa() {\n    Arrays.fill(dist, INF);\n    Deque<Integer> q = new ArrayDeque<>();\n    // st数组表示当前的点是否在队列当中，防止存储重复的点(不校验基本都会TLE，因为spfa中有的点可能会重读入队)\n    q.addLast(1); dist[1] = 0; st[1] = true;\n    \n    while (!q.isEmpty()) {\n        int t = q.pollFirst();\n        // 维护st\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            // d = dist[t] + dist{t -> j}\n            int d = dist[t] + w[i];\n            // 能被更新才更新\n            if (dist[j] > d) {\n                dist[j] = d;\n                // 未在队列中才入队\n                if (!st[j]) {\n                    q.addLast(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n] != INF;\n}\n```\n\n<a name=\"ZfGqz\"></a>\n\n### 3.8 SPFA判负环：[SPFA判负环](https://www.acwing.com/activity/content/problem/content/921/)\n\n<a name=\"ozEcG\"></a>\n\n#### 算法思想：\n\n该算法基于`SPFA`算法，在该过程中增加一个`cnt`数组，表示从起点到该点经过了多少个点，如果某条最短路径上除了自己有`n`个点（假设总共有`n`个点），那么加上自己之后一共有`n + 1`个点，由[抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776)一定有两个点相同，所以存在环。并且在该背景下，这个环一定是负环，否则不会一直更新距离从而导致死循环。（当然，因为有`cnt`限制，一旦`cnt[j] >= n`，则直接`return ture`，所以代码中不会存在死循环）。\n<a name=\"pnlzU\"></a>\n\n#### 代码实现：\n\n```java\n// 队列里存储节点编号（早期代码，用LinkedList写的，实际并非队列，集合而已）\nstatic List<Integer> q = new LinkedList();\npublic static boolean spfa() {\n    // 之所以将所有点放进队列，是因为可能1号点根本到不了负环\n    for (int i = 1; i <= n; i ++) {\n        q.add(i);\n        st[i] = true;\n    }\n    while (!q.isEmpty()) {\n        int t = q.remove();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            // 一开始所有dist都等于0（不用初始化为INF），如果满足dist[j] > dist[t] + w[i]说明有负权值\n            if (dist[j] > dist[t] + w[i]) {\n                dist[j] = dist[t] + w[i];\n                // 每更新一次，将cnt[j]也更新\n                cnt[j] = cnt[t] + 1;\n                if (!st[j]) {\n                    // 如果当前点不在队列中，就将其放进队列\n                    q.add(j);\n                    st[j] = true;\n                }\n                // 如果发现某个点的cnt大于等于n，说明已经在里面转了n次了，因为如果这个环的权值之和大于等于0的话，是不会在里面一直转的，所以直接return，避免死循环\n                if(cnt[j] >= n) return true;\n            }\n        }\n    }\n    return false; // 如果一切顺利，则说明没有负环\n}\n```\n\n<a name=\"uZxnG\"></a>\n\n### 3.9 Floyd算法：[Floyd求最短路](https://www.acwing.com/problem/content/856/)\n\n<a name=\"TleJN\"></a>\n\n#### 算法思想：\n\n`Floyd`算法基于动态规划，使用三重循环，可以求解**多源汇问题**。<br />由于`Floyd`算法是最短路算法的最后一个算法，所以在此进行总结：\n\n- 朴素`Dijkstra`（单元最短路）常用于求解非负权图中的**稠密图**，时间复杂度$\\mathcal{O}(n^2 + m)$；\n- 堆优化版`Dijkstra`（单元最短路）常用于求解非负权图中的**稀疏图**，时间复杂度$\\mathcal{O}(m \\log n)$；\n- `Bellman-Ford`算法常用于求解**有边数限制的最短路问题**，时间复杂度$\\mathcal{O}(nm)$；\n- `spfa`算法常用于求解**存在负权边**的最短路问题（也可以求正权边最短路，有被卡风险），时间复杂度$\\mathcal{O}(m)$；\n- `Floyd`算法常用于求解**多源汇最短路**问题，时间复杂度$\\mathcal{O}(n^3)$，`Floyd`算法的代码实现较简单，理解不了先直接背过即可，后面学了`dp`后就好理解了。\n  <a name=\"ToS1U\"></a>\n\n#### 代码实现：\n\n```java\npublic static void floyd() {\n    for (int k = 1; k <= n; k ++)\n        for (int i = 1; i <= n; i ++)\n            for (int j = 1; j <= n; j ++)\n                // d为图的邻接矩阵，Floyd算法完成后d变成每个点到其他点的最短距离矩阵\n                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n}\n```\n\n<a name=\"G0Mdp\"></a>\n\n### 3.10 朴素Prim算法：[prim算法求最小生成树](https://www.acwing.com/problem/content/860/)\n\n<a name=\"MlZpa\"></a>\n\n#### 算法思想：\n\n- `Prim`算法是求最小生成树的一种算法，原理是从一个点出发，每次找到离集合最近的点，并将其加入到集合中，然后用这个点来更新剩下的点到集合的距离。常常用于求解**稠密图**的最小生成树问题。\n- 集合中维护的元素就是生成树中的节点，每个点到集合的距离定义为该点到集合中任意一点距离的最小值。\n- 用邻接矩阵存储图。\n  <a name=\"tWnNl\"></a>\n\n#### 代码实现：\n\n```java\npublic static int prim() {\n    Arrays.fill(dist, INF);\n    // res表示生成树中每条边的权值之和\n    int res = 0;\n    // 迭代n次，每次确定一个节点\n    for (int i = 0; i < n; i ++) {\n        // t为临时变量，用于寻找到集合的最短节点\n        int t = -1;\n        // 寻找到集合距离最短的节点\n        for (int j = 1; j <= n; j ++)\n            if (!st[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        // 如果不是第一个点，并且到集合距离最短的点的距离为无穷大，则说明最小生成树不存在\n        if (i != 0 && dist[t] == INF) return INF;\n        // 将该条边的权值加到res中\n        if (i != 0) res += dist[t];\n        // st表示是否加入到集合中\n        st[t] = true;\n        // 用该点更新其他点到集合的距离，注意不是 dist[t] + g[t][j]\n        for (int j = 1; j <= n; j ++) dist[j] = Math.min(dist[j], g[t][j]);\n    }\n    return res;\n}\n```\n\n<a name=\"qxFoi\"></a>\n\n### 3.11 Kruskal算法：[Kruskal算法求最小生成树](https://www.acwing.com/activity/content/problem/content/925/)\n\n<a name=\"ydNLU\"></a>\n\n#### 算法思想：\n\n- `Kruskal`是以边为对象，首先将所有边按照权值进行排序，然后枚举每一条边，如果一条边对应的两个顶点不在同一个集合中，那么我们就将其加入到一个集合中，在枚举过程中记录一个`cnt`变量，每次有点加入集合中，则`cnt ++`，如果枚举完成之后，`cnt < n - 1`，则说明并不是所有点都加入集合了，故最小生成树不存在。\n- 在以上过程中，判断两个是否在集合中，可以通过并查集进行查询并维护。\n  <a name=\"sx7IW\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int a, b, w;\n        public Edge(int a, int b, int w) {\n            this.a = a;\n            this.b = b;\n            this.w = w;\n        }\n    }\n    static final int N = 100010, INF = 0x3f3f3f3f;\n    static Edge[] edges = new Edge[2 * N];\n    static int[] p = new int[N];\n    static int n, m;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt(); m = sc.nextInt();\n        for (int i = 0; i < m; i ++) {\n            int a = sc.nextInt(), b = sc.nextInt(), w = sc.nextInt();\n            edges[i] = new Edge(a, b, w);\n        }\n        Arrays.sort(edges, 0, m, (o1, o2) -> o1.w - o2.w);\n        int res = kruskal();\n        System.out.println(res == INF ? \"impossible\" : res);\n    }\n    public static int kruskal() {\n        int res = 0, cnt = 0;\n        for (int i = 0; i <= n; i ++) p[i] = i;\n        for (int i = 0; i < m; i ++) {\n            int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n            a = find(a); b = find(b);\n            if (a != b) {\n                p[a] = b;\n                cnt ++;\n                res += w;\n            }\n            if (cnt == n - 1) return res;\n        }\n        return INF;\n    }\n    public static int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n}\n```\n\n<a name=\"qNQGg\"></a>\n\n### 3.12 染色法判别二分图：[染色法判别二分图](https://www.acwing.com/problem/content/862/)\n\n<a name=\"U9xRN\"></a>\n\n#### 算法思想：\n\n- **二分图：** 当且仅当图中不存在奇数环，可以利用抽屉原理进行证明；\n- **染色法**顾名思义，就是将每个点染色，染色过程中需要保证每个点与它相邻的点的颜色不同，一共两种颜色。如果在染色过程中出现矛盾，那么该图就一定不是二分图。\n  <a name=\"xnuYL\"></a>\n\n#### 代码实现：\n\n```java\n// u表示当前节点编号，c表示当前颜色\npublic static boolean dfs(int u, int c) { \n    // color表示颜色，0表示未染色，1和2表示两种不同颜色\n    color[u] = c; \n    for (int i = h[u]; i != -1; i = ne[i]) { \n        int j = e[i];\n        // 如果这个邻点未被染色，则将其染为与u不同的另一种颜色，如果染色不成功，则说明发生矛盾，直接退出\n        if (color[j] == 0 && !dfs(j, 3 - c)) return false;\n        // 如果当前节点的一个邻点与当前节点颜色相同，则发生矛盾，直接退出\n        else if (color[j] == c) return false; \n    }\n    return true;\n}\n\n// 开始时 flag 为 true，表示不存在染色失败的情况\nboolean flag = true; \n// 枚举每一个点\nfor (int i = 1; i <= n; i ++) \n    // 对还没有染色的节点染色\n    if (color[i] == 0 && !dfs(i, 1)) {\n        // 染色失败，则说明不是二分图\n        flag = false; \n        break;\n    }\n// 循环结束之后 flag 还是 true 则说明染色成功，为二分图\n```\n\n<a name=\"lwi86\"></a>\n\n### 3.13 匈牙利算法：[二分图的最大匹配](https://www.acwing.com/activity/content/problem/content/927/)\n\n<a name=\"zfSqL\"></a>\n\n#### 算法思想：\n\n- 匈牙利算法由两位匈牙利的数学家提出，因此得名。用一个形象的例子解释，一个二分图中，所有顶点分为左右两个部分，左半部分的点与右半部分的点之间存在许多边，如果其中一条边与其他任意的边都不依附于同一个顶点，则称这条边为一个匹配。例如图`1`的二分图中，图`4`就是该二分图的最大匹配，最大匹配数为`4`。\n- 在整个匹配过程中，最开始`1`号与`5`号匹配，`2`号和`7`号匹配，此时没有任何问题，当`3`号点匹配时，发现`7`号点已经被匹配过了，此时，我们看看与`7`号匹配的`2`号点能否换个点匹配，而`2`号点的另一个可匹配点`5`号点被`1`号点匹配，我们再看`1`号点能不能换个点匹配，此时发现`1`号点还可以和`6`号点匹配，于是，`1、2、3`号点都可以匹配，如图`3`所示。\n\n![二分图的最大匹配.PNG](https://cdn.acwing.com/media/article/image/2024/03/02/126318_370a50f7d8-二分图的最大匹配.PNG)\n<a name=\"EeLdc\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean find(int x) {\n    for (int i = h[x]; i != -1; i = ne[i]) {\n        int j = e[i];\n        // 如果j还没被考虑过\n        if (!st[j]) {\n            // 将j的状态设置为已考虑过\n            st[j] = true;\n            // 如果j还没有与其他点匹配，或者可以为与j匹配的点找到其他点进行匹配\n            if (match[j] == 0 || find(match[j])) {\n                // 那么就将j 这个点与x进行匹配(match[j]表示与j这个点匹配的点的节点编号)\n                match[j] = x;\n                // 匹配成功返回true\n                return true;\n            }\n        }\n    }\n    // 如果实在匹配不了，就返回false\n    return false;\n}\n\nint res = 0;\n// 左半部分点的编号为1~n1，依次枚举每个点，看能否找到匹配\nfor (int i = 1; i <= n1; i ++) {\n    // st表示当前点是否被考虑过，并非匹配成功与否\n    Arrays.fill(st, false);\n    // 如果找到匹配，最大匹配数加一\n    if (find(i)) res ++;\n}\n```\n\n<a name=\"my7pd\"></a>\n\n## 第四章：数学知识\n\n<a name=\"XmRxl\"></a>\n\n### 4.1 试除法判定质数：[试除法判定质数](https://www.acwing.com/problem/content/868/)\n\n<a name=\"urRDE\"></a>\n\n#### 算法思想：\n\n判定一个数`n`是否是质数，主要判定$2 \\sim \\sqrt{n}$之间是否有其约数。（所有小于`2`的数不是质数）\n<a name=\"UNmRa\"></a>\n\n#### 代码实现：\n\n```java\npublic static boolean isPrime(int x) {\n    if (x < 2) return false;\n    // 由于sqrt()比较慢，且i * i 可能爆int，所以采用此种写法\n    for (int i = 2; i <= x / i; i ++)\n        if (x % i == 0) return false;\n\treturn true;\n}\n```\n\n<a name=\"HaCNB\"></a>\n\n### 4.2 试除法分解质因数：[试除法分解质因数](https://www.acwing.com/problem/content/869/)\n\n<a name=\"Mne7Y\"></a>\n\n#### 算法思想：\n\n- 想要对一个数`x`分解质因数，主要是通过从小到大枚举其约数，当枚举到一个约数`i`时，通过一个循环，将`x`反复更新为`x = x / i`，并记录更新了多少次，这个次数就是`i`这个质因子的指数。\n- 当上述过程结束后，需要判定一下最后的`x`是否被除成了`1`，如果不是，则说明被除剩下的这个`x`也是最开始的`x`的一个质因子，且该质因子不能再被分解。\n  <a name=\"aAKGd\"></a>\n\n#### 代码实现：\n\n```java\npublic static void devide(int x) {\n    for (int i = 2; i <= x / i; i ++) {\n        // 如果i是x的约数\n        if (x % i == 0) {\n            int cnt = 0;\n            // 求出i的指数cnt，并且更新x（将这个质因子除干净）\n            while (x % i == 0) {\n                x /= i;\n                cnt ++;\n            }\n            // 输出这个质因子和它的指数\n            System.out.println(i + \" \" + cnt);\n        }\n\t}\n\tif (x > 1) System.out.println(x + \" \" + 1);\n}\n```\n\n<a name=\"sAAyB\"></a>\n\n### 4.3 筛质数：[筛质数](https://www.acwing.com/problem/content/870/)\n\n<a name=\"MgFAi\"></a>\n\n#### 4.3.1 朴素筛法：\n\n<a name=\"AeFfu\"></a>\n\n##### 算法思想：\n\n- 筛质数的目的在于求出`1 ~ n`之间的质数。那么比较快速的办法就是将`1 ~ n`当中不是质数的数给筛出去\n- 朴素筛法是利用已经确定了的质数进行筛除，其原理是将一个质数的所有小于等于`n`的倍数全部筛除\n\n> 一般都不用朴素筛法，~~都有线性筛了，谁还用朴素筛法呀~~~\n\n<a name=\"Luzjo\"></a>\n\n##### 代码实现：\n\n```java\n// 记录质数的个数\nint cnt = 0;\n// 存储所有的质数\nint[] primes = new int[n];\n// st 表示当前数是否被筛掉\nboolean[] st = new boolean[n + 10];\n// 从 2 开始枚举每个数\nfor (int i = 2; i <= n; i ++) {\n    // 如果当前的数已经被筛掉，则跳过该次循环\n    if (st[i]) continue;\n    // 否则将其加到质数数组中，同时cnt ++\n    primes[cnt ++] = i;\n    // 用当前质数筛掉其所有的倍数（如2i，3i都被筛掉）\n    for (int j = i + i; j <= n; j += i) st[j] = true;\n}\n```\n\n<a name=\"yJZtE\"></a>\n\n#### 4.3.2 线性筛法：\n\n<a name=\"FdYH1\"></a>\n\n##### 算法思想：\n\n- 线性筛法可以理解为是对朴素筛法的优化，因为朴素筛法里会多次筛除同一个数，而线性筛法中，每个合数只会被筛掉一次。\n- 其主要思想是通过每个合数的最小质因子将其筛掉。\n  <a name=\"QhNqL\"></a>\n\n##### 代码实现：\n\n```java\nint cnt = 0;\nint[] primes = new int[n];\nboolean[] st = new boolean[n + 10];\nfor (int i = 2; i <= n; i ++) {\n    // if (st[i]) continue; 此处不能continue，因为还需要用i来筛掉后面的合数\n    if (!st[i]) primes[cnt ++] = i;\n    // 每次筛掉的数为primes[j] * i，所以需要primes[j] * i <= n\n    for (int j = 0; primes[j] <= n / i; j ++) { \n        st[primes[j] * i] = true;\n        // 保证primes[j]为primes[j] * i的最小质因子，当这个条件发生后，下一个枚举的元素一定大于primes[j] * i的最小质因子，所以需要break\n        if (i % primes[j] == 0) break;\n    }\n}\n```\n\n<a name=\"IU3UX\"></a>\n\n### 4.4 试除法求约数：[试除法求约数](https://www.acwing.com/activity/content/problem/content/938/)\n\n<a name=\"ffFpl\"></a>\n\n#### 算法思想：\n\n与求质数差不多，从`0`开始枚举到$\\sqrt{n}$，对每个数`i`进行判断，如果是`x`的约数，且`i != x / i`，则将`i`与`x / i`放进答案中，最后排序输出即可。\n<a name=\"bcF27\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int T = sc.nextInt(); \n        while (T -- > 0) {\n            List<Integer> devisors = new ArrayList();\n            int x = sc.nextInt();\n            for (int i = 1; i <= x / i; i ++) {\n                if (x % i == 0) {\n                    devisors.add(i);\n                    if (x / i != i) devisors.add(x / i);\n                }\n            }\n            Collections.sort(devisors);\n            for (int a : devisors) bw.write(a + \" \");\n            bw.write(\"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n\n<a name=\"FGRaw\"></a>\n\n### 4.5 约数个数：[约数个数](https://www.acwing.com/activity/content/problem/content/939/)\n\n<a name=\"cQEAe\"></a>\n\n#### 算法思想：\n\n- 该算法求解的是一个数`x`的所有`2 ~ x - 1`中的约数个数\n- 该算法基于约数个数公式：$(\\alpha_1 + 1) \\times (\\alpha_2 + 1) \\times ... \\times (\\alpha_k + 1)$，其中$\\alpha_1$为`x`的第一个质因子的指数，$\\alpha_2$为`x`的第二个质因子的指数，依次类推。\n  <a name=\"iD8yv\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int mod = (int)1e9 + 7;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> primes = new HashMap<>();\n        while (n -- > 0) {\n            int x = sc.nextInt();\n            for (int i = 2; i <= x / i; i ++) {\n                int s = 0;\n                while (x % i == 0) {\n                    x /= i;\n                    s ++;\n                }\n                primes.put(i, primes.getOrDefault(i, 0) + s);\n            }\n            if (x > 1) {\n                primes.put(x, primes.getOrDefault(x, 0) + 1);\n            }\n        }\n        long res = 1;\n        for (int value : primes.values()) \n            res = res * (value + 1) % mod;\n        \n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"wUi0e\"></a>\n\n### 4.6 约数之和：[约数之和](https://www.acwing.com/activity/content/problem/content/940/)\n\n<a name=\"C9FxK\"></a>\n\n#### 算法思想：\n\n- `4.5`节是求一个数的约数个数，而`4.6`则是求这些约数的和。\n- 该算法同样基于公式：$(p_1^0 + p_1^1 + ... + p_1^{\\alpha_1}) \\times ... \\times (p_k^0 + p_k^1 + ... + p_k^{\\alpha_k})$。其中，$p_1$是第一个质因子，$\\alpha_1$是第一个质因子的指数。\n- 上式中，可以利用$t = t \\times p + 1$求解每一项，例如第一项$t_{\\alpha_1}$：$t_0 = 1, t_1 = p + 1, t_2 = p^2 + p + 1, ..., t_{\\alpha_1} = p^{\\alpha_1} + ... + 1$。\n  <a name=\"ROvDE\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\n// 求n个数的乘积，再求这个数的所有约数之和\npublic class Main {\n    static final int mod = (int)1e9 + 7;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> primes = new HashMap<>();\n        while (n -- > 0) {\n            int x = sc.nextInt();\n            for (int i = 2; i <= x / i; i ++) {\n                int s = 0;\n                while (x % i == 0) {\n                    x /= i; // 同4.5节\n                    s ++;\n                }\n                primes.put(i, primes.getOrDefault(i, 0) + s);\n            }\n            if (x > 1) primes.put(x, primes.getOrDefault(x, 0) + 1);\n        }\n        long res = 1;\n        for (Map.Entry prime : primes.entrySet()) { // 遍历容器中的每一项\n            long t = 1;\n            int key = (int)prime.getKey(), value = (int)prime.getValue();\n            while (value -- > 0) t = (t * key + 1) % mod; // 求解公式的每一项\n            res = res * t % mod; // 将公式的每一项相乘\n        }\n        System.out.println(res);\n    }\n}\n```\n\n<a name=\"Yh4jS\"></a>\n\n#### 补充`map`遍历方式：\n\n```java\nfor (int key : map.keySet()) {} // 遍历每项key\nfor (int value : map.values()) {} // 遍历每项value\nfor (Map.Entry<Integer, Integer> p : entrySet()) {} // 遍历map的每个对象\n```\n\n<a name=\"wBmtv\"></a>\n\n### 4.7 最大公约数：[最大公约数](https://www.acwing.com/activity/content/problem/content/941/)\n\n<a name=\"MdBOV\"></a>\n\n#### 算法思想：\n\n如果一个数`d`能整除`a`，且能整除`b`，那么`d`一定能整除`c₁ * a + c₂ * b`。所以`d`也能够整除`a - c * b`，令`c = (a / b)`向下取整，则`a - c * b = a mod b`，所以`d`也能整除`a mod b`，故`a、 b`两个数的最大公约数等于`b、 a mod b`这两个数的最大公约数。这就是欧几里得算法的核心之处。\n<a name=\"fZu8N\"></a>\n\n#### 代码实现：\n\n```java\npublic static int gcd(int a, int b) {\n    // 如果b等于0，那么最大公约数就是a，否则就是gcd(b, a % b)\n    return b > 0 ? gcd(b, a % b) : a;\n}\n```\n\n<a name=\"HpVrm\"></a>\n\n### 4.8 欧拉函数：[欧拉函数](https://www.acwing.com/activity/content/problem/content/943/)\n\n<a name=\"Qe8xq\"></a>\n\n#### 算法思想：\n\n- 欧拉函数是指：对于一个正整数`x`，小于或等于`x`的正整数中与`x`互质的正整数个数（包括`1`）的个数，记作$\\varphi(n)$。\n- 欧拉函数的公式推导大致为：\n\n![欧拉公式.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_86291071d8-欧拉公式.png) <br />其中$p_i$为`x`的每一个质因子。上述公式的除法均为整除（即下取整），上述公式的思想为：`1 ~ x`中总共有`x`个数，减去与`x`有相同质因子的数后，剩下的数均与`x`互质，而每次会重复减去相同的数，所以再加回来（容斥原理）。\n<a name=\"BMqZD\"></a>\n\n#### 代码实现：\n\n```java\npublic static int getEuler(int x) {\n    int res = x;\n    for (int i = 2; i <= x / i; i ++) {\n        if (x % i == 0) {\n            // 公式，这种写法是避免出现小数，等价于res = res *(1 - 1 / i);\n            res = res - res / i; \n            // 把 i 除干净\n            while (x % i == 0) x /= i;\n        }\n    }\n    if (x > 1) res = res - res / x;\n    return res;\n}\n```\n\n<a name=\"rfpgz\"></a>\n\n### 4.9 筛法求欧拉函数：[筛法求欧拉函数](https://www.acwing.com/activity/content/problem/content/943/)\n\n<a name=\"GSbdg\"></a>\n\n#### 算法思想：\n\n主要思想还是基于`4.8`中的公式，此算法适用于题目要求求解`1 ~ x`中的每一个数的欧拉函数值。\n<a name=\"Y9Vxz\"></a>\n\n#### 代码实现：\n\n```java\nstatic final int N = 1000010;\nstatic int[] primes = new int[N];\nstatic boolean[] st = new boolean[N];\nstatic int[] phi = new int[N]; // 用于存放每个数的欧拉函数值\npublic static void getEuler(int x) {\n    int cnt = 0;\n    phi[1] = 1; // 对于phi[]，由于其实际意义，i从1开始\n    for (int i = 2; i <= x; i ++) {\n        if (!st[i]) {\n            primes[cnt ++] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= x / i; j ++) {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) {\n                phi[i * primes[j]] = primes[j] * phi[i]; // 公式1\n                break;\n            }\n            // 不需要else，因为如果执行了if,就会break\n            phi[i * primes[j]] = (primes[j] - 1) * phi[i]; // 公式2\n        }\n    }\n}\n```\n\n<a name=\"mrIbq\"></a>\n\n#### 公式推导：\n\n- **公式1：** 由于此时`i % primes[j] == 0`，说明`primes[j]`是`i`的最小质因子，则在计算`phi[i * primes[j]]`时，`(1 - 1 / primes[j])`已经在求解`phi[i]`时被乘过一次，所以此时不需要乘这一项。\n\n$\\varphi(i \\times\\: \\text{primes}[j]) = i \\times\\: \\text{primes}[j] \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\cdots \\times \\left(1 - \\frac{1}{p_k}\\right) =  \\text{primes}[j]  \\times \t\\varphi(i)$\n\n- **公式2：** 由于此时`i % primes[j] != 0`，说明`primes[j]`不是`i`的质因子，则在计算`phi[i * primes[j]]`时，需要乘`(1 - 1 / primes[j])`这一项，化简即可。\n\n$\\varphi(i \\times\\: \\text{primes}[j]) = i \\times\\: \\text{primes}[j] \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\cdots \\times \\left(1 - \\frac{1}{p_k}\\right) \\times (1 - \\frac{1}{\\text{primes}[j]}) \\\\ = \\text{primes}[j] \\times (1 -\\frac{1}{\\text{primes}[j]}) \\times \\varphi(i) \\\\ = (\\text{primes}[j] - 1) \\times \\varphi(i)$\n\n<a name=\"BEGYT\"></a>\n\n### 4.10 快速幂：[快速幂](https://www.acwing.com/problem/content/877/)\n\n<a name=\"XDMyV\"></a>\n\n#### 算法思想：\n\n- 快速幂可以快速求解$a^b \\% p$的结果。$a^b$在`java`中虽然有方法`pow`可以使用，但是在计算过程中很容易就爆`long`，而快速幂计算的每一步都会$\\% p$，一般不会爆`long`。\n- 其思想为先预处理出$a^{2^0}, a^{2^1}, ..., a^{2^{\\log b}}$的结果，这些数每一个都是前一个的平方。这一步显然是$\\mathcal{O}(\\log b)$复杂度的。\n- 再将$a^b$分解为若干个前面预处理出来的值相乘，即将`b`分解为前面预处理出来的值的指数相加，这一步可以使用二进制进行计算，例如：十进制中的$a^5$，`5`的二进制的`101`，则`5`可以写为$2^0 + 2^2$，那么$a^5$就被分解为$a^{2^0} \\times a^{2^2}$，此时就可以用预处理出来的值相乘得到。而这一步也是$\\mathcal{O}(\\log b)$的，因此时间复杂度为$\\mathcal{O}(\\log b)$。\n  <a name=\"XiN7v\"></a>\n\n#### 代码实现：\n\n> 该模板相当精妙，在每次`while`循环时，算出$a^{2^i}$，同时判断这一个预处理出来的值需不需要乘进去，并达到了更新`a`和`b`的效果\n\n```java\npublic static int qmi(int a, int b, int p) {\n    // 防止p=1，当p=1时，答案为0\n    int res = 1 % p;\n    while(b > 0) {\n        // (b & 1)要加括号，否则&会被当作逻辑运算符，(b & 1) == 1 表示b的二进制中最后一位是否是1，& 运算符表示参与计算的两个数二进制中对应位置的数都是1才是1，否则为0\n        if ((b & 1) == 1) res = (int)((long)res * a % p);\n        // 将a更新为a^2(java为强类型语言，比c++严格，必须最后手动强转为int再复制给a)\n        a = (int)((long)a * a % p);\n        // 删除b的二进制中最后一位数\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n<a name=\"Xkti4\"></a>\n\n### 4.11 快速幂求逆元：[快速幂求逆元](https://www.acwing.com/activity/content/problem/content/945/)\n\n<a name=\"mUBgJ\"></a>\n\n#### 算法思想：\n\n- **乘法逆元定义**：若整数`b, m`互质，并且对于任意的整数`a`，如果满足`b|a`，则存在一个整数`x`，使得`a/b ≡ a * x (mod m)`，则称`x`为`b`的模`m`乘法逆元，记作`b⁻¹ (mod m)`。`b`存在乘法逆元的充分必要条件是`b`与模数`m`互质。\n\n$\\frac{a}{b} = a \\cdot x \\pmod{m} \\\\ b \\cdot x \\equiv 1 \\pmod{m} \\\\ \\because m\\text{为质数，由费马小定理知,} \\\\ b^{m-1} \\equiv 1 \\pmod{m} \\\\ \\text{又} \\because b^{m-1} = b \\cdot b^{m-2}\\quad (m \\geq 2) \\\\  \\therefore x \\equiv b^{m-2}\\quad (\\text{mod } m)$\n\n- 当`b`为`m`的倍数时，显然，`b % m = 0`，不存在逆元；\n- 当`b`不是`m`的倍数时，`b`的逆元为$b^{m - 2} \\% m$。\n  <a name=\"j3cuP\"></a>\n\n#### 代码实现：\n\n```java\npublic static int qmi(int a, int b, int p) {\n    int res = 1 % p;\n    while (b != 0) {\n        if ((b & 1) == 1) res = (int)((long)res * a % p);\n        a = (int)((long)a * a % p);\n        b >>= 1;\n    }\n    return res;\n}\n\nint a = sc.nextInt(), p = sc.nextInt();\nint res = qmi(a, p - 2, p);\nif (b % m != 0) System.out.println(res);\nelse System.out.println(\"impossible\");\n```\n\n<a name=\"k1url\"></a>\n\n### 4.12 扩展欧几里得算法：[扩展欧几里得算法](https://www.acwing.com/activity/content/problem/content/946/)\n\n<a name=\"DPzHN\"></a>\n\n#### 算法思想：\n\n- 想了解扩展欧几里得算法，先引入**裴属定理：** 若`a, b` 是整数,且 `gcd(a , b) = d` ，那么对于任意的整数`x, y`, `ax + by`都一定是`d`的倍数，特别地，一定存在整数`x, y`，使`ax + by = d`成立。而扩展欧几里得算法则可以很方便的求解任意正整数`a, b`的`x, y`这两个系数。即通过函数`exgcd(a, b, x, y)`求得系数`x, y`。注意：`x, y`并不唯一。\n- 由欧几里得算法知，`gcd(a, b) = gcd(b, a % b)`，而`a % b = a - a / b * b` ，那么在递归求`exgcd(b, a % b, y, x)`时有`by + (a % b)x = d`，化简得`ax + (y - a / b * x)b = d`，说明在递归时系数`x`不用更新（这里的`x`是指`exgcd`函数里的`x`，因为在每次进行递归时，会将实参交换后再复制给形参），只需要更新`y`。\n- 在`java`中没有类似`C ++`的引用类型，可以用数组进行代替。\n  <a name=\"a6D15\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[] x = new int[1];\nstatic int[] y = new int[1];\n// 形式上是把gcd拆开写\npublic static int exgcd(int a, int b, int[] x, int[] y) {\n    if (b == 0) {\n        x[0] = 1;\n        y[0] = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    // 核心，更新系数，这里实际上不只是更新y，只是变量名统一为y了，实际上是交替更新x, y\n    y[0] -= a / b * x[0];\n    return d;\n}\n```\n\n<a name=\"kX05h\"></a>\n\n### 4.13 线性同余方程：[线性同余方程](https://www.acwing.com/activity/content/problem/content/947/)\n\n<a name=\"IPFL1\"></a>\n\n#### 算法思想：\n\n- 可以通过扩展欧几里得算法求解线性同余方程`ax ≡ b (mod m)`。从取模的定义出发，可以根据`ax ≡ b (mod m)`构造出`ax = my' + b`，令`y = -y'`，整理得`ax + my = b`，当`b`为`a, m`的最小公倍数的倍数时，可以利用扩展欧几里得算法进行求解，而当`b`不是其倍数时，则无解。\n- 当用扩展欧几里得求出一组$x_0, y_0$后，此时的$x_0, y_0$满足的是$ax_0 + my_0 = gcd(a, m)$，此时，我们将等式两边同时乘以$\\frac {b}{gcd(a, m)}$，得到$ax_0(\\frac {b}{gcd(a, m)}) + my_0(\\frac {b}{gcd(a, m)}) = b$，令$x = x_0(\\frac{b}{gcd(a, m)})$，$y= y_0(\\frac{b}{gcd(a, m)})$，则此时的`x, y`即为原线性同余方程的一组解。\n  <a name=\"C7GMd\"></a>\n\n#### 代码实现：\n\n```java\nstatic int[] x = new int[1];\nstatic int[] y = new int[1];\npublic static int exgcd(int a, int b, int[] x, int[] y) {\n    if (b == 0) {\n        x[0] = 1;\n        y[0] = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y[0] -= a / b * x[0];\n    return d;\n}\n\nint d = exgcd(a, m, x, y);\n// 若b不为d的倍数，则原线性同余方程无解\nif (b % d != 0) bw.write(\"impossible\\n\"); \n// mod m是为了将其转换为int范围内的解\nelse bw.write((long)x[0] * (b / d) % m + \"\\n\"); \nbw.flush();\n```\n\n<a name=\"bh32e\"></a>\n\n### 4.14 高斯消元$\\mathcal{O}(n^3)$：[高斯消元解线性方程组](https://www.acwing.com/problem/content/885/)\n\n<a name=\"EYJpX\"></a>\n\n#### 算法思想：\n\n高斯消元的原理是将线性方程组的增广矩阵进行初等行变换，使之成为上三角矩阵，再通过上三角矩阵倒着解出未知数。<br />**步骤如下：**\n\n- 依次遍历每一列`c`;\n- 找到这一列中绝对值最大的元素行号，若最大元素为`0`，则不需要处理此列；\n- 将其交换到第`r`行（`r`从`0`开始）;\n- 将第`r`行第`c`列元素化为`1`（初等行变换）；\n- 最后通过上三角矩阵判断解的情况。\n  <a name=\"rQdqY\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int n;\n    static double[][] a = new double[N][N];\n    static final double eps = 1e-6;\n    // 便于交换数组中的元素\n    public static void swap(int x1, int y1, int x2, int y2) { \n        double t = a[x1][y1];\n        a[x1][y1] = a[x2][y2];\n        a[x2][y2] = t;\n    }\n    public static int gauss() {\n        int c, r; // col row\n        for (c = 0, r = 0; c < n; c ++) {\n            // 标记当前列中最大元素行号\n            int t = r; \n            // 找到最大元素行号\n            for (int i = r; i < n; i ++) \n                if (Math.abs(a[i][c]) > Math.abs(a[t][c])) \n                    t = i;\n\n            // 若最大的一个元素为0，则该列不需要再进行处理\n            if(Math.abs(a[t][c]) < eps) continue; \n\n            // 将找到的这行换到第r行,从第c列开始（c列之前的全为零且能与之交换的也是0）\n            for (int i = c; i <= n; i ++)  swap(t, i, r, i); \n\n            // 将这一行所有的数除以这一行的第c个数（将第c个数化为1）\n            for (int i = n; i >= c; i --) a[r][i] /= a[r][c]; \n\n            // 将该列在该行一下的元素化为0，初等行变换（某一行减去某一行的若干倍）\n            for (int i = r + 1; i < n; i ++) { \n                // 若该列r行一下有元素本身是0，则元素所在行不需要进行处理\n                if (Math.abs(a[i][c]) > eps) \n                    for (int j  = n; j >= c; j --)  \n                        a[i][j] -= a[r][j] * a[i][c]; // 初等行变换\n            }\n            // 此处r也可以理解为增广矩阵的秩，可以通过秩判定唯一解/无穷多解/无解\n            r ++; \n        }\n\n        if (r < n) {\n            for (int i = r; i < n; i ++) {\n                // 如果系数为0，但多项式和不为0，则说明无解\n                if (Math.abs(a[i][n]) > eps) return 2; \n            }\n            // 否则为无穷多解\n            return 1; \n        }\n        // 唯一解的情况\n        else {\n            // 从倒数第二行往上解方程\n            for (int i = n - 2; i >= 0; i --) { \n                for (int j = i + 1; j < n; j ++) // i为行数，j为列数\n                    // 系数乘以未知数的值(值在该行的下一行(第j行)已经解出，并存放在a[][n])\n                    a[i][n] -= a[i][j] * a[j][n]; \n            }\n            return 0;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        n = Integer.parseInt(br.readLine());\n\n        // 读入增广矩阵\n        for (int i = 0; i < n; i ++) { \n            String[] s = br.readLine().split(\" \");\n            // 每行会多一个多项式的和\n            for (int j = 0; j <= n; j ++) { \n                a[i][j] = Double.parseDouble(s[j]);\n            }\n        }\n\n        int ans = gauss();\n        // 唯一解\n        if (ans == 0)  \n            for (int i = 0; i < n; i ++)\n                if(Math.abs(a[i][n]) < eps)\n                    // 避免数据存储时精度误差（例如存的答案为-0.00000000000001，如果保留两位小数会输出-0.00，答案应为0.00）\n                    System.out.printf(\"0.00\\n\"); \n                else\n                    System.out.printf(\"%.2f\\n\", a[i][n]);\n        else if (ans == 1) System.out.println(\"Infinite group solutions\"); // 无穷多解\n        else System.out.println(\"No solution\"); // 无解\n    }\n}\n```\n\n<a name=\"AdqL6\"></a>\n\n### 4.15 简单博弈论：[Nim游戏](https://www.acwing.com/activity/content/problem/content/961/)\n\n<a name=\"LQfgi\"></a>\n\n#### 算法思想：\n\n博弈论又被称为对策论(Game Theory)，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究已公式化的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。<br />以`Nim`游戏为例：给定`n`堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作（即没有石子可拿）的人视为失败。<br />问如果两人都采用最优策略，先手是否必胜？<br />**结论：**\n\n- 每堆石子的异或为`0`，则先手必败\n- 每堆石子的异或为`1`，则先手必胜\n  <a name=\"ksM19\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s = br.readLine().split(\" \");\n        int[] a = new int[100010];\n        int res = 0; \n        for (int i = 0; i < n; i ++) {\n            a[i] = Integer.parseInt(s[i]);\n            res ^= a[i];\n        }\n        if (res == 0) System.out.print(\"No\"); \n        else System.out.print(\"Yes\");\n    }\n}\n```\n\n<a name=\"NcXWE\"></a>\n\n## 第五章：动态规划\n\n<a name=\"C82gy\"></a>\n\n### 5.1背包问题\n\n> 考虑背包问题的时候，状态表示为：前`i`个物品（第一维），每增加一个限制，增加一维，然后再考虑对代码做等价变形优化空间。\n\n<a name=\"JIgg3\"></a>\n\n#### 5.1.1 01背包问题\n\n<a name=\"P5n2l\"></a>\n\n##### 问题描述：\n\n`01`背包问题描述的是：有`N`件物品和一个容量为`V`的背包。每件物品**只能使用一次**。其中，第`i`件物品的体积是`vi`，价值是`wi`，问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"WvGy2\"></a>\n\n##### 问题分析：\n\n![01背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_b1d88ac9d8-01背包.png)\n<a name=\"X3V7p\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++) {\n                f[i][j] = f[i - 1][j];\n                if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 空间优化\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++) {\n            for (int j = m; j >= v[i]; j --) {\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);\n            }\n        }\n        System.out.println(f[m]);\n    }\n}\n```\n\n优化成一维的说明：[对于01背包一维优化的理解](https://www.acwing.com/file_system/file/content/whole/index/content/4813/)\n<a name=\"nVgj8\"></a>\n\n#### 5.1.2 完全背包问题\n\n<a name=\"IayfS\"></a>\n\n##### 问题描述：\n\n有`N`种物品和一个容量为`V`的背包，每种物品都有**无限**件可以使用。其中，第`i`件物品的体积是`vi`，价值是`wi`。问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"jk44j\"></a>\n\n##### 问题分析：\n\n![完全背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_c1528506d8-完全背包.png) <br />**注：** 上图中的`k`从`1`开始枚举。也可以从`0`开始枚举，则`f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i])`\n<a name=\"aI24l\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    public static final int N = 1010;\n    public static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        int[] v = new int[N];\n        int[] w = new int[N];\n\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s2[0]);\n            w[i] = Integer.parseInt(s2[1]);\n        }\n\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++)\n                for (int k = 0; k * v[i] <= j; k ++)\n                    // 之所以没有写f[i][j] = f[i - 1][j]是因为完全背包在于第i个物品的个数，k层的f[i][j]实际上是k-1层算出来的f[i][j]。\n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 优化时间\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++)\n            for (int j = 0; j <= m; j ++) {\n                f[i][j] = f[i - 1][j];\n                // 根据f[i][j]与f[i][j - v[i]]的关系推出\n                if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]); \n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 优化时间+空间\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 1010;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int m = Integer.parseInt(s[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s1 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s1[0]);\n            w[i] = Integer.parseInt(s1[1]);\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = v[i]; j <= m; j ++) \n                // 完全背包终极写法与01背包很像，此处是从小到大遍历体积\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]); \n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"ipHIk\"></a>\n\n#### 5.1.3 多重背包问题\n\n<a name=\"eDfs7\"></a>\n\n##### 问题描述：\n\n有`N`种物品和一个容量为`V`的背包。第`i`件物品最多有`si`件，每件的体积为`vi`，价值为`wi`。问：将哪些物品装进背包，可使这些物品的体积不超过背包容量，且总价值最大。\n<a name=\"Gc4DY\"></a>\n\n##### 问题分析：\n\n多重背包问题的分析与完全背包问题几乎一样，只是对`k`多了一个限制（`k <= s[i]`）。\n<a name=\"Cp7OI\"></a>\n\n##### 代码实现：\n\n- 朴素版\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[] v = new int[N], w = new int[N], s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            v[i] = Integer.parseInt(s2[0]);\n            w[i] = Integer.parseInt(s2[1]);\n            s[i] = Integer.parseInt(s2[2]);\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) \n                for (int k = 0; k <= s[i] && k * v[i] <= j; k ++) \n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); // 代码几乎与完全背包差不多\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n- 二进制优化版\n\n> 多重背包二进制优化主要是将多重背包问题转换为01背包问题：将每种物品分解为若干堆，这些堆的数量总是能够凑出这种物品原来数量的任意一种取法（例如一种物品总共有8个，则将其分为1、2、4、1这几堆），然后将分堆后的每一堆物品都看作是一件新物品，再对这个些物品做一遍01背包就能求出最终的解。\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 25000;\n    static int[] v = new int[N], w = new int[N];\n    static int[] f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]), m = Integer.parseInt(s1[1]);\n        int cnt = 0; // 表示最终物品的堆数，每一对物品只有拿和不拿两种状态\n        for (int i = 1; i <= n; i ++) {\n            String[] s2 = br.readLine().split(\" \");\n            int a = Integer.parseInt(s2[0]); // 当前物品的单个体积\n            int b = Integer.parseInt(s2[1]); // 当前物品的单个价值\n            int s = Integer.parseInt(s2[2]); // 当前物品的总数量\n            int k = 1; // 将当前物品划分为很多堆，k表示每一堆的数量\n            while (k <= s) { // 二进制优化，将其转为01背包问题\n                cnt ++; // 每划分出一堆，总堆数加一\n                v[cnt] = k * a; // 计算出这一堆的总体积\n                w[cnt] = k * b; // 计算出这一对的总价值\n                s -= k; // 更新这种物品还剩的数量\n                k *= 2; // 更新k\n            }\n            if (s > 0) { // 若物品还有剩的，但是已经不足2^(k + 1)个，就直接将其看作新的一堆\n                cnt ++;\n                v[cnt] = a * s;\n                w[cnt] = b * s;\n            }\n        }\n        n = cnt; // 更新总物品堆数\n        // 做一遍 01 背包\n        for (int i = 1; i <= n; i ++)\n            for (int j = m; j >= v[i]; j --)\n                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);\n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"pNrJk\"></a>\n\n#### 5.1.4 分组背包问题：\n\n<a name=\"zTFFv\"></a>\n\n##### 问题描述：\n\n有`N`组物品和一个容量是`V`的背包。每组物品有若干个，同一组内的物品**最多只能选一个**。且每件物品的体积是 `v[i][j]`，价值是 `w[i][j]`，其中`i`是组号，`j`是组内编号。问：将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\n<a name=\"guQiS\"></a>\n\n##### 问题分析：\n\n![分组背包.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_df2a2e04d8-分组背包.png)\n<a name=\"jwkdC\"></a>\n\n##### 代码实现：\n\n- **朴素版：**\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[][] v = new int[N][N], w = new int[N][N];\n    static int[] s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        for (int i = 1; i <= n; i ++) {\n            s[i] = sc.nextInt();\n            for (int j = 1; j <= s[i]; j ++) {\n                v[i][j] = sc.nextInt();\n                w[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) \n                for (int k = 1; k <= s[i]; k ++) \n                    if(v[i][k] <= j)\n                        f[i][j] = Math.max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);\n        System.out.print(f[n][m]);\n    }\n}\n```\n\n- **一维版本：**\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 110;\n    static int[][] v = new int[N][N], w = new int[N][N];\n    static int[] s = new int[N], f = new int[N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int m = Integer.parseInt(s1[1]);\n        // 读入数据\n        for (int i = 1; i <= n; i ++) {\n            s[i] = Integer.parseInt(br.readLine());\n            for (int j = 1; j <= s[i]; j ++) {\n                String[] s2 = br.readLine().split(\" \");\n                v[i][j] = Integer.parseInt(s2[0]);\n                w[i][j] = Integer.parseInt(s2[1]);\n            }\n        }\n        // 有些许类似于01背包对于每个物品选或不选，倒着枚举j\n        for (int i = 1; i <= n; i ++)\n            for (int j = m; j >= 0; j --)\n                for (int k = 1; k <= s[i]; k ++)\n                    if (v[i][k] <= j)\n                        f[j] = Math.max(f[j], f[j - v[i][k]] + w[i][k]);\n        System.out.println(f[m]);\n    }\n}\n```\n\n<a name=\"q8rfI\"></a>\n\n### 5.2 线性dp\n\n<a name=\"U57un\"></a>\n\n#### 算法思想：\n\n这一类`Dp`先思考需要用几维来表示集合、每个集合表示的是什么、然后再思考需要将每个集合分成哪几个部分，且这几个部分均能够用已知集合推导出来。<br />线性`Dp`以**最长公共子序列**这道题为例，进行分析。\n\n- **问题描述：** 给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\n- **问题分析：**\n    - 首先思考需要用几维来表示集合：本题是两个字符串，且问的是这两个字符串之间的关系，那么根据经验，可以使用二维数组表示集合；\n    - 每个集合分别表示什么：`f[i][j]`表示所有在第一个字符串的前`i`个字母中出现，且在第二个字符串的前`j`个字母中出现的子序列；\n    - 每个集合需要分为哪几个部分：可以按照是否包含第`i`个字母或是否包含第`j`个字母分为`4`部分。\n\n![最长公共子序列.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_59623a75d8-最长公共子序列.png)\n<a name=\"qVhdh\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\npublic class Main {\n    static final int N = 1010;\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        char[] a = (\" \" + sc.next()).toCharArray();\n        char[] b = (\" \" + sc.next()).toCharArray();\n        for (int i = 1; i <= n; i ++) \n            for (int j = 1; j <= m; j ++) {\n                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n                if (a[i] == b[j]) \n                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);\n            }\n        System.out.println(f[n][m]);\n    }\n}\n```\n\n<a name=\"P7uPa\"></a>\n\n### 5.3 区间dp\n\n<a name=\"BIPvq\"></a>\n\n#### 算法思想：\n\n区间`Dp`的题目通常的枚举顺序是：先枚举区间长度，再枚举左端点、再枚举决策。<br />下面将以[石子合并](https://www.acwing.com/problem/content/284/)这道题为例进行分析：<br />**题目描述：** 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。<br />每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。<br />每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。<br />例如有 $4$ 堆石子分别为 `1 3 5 2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1、2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；<br />如果第二步是先合并 $2、3$ 堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。<br />问题是：找出一种合理的方法，使总的代价最小，输出最小代价。\n\n- **问题分析：**\n\n![合并石子分析.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_76a65135d8-合并石子分析.png)\n<a name=\"LMDk7\"></a>\n\n#### 代码实现：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int N = 310, INF = 0x3f3f3f3f;\n    static int[] s = new int[N];\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] s1 = br.readLine().split(\" \");\n        for (int i = 1; i <= n; i ++) s[i] = Integer.parseInt(s1[i - 1]);\n        for (int i = 1; i <= n; i ++) s[i] += s[i - 1]; // 预处理前缀和\n\n        for (int len = 2; len <= n; len ++) { // 按照区间长度从小到大枚举\n            for (int i = 1; i + len - 1 <= n; i ++) { // i实际上就是左端点\n                int l = i, r = i + len - 1; // 定义左右端点\n                f[l][r] = INF; // 初始化f[l][r]，否则全是0，最小代价会被错误地更新\n                for (int k = l; k < r; k ++) { // 从左端点开始，遍历每个分界点\n                    // f[l][r]最终是由两个大区间合并，f[l][r]等于这两个大区间自身合并所需代价加合并这两个区间的代价\n                    f[l][r] = Math.min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n                }\n            }\n        }\n        System.out.print(f[1][n]); // 输出合并1~n这个区间的最小代价\n    }\n}\n```\n\n**区间`dp`总结：**\n\n1. 枚举区间长度`len`，`len`通常为`2 ~ n`;\n2. 枚举区间左端点（一般`i` 从第一个元素开始，右端点`i + len - 1`不能越界）；\n3. 进行决策：\n\n- 若有区间分界点，则枚举分界点（一般左端点位置为第一个分界点，右端点上一个位置为最后一个分界点）\n- 若不需要分界点，则直接进行决策\n  <a name=\"iKwRF\"></a>\n\n### 5.4 计数类dp\n\n<a name=\"qpN02\"></a>\n\n#### 算法思想：\n\n计数类`Dp`实际上就是计数类完全背包问题，只是在集合表示和集合属性上略有不同。计数类`Dp`中，`f[i][j]`的每一部分代表的就是该部分的数量，不需要加上价值，而完全背包则需要加上其价值。\n<a name=\"f4FaA\"></a>\n\n#### 问题分析：\n\n笔误：集合表示只从前`i`个数中选，且总体积恰好是`j`的选法<br />![计数类Dp.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_858eefcdd8-计数类Dp.png)\n<a name=\"t8sQG\"></a>\n\n#### 代码实现：\n\n- 优化时间\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static final int N = 1010, MOD = (int)(1e9 + 7);\n    static int[][] f = new int[N][N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        f[0][0] = 1;\n        for (int i = 1; i <= n; i ++) {\n            for (int j = 0; j <= n; j ++) {\n                // j需要从0开始遍历，当 j >= i 时，才有f[i] [j] = (f[i - 1] [j] + f[i] [j - i])这一步的转移，同完全背包朴素版。如果上面初始化时，将f[1~n][0]都初始化成1，那么这里的j可以从1开始\n                f[i][j] = f[i - 1][j] % MOD;\n                if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % MOD;\n            }\n        }\n        System.out.print(f[n][n]);\n    }\n}\n```\n\n- 优化时间+空间\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    static final int N = 1010, MOD = (int)(1e9 + 7);\n    static int[] f = new int[N];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        f[0] = 1;\n        for (int i = 1; i <= n; i ++) \n            for (int j = i; j <= n; j ++) \n                f[j] = (f[j] + f[j - i]) % MOD;\n        System.out.print(f[n]);\n    } \n}\n```\n\n<a name=\"UdzpI\"></a>\n\n### 5.5 状态压缩dp\n\n<a name=\"hY4p6\"></a>\n\n#### 算法思想：\n\n状态压缩dp的思想就是用一个数的二进制表现形式表示二维状态中某一维的状态。<br />**以蒙德里安的梦想这道题为例：**\n\n> [蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)：求把$N \\times M$的棋盘分割成若干个$1 \\times 2$的长方形，有多少种方案。\n> 例如$2 \\times 4$的棋盘的方案有：![5.5状态压缩dp.png](https://cdn.acwing.com/media/article/image/2024/03/02/126318_d419c420d8-5.5状态压缩dp.png)\n\n题目中要求使用`1 × 2`的小方格把棋盘填满，那么我们可以横着填，也可以竖着填。当我们把横着填的长方形填完，那么竖着填的小方格的方案就是唯一的。因此我们只需要考虑横着填的长方形有多少种填法。<br />我们分析每一列，用一个二进制数表示该列长方形的摆放状态。如果该列的某一行是`0`，则表示该列的这行没有摆放长方形，`1`则是摆放了长方形。例如上面例图中的`2 × 4`棋盘，第二个摆放方案对应的状态表示为$\\begin{bmatrix}\n1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 0\n\\end{bmatrix}$，那么我们可以用`3`表示第一列和第二列的状态，用`0`表示第三列和第四列的状态。<br />**如何判断每一列的状态是不是一个合法的状态？**<br />我们要知道，不是每一个数都能表示一个列的状态的，因为这是实际问题。例如，`11`的二进制表示`1011`就不是一个合法的状态，因为如果当前列这样摆放，那么竖着的长方形就无法摆放。<br />因此，只要一个数的二进制表示中出现了连续的奇数个`0`时，则该数就不是一个合法的状态。<br />**如何进行状态转移？**<br />首先我们定义状态数组$f[i][j]$表示前$i$列摆放完成的所有方案数。<br />$f[i][j]$表示所有能从上一个列的状态转移过来的方案数之和。\n\n> 假设第$i - 1$列被戳的状态为$k$，第$i$列被戳状态为$j$。（只考虑二进制表示中的$1$全部由上一列戳出的情况），**那么这样第**$i - 1$**列被戳和戳出的情况的考虑完了（即第**$i - 1$**列的状态为**$j \\mid k$**）**。\n\n**能够从第**$i - 1$**列戳到第**$i$**列的条件（能转移的条件，实际就是在判断第**$i- 1$**列的状态和转移方式是否合法）：**\n\n- 第$i - 1$与第$i$列不能同时被戳（`j & k = 0`）\n- 在确定第$i- 1$列被戳或向后戳出后所剩下的位置要能够摆放竖着的长方形（状态的二进制表示不能有连续奇数个`0`：即`j | k`的二进制表示不能有连续奇数个`0`）\n\n**状态转移方程：**\n\n```java\nif (满足能够从第i - 1列戳到第i列的条件)\n    f[i][j] += f[i - 1][k];\n```\n\n**初始化与答案：**<br />根据$f[i][j]$的含义，第$0$列是不会被戳的，因此其上一列（虚拟）全是竖着摆放方块的（只有这一种方案），所以$f[0][0] = 1$。<br />当我们将全部的$m$列（$0 \\sim m - 1$）摆好时，第$m$列（不需要摆放方块的列）没有被戳的所有方案数之和即为答案，即$f[m][0]$。\n<a name=\"c9j85\"></a>\n\n#### 代码实现：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    static final int N = 12, M = 1 << 12;\n    static long[][] f = new long[N][M];\n    static boolean[] st = new boolean[M];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt(), m = sc.nextInt();\n            if (n == 0 && m == 0) break;\n            // 预处理每个状态的合法性\n            Arrays.fill(st, true);\n            for (int i = 0; i < 1 << n; i ++) {\n                int cnt = 0;\n                for (int j = 0; j < n; j ++)\n                    if (((i >> j) & 1) == 1) {\n                        if ((cnt & 1) > 0) {\n                            st[i] = false;\n                            break;\n                        }\n                    }\n                    else cnt ++;\n                if ((cnt & 1) > 0) st[i] = false;\n            }\n            for (int i = 0; i < N; i ++) Arrays.fill(f[i], 0);\n            f[0][0] = 1;\n            // 状态转移\n            for (int i = 1; i <= m; i ++)\n                for (int j = 0; j < 1 << n; j ++)\n                    for (int k = 0; k < 1 << n; k ++)\n                        if ((j & k) == 0 && st[j | k])\n                            f[i][j] += f[i - 1][k];\n            System.out.println(f[m][0]);\n        }\n    }\n}\n```\n\n<a name=\"DZPyh\"></a>\n\n## 第六章：由不同数据范围反推时间复杂度和算法内容\n\n1. $n \\leq 30 \\Rightarrow$指数级别：`dfs + 剪枝`、`状态压缩dp`\n2. $n \\leq 100 \\Rightarrow \\mathcal{O}(n^3)$：`floyd`、`dp`、`高斯消元`\n3. $n \\leq 1000 \\Rightarrow \\mathcal{O}(n^2) 或 \\mathcal{O}(n^2 \\log n)$：`dp`、`二分`、`朴素Dijkstra`、`朴素版Prim`、`Bellman-Ford`\n4. $n \\leq 10000 \\Rightarrow \\mathcal{O}(n \\times \\sqrt{n})$：`块状链表`、`分块`、`莫队`\n5. $n \\leq 10^5 \\Rightarrow \\mathcal{O}(n \\log n)$：`各种sort`、`线段树`、`树状数组`、`set/map`、`heap`、`拓扑排序`、`dijkstra + heap`、`prim + heap`、`Kruskal`、`spfa`、`求凸包`、`求半平面交`、`二分`、`CDQ分治`、`整体二分`、`后缀数组`、`树链剖分`、`动态树`\n6. $n \\leq 10^6 \\Rightarrow \\mathcal{O}(n)或常数较小的\\mathcal{O}(n \\log n)$：`单调队列`、`hash`、`双指针`、`并查集`，`kmp`、`AC自动机`、`sort`、`树状数组`、`heap`、`dijkstra`、`spfa`\n7. $n \\leq 10^7 \\Rightarrow \\mathcal{O}(n)$：`双指针`、`kmp`、`AC自动机`、`线性筛质数`\n8. $n \\leq 10^9 \\Rightarrow \\mathcal{O}(\\sqrt{n})$：`试除法判断质数`\n9. $n \\leq 10^{18} \\Rightarrow \\mathcal{O}(\\log n)$：`最大公约数`，`快速幂`，`数位dp`\n10. $n \\leq 10^{1000} \\Rightarrow \\mathcal{O}((\\log n)^2)(\\log n 表示位数)$：`高精度加减乘除`\n11. $n \\leq 10^{100000} \\Rightarrow \\mathcal{O}(\\log k \\times \\log\\log k)(k表示位数)$：`高精度加减`、`FFT/NTT`","categories":["算法"]}]